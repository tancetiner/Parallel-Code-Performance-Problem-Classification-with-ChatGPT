{"messages": [{"role": "system", "content": "You are a parallel computing expert. I will provide you a source code in C or C++ and I want you to classify if there is an inefficiency problem in the code. If there is an problem, I want you to classify this problem from the following list: ['Memory/Data locality', 'Micro-architectural inefficiency', 'Vector/SIMD parallelism', 'GPU parallelism', 'Instruction level parallelism', 'Task parallelism', 'small parallel region', 'Inefficeint thread mapping / inefficient block size / Load imbalance', 'Under-parallelization', 'Over-Parallelization', 'Unncessary locks', 'Unncessary strong memory consistency', 'Lock management overhead', 'Unnecessary synchronization', 'Unnecessary process communiction', 'Unnecessary operation/traversal/function call', 'Redundant operation', 'Expensive operation', 'Frequent  function call', 'Inefficient data-structure library', 'Usage of improper data type', 'memory leak', 'repreated memory allocation', 'Redundant memory allocation', 'Slower memory allocation library call', 'Insufficient memory', 'unnecessary data copy', 'sequential I/O operation', 'over parallelization', 'boundary condition check', 'Unintentional Programming logic error', 'Inefficiency due to new compiler version '] and return an answer with the following format and this format only, don't provide explanation: Type: classified_type."}, {"role": "user", "content": "/*\n//@HEADER\n// ************************************************************************\n//\n//                        Kokkos v. 2.0\n//              Copyright (2014) Sandia Corporation\n//\n// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,\n// the U.S. Government retains certain rights in this software.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// 1. Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the Corporation nor the names of the\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Questions? Contact  H. Carter Edwards (hcedwar@sandia.gov)\n//\n// ************************************************************************\n//@HEADER\n*/\n\n#ifndef KOKKOS_WORKGRAPHPOLICY_HPP\n#define KOKKOS_WORKGRAPHPOLICY_HPP\n\nnamespace Kokkos {\nnamespace Impl {\n\ntemplate< class functor_type , class execution_space, class ... policy_args >\nclass WorkGraphExec;\n\n}} // namespace Kokkos::Impl\n\nnamespace Kokkos {\n\ntemplate< class ... Properties >\nclass WorkGraphPolicy\n{\npublic:\n\n  using self_type       = WorkGraphPolicy<Properties ... >;\n  using traits          = Kokkos::Impl::PolicyTraits<Properties ... >;\n  using index_type      = typename traits::index_type;\n  using member_type     = index_type;\n  using work_tag        = typename traits::work_tag;\n  using execution_space = typename traits::execution_space;\n  using memory_space    = typename execution_space::memory_space;\n  using graph_type      = Kokkos::Crs<index_type,execution_space,void,index_type>;\n\n  enum : std::int32_t {\n    END_TOKEN       = -1 ,\n    BEGIN_TOKEN     = -2 ,\n    COMPLETED_TOKEN = -3 };\n\nprivate:\n\n  using ints_type = Kokkos::View<std::int32_t*, memory_space>;\n\n  // Let N = m_graph.numRows(), the total work\n  // m_queue[  0 ..   N-1] = the ready queue\n  // m_queue[  N .. 2*N-1] = the waiting queue counts\n  // m_queue[2*N .. 2*N+2] = the ready queue hints\n\n  graph_type const m_graph;\n  ints_type        m_queue ;\n\n  KOKKOS_INLINE_FUNCTION\n  void push_work( const std::int32_t w ) const noexcept\n    {\n      const std::int32_t N = m_graph.numRows();\n\n      std::int32_t volatile * const ready_queue = & m_queue[0] ;\n      std::int32_t volatile * const end_hint    = & m_queue[2*N+1] ;\n\n      // Push work to end of queue\n      const std::int32_t j = atomic_fetch_add( end_hint , 1 );\n\n      if ( ( N <= j ) ||\n           ( END_TOKEN != atomic_exchange(ready_queue+j,w) ) ) {\n        // ERROR: past the end of queue or did not replace END_TOKEN\n        Kokkos::abort(\"WorkGraphPolicy push_work error\");\n      }\n\n      memory_fence();\n    }\n\npublic:\n\n  /**\\brief  Attempt to pop the work item at the head of the queue.\n   *\n   *  Find entry 'i' such that\n   *    ( m_queue[i] != BEGIN_TOKEN ) AND\n   *    ( i == 0 OR m_queue[i-1] == BEGIN_TOKEN )\n   *  if found then\n   *    increment begin hint\n   *    return atomic_exchange( m_queue[i] , BEGIN_TOKEN )\n   *  else if i < total work\n   *    return END_TOKEN\n   *  else\n   *    return COMPLETED_TOKEN\n   *  \n   */\n  KOKKOS_INLINE_FUNCTION\n  std::int32_t pop_work() const noexcept\n    {\n      const std::int32_t N = m_graph.numRows();\n\n      std::int32_t volatile * const ready_queue = & m_queue[0] ;\n      std::int32_t volatile * const begin_hint  = & m_queue[2*N] ;\n\n      // begin hint is guaranteed to be less than or equal to\n      // actual begin location in the queue.\n\n      for ( std::int32_t i = *begin_hint ; i < N ; ++i ) {\n\n        const std::int32_t w = ready_queue[i] ;\n\n        if ( w == END_TOKEN ) { return END_TOKEN ; }\n\n        if ( ( w != BEGIN_TOKEN ) &&\n             ( w == atomic_compare_exchange<std::int32_t>(ready_queue+i,w,BEGIN_TOKEN) ) ) {\n          // Attempt to claim ready work index succeeded,\n          // update the hint and return work index\n          atomic_increment( begin_hint );\n          return w ;\n        }\n        // arrive here when ready_queue[i] == BEGIN_TOKEN\n      }\n\n      return COMPLETED_TOKEN ;\n    }\n\n\n  KOKKOS_INLINE_FUNCTION\n  void completed_work( std::int32_t w ) const noexcept\n    {\n      Kokkos::memory_fence();\n\n      // Make sure the completed work function's memory accesses are flushed.\n\n      const std::int32_t N = m_graph.numRows();\n\n      std::int32_t volatile * const count_queue = & m_queue[N] ;\n\n      const std::int32_t B = m_graph.row_map(w);\n      const std::int32_t E = m_graph.row_map(w+1);\n\n      for ( std::int32_t i = B ; i < E ; ++i ) {\n        const std::int32_t j = m_graph.entries(i);\n        if ( 1 == atomic_fetch_add(count_queue+j,-1) ) {\n          push_work(j);\n        }\n      }\n    }\n\n  struct TagInit {};\n  struct TagCount {};\n  struct TagReady {};\n\n  /**\\brief  Initialize queue\n   *\n   *  m_queue[0..N-1] = END_TOKEN, the ready queue\n   *  m_queue[N..2*N-1] = 0, the waiting count queue\n   *  m_queue[2*N..2*N+1] = 0, begin/end hints for ready queue\n   */\n  KOKKOS_INLINE_FUNCTION\n  void operator()( const TagInit , int i ) const noexcept\n    { m_queue[i] = i < m_graph.numRows() ? END_TOKEN : 0 ; }\n\n  KOKKOS_INLINE_FUNCTION\n  void operator()( const TagCount , int i ) const noexcept\n    {\n      std::int32_t volatile * const count_queue =\n        & m_queue[ m_graph.numRows() ] ;\n\n      atomic_increment( count_queue + m_graph.entries[i] );\n    }\n\n  KOKKOS_INLINE_FUNCTION\n  void operator()( const TagReady , int w ) const noexcept\n    {\n      std::int32_t const * const count_queue =\n        & m_queue[ m_graph.numRows() ] ;\n\n      if ( 0 == count_queue[w] ) push_work(w);\n    }\n\n  WorkGraphPolicy( const graph_type & arg_graph )\n    : m_graph(arg_graph)\n    , m_queue( view_alloc( \"queue\" , WithoutInitializing )\n             , arg_graph.numRows() * 2 + 2 )\n  {\n    { // Initialize\n      using policy_type = RangePolicy<std::int32_t, execution_space, TagInit>;\n      using closure_type = Kokkos::Impl::ParallelFor<self_type, policy_type>;\n      const closure_type closure(*this, policy_type(0, m_queue.size()));\n      closure.execute();\n      execution_space::fence();\n    }\n\n    { // execute-after counts\n      using policy_type = RangePolicy<std::int32_t, execution_space, TagCount>;\n      using closure_type = Kokkos::Impl::ParallelFor<self_type, policy_type>;\n      const closure_type closure(*this,policy_type(0,m_graph.entries.size()));\n      closure.execute();\n      execution_space::fence();\n    }\n\n    { // Scheduling ready tasks\n      using policy_type = RangePolicy<std::int32_t, execution_space, TagReady>;\n      using closure_type = Kokkos::Impl::ParallelFor<self_type, policy_type>;\n      const closure_type closure(*this,policy_type(0,m_graph.numRows()));\n      closure.execute();\n      execution_space::fence();\n    }\n  }\n};\n\n} // namespace Kokkos\n\n#ifdef KOKKOS_ENABLE_SERIAL\n#include \"impl/Kokkos_Serial_WorkGraphPolicy.hpp\"\n#endif\n\n#ifdef KOKKOS_ENABLE_OPENMP\n#include \"OpenMP/Kokkos_OpenMP_WorkGraphPolicy.hpp\"\n#endif\n\n#ifdef KOKKOS_ENABLE_CUDA\n#include \"Cuda/Kokkos_Cuda_WorkGraphPolicy.hpp\"\n#endif\n\n#ifdef KOKKOS_ENABLE_THREADS\n#include \"Threads/Kokkos_Threads_WorkGraphPolicy.hpp\"\n#endif\n\n#endif /* #define KOKKOS_WORKGRAPHPOLICY_HPP */\n"}, {"role": "assistant", "content": "Type: no inefficiency problem."}]}
{"messages": [{"role": "system", "content": "You are a parallel computing expert. I will provide you a source code in C or C++ and I want you to classify if there is an inefficiency problem in the code. If there is an problem, I want you to classify this problem from the following list: ['Memory/Data locality', 'Micro-architectural inefficiency', 'Vector/SIMD parallelism', 'GPU parallelism', 'Instruction level parallelism', 'Task parallelism', 'small parallel region', 'Inefficeint thread mapping / inefficient block size / Load imbalance', 'Under-parallelization', 'Over-Parallelization', 'Unncessary locks', 'Unncessary strong memory consistency', 'Lock management overhead', 'Unnecessary synchronization', 'Unnecessary process communiction', 'Unnecessary operation/traversal/function call', 'Redundant operation', 'Expensive operation', 'Frequent  function call', 'Inefficient data-structure library', 'Usage of improper data type', 'memory leak', 'repreated memory allocation', 'Redundant memory allocation', 'Slower memory allocation library call', 'Insufficient memory', 'unnecessary data copy', 'sequential I/O operation', 'over parallelization', 'boundary condition check', 'Unintentional Programming logic error', 'Inefficiency due to new compiler version '] and return an answer with the following format and this format only, don't provide explanation: Type: classified_type."}, {"role": "user", "content": "/*******************************************************\n * Copyright (c) 2014, ArrayFire\n * All rights reserved.\n *\n * This file is distributed under 3-clause BSD license.\n * The complete license agreement can be obtained at:\n * http://arrayfire.com/licenses/BSD-3-Clause\n ********************************************************/\n\n#pragma once\n#include <kernel_headers/sort_pair.hpp>\n#include <kernel/sort_by_key.hpp>\n#include <kernel/sort_helper.hpp>\n#include <program.hpp>\n#include <memory.hpp>\n#include <traits.hpp>\n#include <string>\n#include <mutex>\n#include <dispatch.hpp>\n#include <Param.hpp>\n#include <debug_opencl.hpp>\n#include <math.hpp>\n#include <kernel/iota.hpp>\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n\n#include <boost/compute/core.hpp>\n#include <boost/compute/algorithm/sort_by_key.hpp>\n#include <boost/compute/functional/operator.hpp>\n#include <boost/compute/iterator/buffer_iterator.hpp>\n#include <boost/compute/algorithm/copy.hpp>\n#include <boost/compute/algorithm/transform.hpp>\n#include <boost/compute/container/vector.hpp>\n#include <boost/compute/functional/get.hpp>\n#include <boost/compute/functional/field.hpp>\n#include <boost/compute/types/pair.hpp>\n\nnamespace compute = boost::compute;\n\nusing cl::Buffer;\nusing cl::Program;\nusing cl::Kernel;\nusing cl::KernelFunctor;\nusing cl::EnqueueArgs;\nusing cl::NDRange;\nusing std::string;\n\ntemplate<typename Tk, typename Tv, bool isAscending>\ninline\nboost::compute::function<bool(const std::pair<Tk, Tv>, const std::pair<Tk, Tv>)>\nmakeCompareFunction()\n{\n    // Cannot use isAscending in BOOST_COMPUTE_FUNCTION\n    if(isAscending) {\n        BOOST_COMPUTE_FUNCTION(bool, IPCompare, (std::pair<Tk, Tv> lhs, std::pair<Tk, Tv> rhs),\n            {\n                return lhs.first < rhs.first;\n            }\n        );\n        return IPCompare;\n    } else {\n        BOOST_COMPUTE_FUNCTION(bool, IPCompare, (std::pair<Tk, Tv> lhs, std::pair<Tk, Tv> rhs),\n            {\n                return lhs.first > rhs.first;\n            }\n        );\n        return IPCompare;\n    }\n}\n\ntemplate<typename Tk>\ninline boost::compute::function<Tk(Tk)>\nflipFunction()\n{\n    BOOST_COMPUTE_FUNCTION(Tk, negateFn, (const Tk x),\n        {\n            return -x;\n        }\n    );\n\n    return negateFn;\n}\n\n#define INSTANTIATE_FLIP(TY, XMAX)                              \\\ntemplate<> inline boost::compute::function<TY(TY)>              \\\nflipFunction<TY>()                                              \\\n{                                                               \\\n    BOOST_COMPUTE_FUNCTION(TY, negateFn, (const TY x),          \\\n       {                                                        \\\n            return XMAX - x;                                    \\\n        }                                                       \\\n    );                                                          \\\n                                                                \\\n    return negateFn;                                            \\\n}\n\nINSTANTIATE_FLIP(unsigned, UINT_MAX)\nINSTANTIATE_FLIP(unsigned short, USHRT_MAX)\nINSTANTIATE_FLIP(unsigned char, UCHAR_MAX)\nINSTANTIATE_FLIP(cl_ulong, ULONG_MAX)\n\n#undef INSTANTIATE_FLIP\n\nnamespace opencl\n{\n    namespace kernel\n    {\n        static const int copyPairIter = 4;\n\n        template<typename Tk, typename Tv>\n        void makePair(cl::Buffer *out, const cl::Buffer *first, const cl::Buffer *second, const unsigned N)\n        {\n            try {\n                static std::once_flag compileFlags[DeviceManager::MAX_DEVICES];\n                static std::map<int, Program*>   sortPairProgs;\n                static std::map<int, Kernel*>  sortPairKernels;\n\n                int device = getActiveDeviceId();\n\n                std::call_once( compileFlags[device], [device] () {\n                    std::ostringstream options;\n                    options << \" -D Tk=\"      << dtype_traits<Tk>::getName()\n                            << \" -D Tv=\"      << dtype_traits<Tv>::getName()\n                            << \" -D copyPairIter=\" << copyPairIter;\n                    if (std::is_same<Tk, double >::value ||\n                        std::is_same<Tk, cdouble>::value ||\n                        std::is_same<Tv, double >::value ||\n                        std::is_same<Tv, cdouble>::value) {\n                        options << \" -D USE_DOUBLE\";\n                    }\n                    Program prog;\n                    buildProgram(prog, sort_pair_cl, sort_pair_cl_len, options.str());\n                    sortPairProgs[device]   = new Program(prog);\n                    sortPairKernels[device] = new Kernel(*sortPairProgs[device], \"make_pair_kernel\");\n                });\n\n                auto makePairOp = KernelFunctor<Buffer, const Buffer, const Buffer, const unsigned>\n                                          (*sortPairKernels[device]);\n\n                NDRange local(256, 1, 1);\n                NDRange global(local[0] * divup(N, local[0] * copyPairIter), 1, 1);\n\n                makePairOp(EnqueueArgs(getQueue(), global, local), *out, *first, *second, N);\n\n                CL_DEBUG_FINISH(getQueue());\n            } catch (cl::Error err) {\n                CL_TO_AF_ERROR(err);\n                throw;\n            }\n        }\n\n        template<typename Tk, typename Tv>\n        void splitPair(cl::Buffer *first, cl::Buffer *second, const cl::Buffer *in, const unsigned N)\n        {\n            try {\n                static std::once_flag compileFlags[DeviceManager::MAX_DEVICES];\n                static std::map<int, Program*>   sortPairProgs;\n                static std::map<int, Kernel*>  sortPairKernels;\n\n                int device = getActiveDeviceId();\n\n                std::call_once( compileFlags[device], [device] () {\n                    std::ostringstream options;\n                    options << \" -D Tk=\"      << dtype_traits<Tk>::getName()\n                            << \" -D Tv=\"      << dtype_traits<Tv>::getName()\n                            << \" -D copyPairIter=\" << copyPairIter;\n                    if (std::is_same<Tk, double >::value ||\n                        std::is_same<Tk, cdouble>::value ||\n                        std::is_same<Tv, double >::value ||\n                        std::is_same<Tv, cdouble>::value) {\n                        options << \" -D USE_DOUBLE\";\n                    }\n                    Program prog;\n                    buildProgram(prog, sort_pair_cl, sort_pair_cl_len, options.str());\n                    sortPairProgs[device]   = new Program(prog);\n                    sortPairKernels[device] = new Kernel(*sortPairProgs[device], \"split_pair_kernel\");\n                });\n\n                auto splitPairOp = KernelFunctor<Buffer, Buffer, const Buffer, const unsigned>\n                                          (*sortPairKernels[device]);\n\n                NDRange local(256, 1, 1);\n                NDRange global(local[0] * divup(N, local[0] * copyPairIter), 1, 1);\n\n                splitPairOp(EnqueueArgs(getQueue(), global, local), *first, *second, *in, N);\n\n                CL_DEBUG_FINISH(getQueue());\n            } catch (cl::Error err) {\n                CL_TO_AF_ERROR(err);\n                throw;\n            }\n        }\n\n        template<typename Tk, typename Tv>\n        void sort0ByKeyIterative(Param pKey, Param pVal, bool isAscending)\n        {\n            try {\n                compute::command_queue c_queue(getQueue()());\n\n                compute::buffer pKey_buf((*pKey.data)());\n                compute::buffer pVal_buf((*pVal.data)());\n\n                for(int w = 0; w < pKey.info.dims[3]; w++) {\n                    int pKeyW = w * pKey.info.strides[3];\n                    int pValW = w * pVal.info.strides[3];\n                    for(int z = 0; z < pKey.info.dims[2]; z++) {\n                        int pKeyWZ = pKeyW + z * pKey.info.strides[2];\n                        int pValWZ = pValW + z * pVal.info.strides[2];\n                        for(int y = 0; y < pKey.info.dims[1]; y++) {\n\n                            int pKeyOffset = pKeyWZ + y * pKey.info.strides[1];\n                            int pValOffset = pValWZ + y * pVal.info.strides[1];\n\n                            compute::buffer_iterator< type_t<Tk> > start= compute::make_buffer_iterator< type_t<Tk> >(pKey_buf, pKeyOffset);\n                            compute::buffer_iterator< type_t<Tk> > end  = compute::make_buffer_iterator< type_t<Tk> >(pKey_buf, pKeyOffset + pKey.info.dims[0]);\n                            compute::buffer_iterator< type_t<Tv> > vals = compute::make_buffer_iterator< type_t<Tv> >(pVal_buf, pValOffset);\n                            if(isAscending) {\n                                compute::sort_by_key(start, end, vals, c_queue);\n                            } else {\n                                compute::sort_by_key(start, end, vals,\n                                                     compute::greater< type_t<Tk> >(), c_queue);\n                            }\n                        }\n                    }\n                }\n\n                CL_DEBUG_FINISH(getQueue());\n            } catch (cl::Error err) {\n                CL_TO_AF_ERROR(err);\n                throw;\n            }\n        }\n\n        template<typename Tk_, typename Tv_>\n        void sortByKeyBatched(Param pKey, Param pVal, const int dim, bool isAscending)\n        {\n            typedef type_t<Tk_> Tk;\n            typedef type_t<Tv_> Tv;\n\n            try {\n                af::dim4 inDims;\n                for(int i = 0; i < 4; i++)\n                    inDims[i] = pKey.info.dims[i];\n\n                // Sort dimension\n                // tileDims * seqDims = inDims\n                af::dim4 tileDims(1);\n                af::dim4 seqDims = inDims;\n                tileDims[dim] = inDims[dim];\n                seqDims[dim] = 1;\n\n                // Create/call iota\n                // Array<Tv> key = iota<Tv>(seqDims, tileDims);\n                cl::Buffer* key = bufferAlloc(inDims.elements() * sizeof(unsigned));\n                Param pSeq;\n                pSeq.data = key;\n                pSeq.info.offset = 0;\n                pSeq.info.dims[0] = inDims[0];\n                pSeq.info.strides[0] = 1;\n                for(int i = 1; i < 4; i++) {\n                    pSeq.info.dims[i] = inDims[i];\n                    pSeq.info.strides[i] = pSeq.info.strides[i - 1] * pSeq.info.dims[i - 1];\n                }\n                kernel::iota<unsigned>(pSeq, seqDims, tileDims);\n\n                int elements = inDims.elements();\n\n                // Flat - Not required since inplace and both are continuous\n                //val.modDims(inDims.elements());\n                //key.modDims(inDims.elements());\n\n                // Sort indices\n                // sort_by_key<T, Tv, isAscending>(*resVal, *resKey, val, key, 0);\n                //kernel::sort0_by_key<T, Tv, isAscending>(pVal, pKey);\n                compute::command_queue c_queue(getQueue()());\n                compute::context c_context(getContext()());\n\n                // Create buffer iterators for seq\n                compute::buffer pSeq_buf((*pSeq.data)());\n                compute::buffer_iterator<unsigned> seq0 = compute::make_buffer_iterator<unsigned>(pSeq_buf, 0);\n                compute::buffer_iterator<unsigned> seqN = compute::make_buffer_iterator<unsigned>(pSeq_buf, elements);\n                // Create buffer iterators for key and val\n                compute::buffer pKey_buf((*pKey.data)());\n                compute::buffer pVal_buf((*pVal.data)());\n                compute::buffer_iterator<Tk> key0 = compute::make_buffer_iterator<Tk>(pKey_buf, 0);\n                compute::buffer_iterator<Tk> keyN = compute::make_buffer_iterator<Tk>(pKey_buf, elements);\n                compute::buffer_iterator<Tv> val0 = compute::make_buffer_iterator<Tv>(pVal_buf, 0);\n                compute::buffer_iterator<Tv> valN = compute::make_buffer_iterator<Tv>(pVal_buf, elements);\n\n                // Sort By Key for descending is stable in the reverse\n                // (greater) order. Sorting in ascending with negated values\n                // will give the right result\n                if(!isAscending) compute::transform(key0, keyN, key0, flipFunction<Tk>(), c_queue);\n\n                // Create a copy of the pKey buffer\n                cl::Buffer* cKey = bufferAlloc(elements * sizeof(Tk));\n                compute::buffer cKey_buf((*cKey)());\n                compute::buffer_iterator<Tk> cKey0 = compute::make_buffer_iterator<Tk>(cKey_buf, 0);\n                compute::buffer_iterator<Tk> cKeyN = compute::make_buffer_iterator<Tk>(cKey_buf, elements);\n                compute::copy(key0, keyN, cKey0, c_queue);\n\n                // FIRST SORT\n                compute::sort_by_key(key0, keyN, seq0, c_queue);\n                compute::sort_by_key(cKey0, cKeyN, val0, c_queue);\n\n                // Create a copy of the seq buffer after first sort\n                cl::Buffer* cSeq = bufferAlloc(elements * sizeof(unsigned));\n                compute::buffer cSeq_buf((*cSeq)());\n                compute::buffer_iterator<unsigned> cSeq0 = compute::make_buffer_iterator<unsigned>(cSeq_buf, 0);\n                compute::buffer_iterator<unsigned> cSeqN = compute::make_buffer_iterator<unsigned>(cSeq_buf, elements);\n                compute::copy(seq0, seqN, cSeq0, c_queue);\n\n                // SECOND SORT\n                // First call will sort key, second sort will sort val\n                // Needs to be ascending (true) in order to maintain the indices properly\n                //kernel::sort0_by_key<Tv, T, true>(pKey, pVal);\n                compute::sort_by_key(seq0, seqN, key0, c_queue);\n                compute::sort_by_key(cSeq0, cSeqN, val0, c_queue);\n\n                // If descending, flip it back\n                if(!isAscending) compute::transform(key0, keyN, key0, flipFunction<Tk>(), c_queue);\n\n                //// No need of doing moddims here because the original Array<T>\n                //// dimensions have not been changed\n                ////val.modDims(inDims);\n\n                CL_DEBUG_FINISH(getQueue());\n                bufferFree(key);\n                bufferFree(cSeq);\n                bufferFree(cKey);\n            } catch (cl::Error err) {\n                CL_TO_AF_ERROR(err);\n                throw;\n            }\n        }\n\n        template<typename Tk, typename Tv>\n        void sort0ByKey(Param pKey, Param pVal, bool isAscending)\n        {\n            int higherDims =  pKey.info.dims[1] * pKey.info.dims[2] * pKey.info.dims[3];\n            // TODO Make a better heurisitic\n            if(higherDims > 5)\n                kernel::sortByKeyBatched<Tk, Tv>(pKey, pVal, 0, isAscending);\n            else\n                kernel::sort0ByKeyIterative<Tk, Tv>(pKey, pVal, isAscending);\n        }\n\n#define INSTANTIATE(Tk, Tv)                                                         \\\n  template void sort0ByKey<Tk, Tv>(Param okey, Param oval, bool isAscending);        \\\n  template void sort0ByKeyIterative<Tk, Tv>(Param okey, Param oval, bool isAscending); \\\n  template void sortByKeyBatched<Tk, Tv>(Param okey, Param oval, const int dim, bool isAscending);\n\n#define INSTANTIATE1(Tk    ) \\\n    INSTANTIATE(Tk, float  ) \\\n    INSTANTIATE(Tk, double ) \\\n    INSTANTIATE(Tk, cfloat ) \\\n    INSTANTIATE(Tk, cdouble) \\\n    INSTANTIATE(Tk, int    ) \\\n    INSTANTIATE(Tk, uint   ) \\\n    INSTANTIATE(Tk, short  ) \\\n    INSTANTIATE(Tk, ushort ) \\\n    INSTANTIATE(Tk, char   ) \\\n    INSTANTIATE(Tk, uchar  ) \\\n    INSTANTIATE(Tk, intl   ) \\\n    INSTANTIATE(Tk, uintl  )\n    }\n}\n\n#pragma GCC diagnostic pop\n"}, {"role": "assistant", "content": "Type: Unncessary locks."}]}
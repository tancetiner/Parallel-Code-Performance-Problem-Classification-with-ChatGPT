{"messages": [{"role": "system", "content": "You are a parallel computing expert. I will provide you a source code in C or C++ and I want you to classify if there is an inefficiency problem in the code. If there is an problem, I want you to classify this problem from the following list: ['Memory/Data locality', 'Micro-architectural inefficiency', 'Vector/SIMD parallelism', 'GPU parallelism', 'Instruction level parallelism', 'Task parallelism', 'small parallel region', 'Inefficeint thread mapping / inefficient block size / Load imbalance', 'Under-parallelization', 'Over-Parallelization', 'Unncessary locks', 'Unncessary strong memory consistency', 'Lock management overhead', 'Unnecessary synchronization', 'Unnecessary process communiction', 'Unnecessary operation/traversal/function call', 'Redundant operation', 'Expensive operation', 'Frequent  function call', 'Inefficient data-structure library', 'Usage of improper data type', 'memory leak', 'repreated memory allocation', 'Redundant memory allocation', 'Slower memory allocation library call', 'Insufficient memory', 'unnecessary data copy', 'sequential I/O operation', 'over parallelization', 'boundary condition check', 'Unintentional Programming logic error', 'Inefficiency due to new compiler version '] and return an answer with the following format and this format only, don't provide explanation: Type: classified_type."}, {"role": "user", "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n//#include <sys/mman.h>\n#include \"common.h\"\n\n#ifndef USE_OPENMP\n\n#include \"blas_server.c\"\n\n#else\n\n#ifndef OMP_SCHED\n#define OMP_SCHED static\n#endif\n\nint blas_server_avail = 0;\n\nstatic void * blas_thread_buffer[MAX_PARALLEL_NUMBER][MAX_CPU_NUMBER];\n#ifdef HAVE_C11\nstatic atomic_bool blas_buffer_inuse[MAX_PARALLEL_NUMBER];\n#else\nstatic _Bool blas_buffer_inuse[MAX_PARALLEL_NUMBER];\n#endif\n\nvoid goto_set_num_threads(int num_threads) {\n\n  int i=0, j=0;\n\n  if (num_threads < 1) num_threads = blas_num_threads;\n\n  if (num_threads > MAX_CPU_NUMBER) num_threads = MAX_CPU_NUMBER;\n\n  if (num_threads > blas_num_threads) {\n    blas_num_threads = num_threads;\n  }\n\n  blas_cpu_number  = num_threads;\n\n  omp_set_num_threads(blas_cpu_number);\n\n  //adjust buffer for each thread\n  for(i=0; i<MAX_PARALLEL_NUMBER; i++) {\n    for(j=0; j<blas_cpu_number; j++){\n      if(blas_thread_buffer[i][j]==NULL){\n        blas_thread_buffer[i][j]=blas_memory_alloc(2);\n      }\n    }\n    for(; j<MAX_CPU_NUMBER; j++){\n      if(blas_thread_buffer[i][j]!=NULL){\n        blas_memory_free(blas_thread_buffer[i][j]);\n        blas_thread_buffer[i][j]=NULL;\n      }\n    }\n  }\n#if defined(ARCH_MIPS64)\n  //set parameters for different number of threads.\n  blas_set_parameter();\n#endif\n\n}\nvoid openblas_set_num_threads(int num_threads) {\n\n\tgoto_set_num_threads(num_threads);\n}\n\nint blas_thread_init(void){\n\n  int i=0, j=0;\n\n  blas_get_cpu_number();\n\n  blas_server_avail = 1;\n\n  for(i=0; i<MAX_PARALLEL_NUMBER; i++) {\n    for(j=0; j<blas_num_threads; j++){\n      blas_thread_buffer[i][j]=blas_memory_alloc(2);\n    }\n    for(; j<MAX_CPU_NUMBER; j++){\n      blas_thread_buffer[i][j]=NULL;\n    }\n  }\n\n  return 0;\n}\n\nint BLASFUNC(blas_thread_shutdown)(void){\n  int i=0, j=0;\n  blas_server_avail = 0;\n\n  for(i=0; i<MAX_PARALLEL_NUMBER; i++) {\n    for(j=0; j<MAX_CPU_NUMBER; j++){\n      if(blas_thread_buffer[i][j]!=NULL){\n        blas_memory_free(blas_thread_buffer[i][j]);\n        blas_thread_buffer[i][j]=NULL;\n      }\n    }\n  }\n\n  return 0;\n}\n\nstatic void legacy_exec(void *func, int mode, blas_arg_t *args, void *sb){\n\n      if (!(mode & BLAS_COMPLEX)){\n#ifdef EXPRECISION\n\tif (mode & BLAS_XDOUBLE){\n\t  /* REAL / Extended Double */\n\t  void (*afunc)(BLASLONG, BLASLONG, BLASLONG, xdouble,\n\t\t\txdouble *, BLASLONG, xdouble *, BLASLONG,\n\t\t\txdouble *, BLASLONG, void *) = func;\n\n\t  afunc(args -> m, args -> n, args -> k,\n\t\t((xdouble *)args -> alpha)[0],\n\t\targs -> a, args -> lda,\n\t\targs -> b, args -> ldb,\n\t\targs -> c, args -> ldc, sb);\n\t} else\n#endif\n\t  if (mode & BLAS_DOUBLE){\n\t    /* REAL / Double */\n\t    void (*afunc)(BLASLONG, BLASLONG, BLASLONG, double,\n\t\t\t  double *, BLASLONG, double *, BLASLONG,\n\t\t\t  double *, BLASLONG, void *) = func;\n\n\t    afunc(args -> m, args -> n, args -> k,\n\t\t  ((double *)args -> alpha)[0],\n\t\t  args -> a, args -> lda,\n\t\t  args -> b, args -> ldb,\n\t\t  args -> c, args -> ldc, sb);\n\t  } else {\n\t    /* REAL / Single */\n\t    void (*afunc)(BLASLONG, BLASLONG, BLASLONG, float,\n\t\t\t  float *, BLASLONG, float *, BLASLONG,\n\t\t\t  float *, BLASLONG, void *) = func;\n\n\t    afunc(args -> m, args -> n, args -> k,\n\t\t  ((float *)args -> alpha)[0],\n\t\t  args -> a, args -> lda,\n\t\t  args -> b, args -> ldb,\n\t\t  args -> c, args -> ldc, sb);\n\t  }\n      } else {\n#ifdef EXPRECISION\n\tif (mode & BLAS_XDOUBLE){\n\t  /* COMPLEX / Extended Double */\n\t  void (*afunc)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t\t\txdouble *, BLASLONG, xdouble *, BLASLONG,\n\t\t\txdouble *, BLASLONG, void *) = func;\n\n\t  afunc(args -> m, args -> n, args -> k,\n\t\t((xdouble *)args -> alpha)[0],\n\t\t((xdouble *)args -> alpha)[1],\n\t\targs -> a, args -> lda,\n\t\targs -> b, args -> ldb,\n\t\targs -> c, args -> ldc, sb);\n\t} else\n#endif\n\t  if (mode & BLAS_DOUBLE){\n\t    /* COMPLEX / Double */\n\t  void (*afunc)(BLASLONG, BLASLONG, BLASLONG, double, double,\n\t\t\tdouble *, BLASLONG, double *, BLASLONG,\n\t\t\tdouble *, BLASLONG, void *) = func;\n\n\t  afunc(args -> m, args -> n, args -> k,\n\t\t((double *)args -> alpha)[0],\n\t\t((double *)args -> alpha)[1],\n\t\targs -> a, args -> lda,\n\t\targs -> b, args -> ldb,\n\t\targs -> c, args -> ldc, sb);\n\t  } else {\n\t    /* COMPLEX / Single */\n\t  void (*afunc)(BLASLONG, BLASLONG, BLASLONG, float, float,\n\t\t\tfloat *, BLASLONG, float *, BLASLONG,\n\t\t\tfloat *, BLASLONG, void *) = func;\n\n\t  afunc(args -> m, args -> n, args -> k,\n\t\t((float *)args -> alpha)[0],\n\t\t((float *)args -> alpha)[1],\n\t\targs -> a, args -> lda,\n\t\targs -> b, args -> ldb,\n\t\targs -> c, args -> ldc, sb);\n\t  }\n      }\n}\n\nstatic void exec_threads(blas_queue_t *queue, int buf_index){\n\n  void *buffer, *sa, *sb;\n  int pos=0, release_flag=0;\n\n  buffer = NULL;\n  sa = queue -> sa;\n  sb = queue -> sb;\n\n#ifdef CONSISTENT_FPCSR\n  __asm__ __volatile__ (\"ldmxcsr %0\" : : \"m\" (queue -> sse_mode));\n  __asm__ __volatile__ (\"fldcw %0\"   : : \"m\" (queue -> x87_mode));\n#endif\n\n  if ((sa == NULL) && (sb == NULL) && ((queue -> mode & BLAS_PTHREAD) == 0)) {\n\n    pos = omp_get_thread_num();\n    buffer = blas_thread_buffer[buf_index][pos];\n\n    //fallback\n    if(buffer==NULL) {\n      buffer = blas_memory_alloc(2);\n      release_flag=1;\n    }\n\n    if (sa == NULL) {\n      sa = (void *)((BLASLONG)buffer + GEMM_OFFSET_A);\n      queue->sa=sa;\n    }\n\n    if (sb == NULL) {\n      if (!(queue -> mode & BLAS_COMPLEX)){\n#ifdef EXPRECISION\n\tif (queue -> mode & BLAS_XDOUBLE){\n\t  sb = (void *)(((BLASLONG)sa + ((QGEMM_P * QGEMM_Q * sizeof(xdouble)\n\t\t\t\t\t  + GEMM_ALIGN) & ~GEMM_ALIGN)) + GEMM_OFFSET_B);\n\t} else\n#endif\n\t  if (queue -> mode & BLAS_DOUBLE){\n\t    sb = (void *)(((BLASLONG)sa + ((DGEMM_P * DGEMM_Q * sizeof(double)\n\t\t\t\t\t    + GEMM_ALIGN) & ~GEMM_ALIGN)) + GEMM_OFFSET_B);\n\n\t  } else {\n\t    sb = (void *)(((BLASLONG)sa + ((SGEMM_P * SGEMM_Q * sizeof(float)\n\t\t\t\t\t    + GEMM_ALIGN) & ~GEMM_ALIGN)) + GEMM_OFFSET_B);\n\t  }\n      } else {\n#ifdef EXPRECISION\n\tif (queue -> mode & BLAS_XDOUBLE){\n\t  sb = (void *)(((BLASLONG)sa + ((XGEMM_P * XGEMM_Q * 2 * sizeof(xdouble)\n\t\t\t\t\t  + GEMM_ALIGN) & ~GEMM_ALIGN)) + GEMM_OFFSET_B);\n\t} else\n#endif\n\t  if (queue -> mode & BLAS_DOUBLE){\n\t    sb = (void *)(((BLASLONG)sa + ((ZGEMM_P * ZGEMM_Q * 2 * sizeof(double)\n\t\t\t\t\t    + GEMM_ALIGN) & ~GEMM_ALIGN)) + GEMM_OFFSET_B);\n\t  } else {\n\t    sb = (void *)(((BLASLONG)sa + ((CGEMM_P * CGEMM_Q * 2 * sizeof(float)\n\t\t\t\t\t    + GEMM_ALIGN) & ~GEMM_ALIGN)) + GEMM_OFFSET_B);\n\t  }\n      }\n      queue->sb=sb;\n    }\n  }\n\n  if (queue -> mode & BLAS_LEGACY) {\n    legacy_exec(queue -> routine, queue -> mode, queue -> args, sb);\n  } else\n    if (queue -> mode & BLAS_PTHREAD) {\n      void (*pthreadcompat)(void *) = queue -> routine;\n      (pthreadcompat)(queue -> args);\n\n    } else {\n      int (*routine)(blas_arg_t *, void *, void *, void *, void *, BLASLONG) = queue -> routine;\n\n      (routine)(queue -> args, queue -> range_m, queue -> range_n, sa, sb, queue -> position);\n\n    }\n\n  if (release_flag) blas_memory_free(buffer);\n\n}\n\nint exec_blas(BLASLONG num, blas_queue_t *queue){\n\n  BLASLONG i, buf_index;\n\n  if ((num <= 0) || (queue == NULL)) return 0;\n\n#ifdef CONSISTENT_FPCSR\n  for (i = 0; i < num; i ++) {\n    __asm__ __volatile__ (\"fnstcw %0\"  : \"=m\" (queue[i].x87_mode));\n    __asm__ __volatile__ (\"stmxcsr %0\" : \"=m\" (queue[i].sse_mode));\n  }\n#endif\n\n  while(true) {\n    for(i=0; i < MAX_PARALLEL_NUMBER; i++) {\n#ifdef HAVE_C11\n      _Bool inuse = false;\n      if(atomic_compare_exchange_weak(&blas_buffer_inuse[i], &inuse, true)) {\n#else\n      if(blas_buffer_inuse[i] == false) {\n        blas_buffer_inuse[i] = true;\n#endif\n        buf_index = i;\n        break;\n      }\n    }\n    if(i != MAX_PARALLEL_NUMBER)\n      break;\n  }\n\n#pragma omp parallel for schedule(OMP_SCHED)\n  for (i = 0; i < num; i ++) {\n\n#ifndef USE_SIMPLE_THREADED_LEVEL3\n    queue[i].position = i;\n#endif\n\n    exec_threads(&queue[i], buf_index);\n  }\n\n#ifdef HAVE_C11\n  atomic_store(&blas_buffer_inuse[buf_index], false);\n#else\n  blas_buffer_inuse[buf_index] = false;\n#endif\n\n  return 0;\n}\n\n#endif\n"}, {"role": "assistant", "content": "Type: Task parallelism."}]}
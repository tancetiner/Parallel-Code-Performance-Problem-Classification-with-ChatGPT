{"messages": [{"role": "system", "content": "You are a parallel computing expert. I will provide you a source code in C or C++ and I want you to classify if there is an inefficiency problem in the code. If there is an problem, I want you to classify this problem from the following list: ['Memory/Data locality', 'Micro-architectural inefficiency', 'Vector/SIMD parallelism', 'GPU parallelism', 'Instruction level parallelism', 'Task parallelism', 'small parallel region', 'Inefficeint thread mapping / inefficient block size / Load imbalance', 'Under-parallelization', 'Over-Parallelization', 'Unncessary locks', 'Unncessary strong memory consistency', 'Lock management overhead', 'Unnecessary synchronization', 'Unnecessary process communiction', 'Unnecessary operation/traversal/function call', 'Redundant operation', 'Expensive operation', 'Frequent  function call', 'Inefficient data-structure library', 'Usage of improper data type', 'memory leak', 'repreated memory allocation', 'Redundant memory allocation', 'Slower memory allocation library call', 'Insufficient memory', 'unnecessary data copy', 'sequential I/O operation', 'over parallelization', 'boundary condition check', 'Unintentional Programming logic error', 'Inefficiency due to new compiler version '] and return an answer with the following format and this format only, don't provide explanation: Type: classified_type."}, {"role": "user", "content": "/*BHEADER**********************************************************************\n * (c) 1999   The Regents of the University of California\n *\n * See the file COPYRIGHT_and_DISCLAIMER for a complete copyright\n * notice, contact person, and disclaimer.\n *\n * $Revision$\n *********************************************************************EHEADER*/\n/******************************************************************************\n *\n * RowPatt - Pattern of a row, and functions to manipulate the pattern of\n * a row, particularly merging a pattern with a set of nonzero indices.\n *\n * Implementation and Notes: a full-length array is used to mark nonzeros\n * in the pattern.  Indices must not equal -1, which is the \"empty\" marker\n * used in the full length array.  It is expected that RowPatt will only be \n * presented with local indices, otherwise the full length array may be very \n * large.\n *\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <assert.h>\n#include \"Common.h\"\n#include \"RowPatt.h\"\n\n/*--------------------------------------------------------------------------\n * resize - local function for automatically increasing the size of RowPatt\n *--------------------------------------------------------------------------*/\n\nstatic void resize(RowPatt *p, int newlen)\n{\n    int oldlen, i;\n\n    oldlen = p->maxlen;\n    p->maxlen = newlen;\n\n    p->ind  = (int *) realloc(p->ind,  p->maxlen * sizeof(int));\n    p->mark = (int *) realloc(p->mark, p->maxlen * sizeof(int));\n\n    /* initialize the new portion of the mark array */\n    for (i=oldlen; i<p->maxlen; i++)\n\tp->mark[i] = -1;\n}\n\n/*--------------------------------------------------------------------------\n * RowPattCreate - Return (a pointer to) a pattern of a row with a maximum\n * of \"maxlen\" nonzeros.\n *--------------------------------------------------------------------------*/\n\nRowPatt *RowPattCreate(int maxlen)\n{\n    int i;\n    RowPatt *p = (RowPatt *) malloc(sizeof(RowPatt));\n\n    p->maxlen   = maxlen;\n    p->len      = 0;\n    p->prev_len = 0;\n    p->ind      = (int *) malloc(maxlen * sizeof(int));\n    p->mark     = (int *) malloc(maxlen * sizeof(int));\n    p->buffer   = NULL;\n    p->buflen   = 0;\n\n    for (i=0; i<maxlen; i++)\n        p->mark[i] = -1;\n\n    return p;\n}\n\n/*--------------------------------------------------------------------------\n * RowPattDestroy - Destroy a row pattern object \"p\".\n *--------------------------------------------------------------------------*/\n\nvoid RowPattDestroy(RowPatt *p)\n{\n    free(p->ind);\n    free(p->mark);\n    free(p);\n}\n\n/*--------------------------------------------------------------------------\n * RowPattReset - Empty the pattern of row pattern object \"p\".\n *--------------------------------------------------------------------------*/\n\nvoid RowPattReset(RowPatt *p)\n{\n    int i;\n\n    for (i=0; i<p->len; i++)\n        p->mark[p->ind[i]] = -1;\n\n    p->len      = 0;\n    p->prev_len = 0;\n}\n\n/*--------------------------------------------------------------------------\n * RowPattMerge - Merge the \"len\" nonzeros in array \"ind\" with pattern \"p\".\n *--------------------------------------------------------------------------*/\n\nvoid RowPattMerge(RowPatt *p, int len, int *ind)\n{\n    int i;\n\n    for (i=0; i<len; i++)\n    {\n\tif (ind[i] >= p->maxlen)\n\t    resize(p, ind[i]+1000);\n\n\tif (p->mark[ind[i]] == -1)\n\t{\n\t    assert(p->len < p->maxlen);\n\n\t    p->mark[ind[i]] = p->len;\n            p->ind[p->len] = ind[i];\n            p->len++;\n\t}\n    }\n}\n\n/*--------------------------------------------------------------------------\n * RowPattMergeExt - Merge the external nonzeros in the array \"ind\" of \n * length \"len\" with the pattern \"p\".  The external indices are those\n * that are less than \"beg\" or greater than \"end\".\n *--------------------------------------------------------------------------*/\n\nvoid RowPattMergeExt(RowPatt *p, int len, int *ind, int num_loc)\n{\n    int i;\n\n    for (i=0; i<len; i++)\n    {\n        if (ind[i] < num_loc)\n\t    continue;\n\n\tif (ind[i] >= p->maxlen)\n\t    resize(p, ind[i]+1000);\n\n\tif (p->mark[ind[i]] == -1)\n\t{\n\t    assert(p->len < p->maxlen);\n\n\t    p->mark[ind[i]] = p->len;\n            p->ind[p->len] = ind[i];\n            p->len++;\n\t}\n    }\n}\n\n/*--------------------------------------------------------------------------\n * RowPattGet - Return the pattern of \"p\".  The length and pointer to the\n * pattern indices are returned through the parameters \"lenp\" and \"indp\".\n * A copy of the indices is returned; this copy is destroyed on the next\n * call to RowPattGet or RowPattPrevLevel.\n *--------------------------------------------------------------------------*/\n\nvoid RowPattGet(RowPatt *p, int *lenp, int **indp)\n{\n    int len;\n\n    len = p->len;\n\n    if (len > p->buflen)\n    {\n\tfree(p->buffer);\n\tp->buflen = len + 100;\n\tp->buffer = (int *) malloc(p->buflen * sizeof(int));\n    }\n\n    memcpy(p->buffer, p->ind, len*sizeof(int));\n\n    *lenp = len;\n    *indp = p->buffer;\n}\n\n/*--------------------------------------------------------------------------\n * RowPattPrevLevel - Return the new indices added to the pattern of \"p\"\n * since the last call to RowPattPrevLevel (or all the indices if never\n * called).  The length and pointer to the pattern indices are returned \n * through the parameters \"lenp\" and \"indp\".\n * A copy of the indices is returned; this copy is destroyed on the next\n * call to RowPattGet or RowPattPrevLevel.\n *--------------------------------------------------------------------------*/\n\nvoid RowPattPrevLevel(RowPatt *p, int *lenp, int **indp)\n{\n    int len;\n\n    len = p->len - p->prev_len;\n\n    if (len > p->buflen)\n    {\n\tfree(p->buffer);\n\tp->buflen = len + 100;\n\tp->buffer = (int *) malloc(p->buflen * sizeof(int));\n    }\n\n    memcpy(p->buffer, &p->ind[p->prev_len], len*sizeof(int));\n\n    *lenp = len;\n    *indp = p->buffer;\n\n    p->prev_len = p->len;\n}\n"}, {"role": "assistant", "content": "Type: No inefficiency problem."}]}
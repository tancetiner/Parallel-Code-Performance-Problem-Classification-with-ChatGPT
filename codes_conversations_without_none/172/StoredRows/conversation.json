{"messages": [{"role": "system", "content": "You are a parallel computing expert. I will provide you a source code in C or C++ and I want you to classify if there is an inefficiency problem in the code. If there is an problem, I want you to classify this problem from the following list: ['Memory/Data locality', 'Micro-architectural inefficiency', 'Vector/SIMD parallelism', 'GPU parallelism', 'Instruction level parallelism', 'Task parallelism', 'small parallel region', 'Inefficeint thread mapping / inefficient block size / Load imbalance', 'Under-parallelization', 'Over-Parallelization', 'Unncessary locks', 'Unncessary strong memory consistency', 'Lock management overhead', 'Unnecessary synchronization', 'Unnecessary process communiction', 'Unnecessary operation/traversal/function call', 'Redundant operation', 'Expensive operation', 'Frequent  function call', 'Inefficient data-structure library', 'Usage of improper data type', 'memory leak', 'repreated memory allocation', 'Redundant memory allocation', 'Slower memory allocation library call', 'Insufficient memory', 'unnecessary data copy', 'sequential I/O operation', 'over parallelization', 'boundary condition check', 'Unintentional Programming logic error', 'Inefficiency due to new compiler version '] and return an answer with the following format and this format only, don't provide explanation: Type: classified_type."}, {"role": "user", "content": "/*BHEADER**********************************************************************\n * (c) 1999   The Regents of the University of California\n *\n * See the file COPYRIGHT_and_DISCLAIMER for a complete copyright\n * notice, contact person, and disclaimer.\n *\n * $Revision$\n *********************************************************************EHEADER*/\n/******************************************************************************\n *\n * StoredRows - Local storage of rows from other processors.  Although only\n * off-processor rows are stored, if an on-processor row is requested, it\n * is returned by referring to the local matrix.  Local indexing is used to\n * access the stored rows.\n *\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <assert.h>\n#include \"Common.h\"\n#include \"Mem.h\"\n#include \"Matrix.h\"\n#include \"StoredRows.h\"\n\n/*--------------------------------------------------------------------------\n * StoredRowsCreate - Return (a pointer to) a stored rows object.\n *\n * mat  - matrix used for returning on-processor rows (input)\n * size - the maximum number of (off-processor) rows that can be stored \n *        (input).  See below for more a precise description.\n *\n * A slot is available for \"size\" off-processor rows.  The slot for the\n * row with local index i is (i - num_loc).  Therefore, if max_i is the\n * largest local index expected, then size should be set to \n * (max_i - num_loc + 1).  StoredRows will automatically increase its \n * size if a row with a larger local index needs to be put in StoredRows.\n *--------------------------------------------------------------------------*/\n\nStoredRows *StoredRowsCreate(Matrix *mat, int size)\n{\n    StoredRows *p = (StoredRows *) malloc(sizeof(StoredRows));\n\n    p->mat  = mat;\n    p->mem  = MemCreate();\n\n    p->size = size;\n    p->num_loc = mat->end_row - mat->beg_row + 1;\n\n    p->len = (int *)     calloc(size,  sizeof(int));\n    p->ind = (int **)    malloc(size * sizeof(int *));\n    p->val = (double **) malloc(size * sizeof(double *));\n\n    p->count = 0;\n\n    return p;\n}\n\n/*--------------------------------------------------------------------------\n * StoredRowsDestroy - Destroy a stored rows object \"p\".\n *--------------------------------------------------------------------------*/\n\nvoid StoredRowsDestroy(StoredRows *p)\n{\n    MemDestroy(p->mem);\n    free(p->len);\n    free(p->ind);\n    free(p->val);\n    free(p);\n}\n\n/*--------------------------------------------------------------------------\n * StoredRowsAllocInd - Return space allocated for \"len\" indices in the\n * stored rows object \"p\".  The indices may span several rows.\n *--------------------------------------------------------------------------*/\n\nint *StoredRowsAllocInd(StoredRows *p, int len)\n{\n    return (int *) MemAlloc(p->mem, len*sizeof(int));\n}\n\n/*--------------------------------------------------------------------------\n * StoredRowsAllocVal - Return space allocated for \"len\" values in the\n * stored rows object \"p\".  The values may span several rows.\n *--------------------------------------------------------------------------*/\n\ndouble *StoredRowsAllocVal(StoredRows *p, int len)\n{\n    return (double *) MemAlloc(p->mem, len*sizeof(double));\n}\n\n/*--------------------------------------------------------------------------\n * StoredRowsPut - Given a row (len, ind, val), store it as row \"index\" in\n * the stored rows object \"p\".  Only nonlocal stored rows should be put using\n * this interface; the local stored rows are put using the create function.\n *--------------------------------------------------------------------------*/\n\nvoid StoredRowsPut(StoredRows *p, int index, int len, int *ind, double *val)\n{\n    int i = index - p->num_loc;\n\n    /* Reallocate if necessary */\n    if (i >= p->size)\n    {\n        int j;\n        int newsize;\n\n\tnewsize = i+1000;\n        p->len = (int *)     realloc(p->len, newsize * sizeof(int));\n        p->ind = (int **)    realloc(p->ind, newsize * sizeof(int *));\n        p->val = (double **) realloc(p->val, newsize * sizeof(double *));\n\n\t/* set lengths to zero */\n        for (j=p->size; j<newsize; j++)\n\t    p->len[j] = 0;\n\n        p->size = newsize;\n    }\n\n    /* check that row has not been put already */\n    assert(p->len[i] == 0);\n\n    p->len[i] = len;\n    p->ind[i] = ind;\n    p->val[i] = val;\n\n    p->count++;\n}\n\n/*--------------------------------------------------------------------------\n * StoredRowsGet - Return the row with index \"index\" through the pointers \n * \"lenp\", \"indp\" and \"valp\" in the stored rows object \"p\".\n *--------------------------------------------------------------------------*/\n\nvoid StoredRowsGet(StoredRows *p, int index, int *lenp, int **indp, \n  double **valp)\n{\n    if (index < p->num_loc)\n    {\n        MatrixGetRow(p->mat, index, lenp, indp, valp);\n    }\n    else\n    {\n\tindex = index - p->num_loc;\n\n        *lenp = p->len[index];\n        *indp = p->ind[index];\n        *valp = p->val[index];\n    }\n}\n"}, {"role": "assistant", "content": "Type: No inefficiency."}]}
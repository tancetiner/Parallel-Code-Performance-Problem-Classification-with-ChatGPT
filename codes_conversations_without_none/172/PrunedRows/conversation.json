{"messages": [{"role": "system", "content": "You are a parallel computing expert. I will provide you a source code in C or C++ and I want you to classify if there is an inefficiency problem in the code. If there is an problem, I want you to classify this problem from the following list: ['Memory/Data locality', 'Micro-architectural inefficiency', 'Vector/SIMD parallelism', 'GPU parallelism', 'Instruction level parallelism', 'Task parallelism', 'small parallel region', 'Inefficeint thread mapping / inefficient block size / Load imbalance', 'Under-parallelization', 'Over-Parallelization', 'Unncessary locks', 'Unncessary strong memory consistency', 'Lock management overhead', 'Unnecessary synchronization', 'Unnecessary process communiction', 'Unnecessary operation/traversal/function call', 'Redundant operation', 'Expensive operation', 'Frequent  function call', 'Inefficient data-structure library', 'Usage of improper data type', 'memory leak', 'repreated memory allocation', 'Redundant memory allocation', 'Slower memory allocation library call', 'Insufficient memory', 'unnecessary data copy', 'sequential I/O operation', 'over parallelization', 'boundary condition check', 'Unintentional Programming logic error', 'Inefficiency due to new compiler version '] and return an answer with the following format and this format only, don't provide explanation: Type: classified_type."}, {"role": "user", "content": "/*BHEADER**********************************************************************\n * (c) 1999   The Regents of the University of California\n *\n * See the file COPYRIGHT_and_DISCLAIMER for a complete copyright\n * notice, contact person, and disclaimer.\n *\n * $Revision$\n *********************************************************************EHEADER*/\n/******************************************************************************\n *\n * PrunedRows - Collection of pruned rows that are cached on the local \n * processor.  Direct access to these rows is available, via the local\n * index number.\n *\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <assert.h>\n#include \"Common.h\"\n#include \"Mem.h\"\n#include \"Matrix.h\"\n#include \"DiagScale.h\"\n#include \"PrunedRows.h\"\n\n/*--------------------------------------------------------------------------\n * PrunedRowsCreate - Return (a pointer to) a pruned rows object.\n *\n * mat        - matrix used to construct the local pruned rows (input)\n *              assumes the matrix uses local indexing\n * size       - number of unique local indices on this processor;\n *              an array of this size will be allocated to access the\n *              pruned rows (input) - includes the number of local nodes\n * diag_scale - diagonal scale object used to scale the thresholding (input)\n * thresh     - threshold for pruning the matrix (input)\n *\n * The local pruned rows are stored in the first part of the len and ind \n * arrays.\n *--------------------------------------------------------------------------*/\n\nPrunedRows *PrunedRowsCreate(Matrix *mat, int size, DiagScale *diag_scale, \n  double thresh)\n{\n    int row, len, *ind, count, j, *data;\n    double *val, temp;\n\n    PrunedRows *p = (PrunedRows *) malloc(sizeof(PrunedRows));\n\n    p->mem  = MemCreate();\n    p->size = MAX(size, mat->end_row - mat->beg_row + 1);\n\n    p->len = (int *)  malloc(p->size * sizeof(int));\n    p->ind = (int **) malloc(p->size * sizeof(int *));\n\n    /* Prune and store the rows on the local processor */\n\n    for (row=0; row<=mat->end_row - mat->beg_row; row++)\n    {\n        MatrixGetRow(mat, row, &len, &ind, &val);\n\n        count = 1; /* automatically include the diagonal */\n        for (j=0; j<len; j++)\n        {\n            temp = DiagScaleGet(diag_scale, row);\n            if (temp*ABS(val[j])*DiagScaleGet(diag_scale, ind[j]) \n              >= thresh && ind[j] != row)\n                count++;\n        }\n\n        p->ind[row] = (int *) MemAlloc(p->mem, count*sizeof(int));\n        p->len[row] = count;\n\n        data = p->ind[row];\n        *data++ = row; /* the diagonal entry */\n        for (j=0; j<len; j++)\n        {\n            temp = DiagScaleGet(diag_scale, row);\n            if (temp*ABS(val[j])*DiagScaleGet(diag_scale, ind[j]) \n              >= thresh && ind[j] != row)\n                *data++ = ind[j];\n        }\n    }\n\n    return p;\n}\n\n/*--------------------------------------------------------------------------\n * PrunedRowsDestroy - Destroy a pruned rows object \"p\".\n *--------------------------------------------------------------------------*/\n\nvoid PrunedRowsDestroy(PrunedRows *p)\n{\n    MemDestroy(p->mem);\n    free(p->len);\n    free(p->ind);\n    free(p);\n}\n\n/*--------------------------------------------------------------------------\n * PrunedRowsAllocInd - Return space allocated for \"len\" indices in the\n * pruned rows object \"p\".  The indices may span several rows.\n *--------------------------------------------------------------------------*/\n\nint *PrunedRowsAlloc(PrunedRows *p, int len)\n{\n    return (int *) MemAlloc(p->mem, len*sizeof(int));\n}\n\n/*--------------------------------------------------------------------------\n * PrunedRowsPut - Given a pruned row (len, ind), store it as row \"index\" in\n * the pruned rows object \"p\".  Only nonlocal pruned rows should be put using\n * this interface; the local pruned rows are put using the create function.\n *--------------------------------------------------------------------------*/\n\nvoid PrunedRowsPut(PrunedRows *p, int index, int len, int *ind)\n{\n    if (index >= p->size)\n    {\n\tp->size = index + 1000;\n\tp->len = (int *)  realloc(p->len, p->size * sizeof(int));\n\tp->ind = (int **) realloc(p->ind, p->size * sizeof(int *));\n    }\n\n    p->len[index] = len;\n    p->ind[index] = ind;\n}\n\n/*--------------------------------------------------------------------------\n * PrunedRowsGet - Return the row with index \"index\" through the pointers \n * \"lenp\" and \"indp\" in the pruned rows object \"p\".\n *--------------------------------------------------------------------------*/\n\nvoid PrunedRowsGet(PrunedRows *p, int index, int *lenp, int **indp)\n{\n    *lenp = p->len[index];\n    *indp = p->ind[index];\n}\n"}, {"role": "assistant", "content": "Type: Unnecessary memory allocation."}]}
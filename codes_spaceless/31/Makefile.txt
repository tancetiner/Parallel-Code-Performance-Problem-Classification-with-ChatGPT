include ../make.inc QUDA = libquda.a QUDA_OBJS = blas_quda.o clover_quda.o color_spinor_field.o \ cpu_color_spinor_field.o cuda_color_spinor_field.o dirac.o \ dirac_clover.o dirac_wilson.o dirac_staggered.o dirac_domain_wall.o \ dirac_twisted_mass.o dslash_quda.o gauge_quda.o inv_bicgstab_quda.o \ inv_cg_quda.o inv_multi_cg_quda.o interface_quda.o util_quda.o hw_quda.o # header files, found in include/ QUDA_HDRS = blas_quda.h clover_quda.h color_spinor_field.h dirac_quda.h \ dslash_quda.h enum_quda.h gauge_force_quda.h gauge_quda.h \ invert_quda.h llfat_quda.h quda.h quda_internal.h util_quda.h # files containing complex macros and other code fragments to be inlined, # found in lib/ QUDA_INLN = check_params.h clover_def.h dslash_constants.h dslash_textures.h \ force_common.h io_spinor.h llfat_core.h pack_spinor.h read_clover.h \ read_gauge.h reduce_complex_core.h reduce_core.h \ reduce_triple_core.h staggered_dslash_def.h wilson_dslash_def.h \ dw_dslash_def.h tm_dslash_def.h # files generated by the scripts in lib/generate/, found in lib/dslash_core/ # (The current clover_core.h and staggered_dslash_core.h were edited by hand.) QUDA_CORE = clover_core.h staggered_dslash_core.h wilson_dslash_core.h \ wilson_dslash_dagger_core.h staggered_dslash_core.h \ dw_dslash_dagger_core.h dw_dslash_core.h \ tm_dslash_dagger_core.h tm_dslash_core.h INC += -I../include -Idslash_core -I. HDRS = $(QUDA_HDRS:%=../include/%) HDRS += $(QUDA_INLN) CORE = $(QUDA_CORE:%=dslash_core/%) # limit maximum number of registers in BLAS routines to increase occupancy ifeq ($(strip $(GPU_ARCH)), sm_20) MAXREG = else MAXREG = --maxrregcount=80 endif all: $(QUDA) $(QUDA): $(QUDA_OBJS) ar cru $@ $(QUDA_OBJS) gen: $(PYTHON) generate/dslash_cuda_gen.py clean: -rm -f *.o $(QUDA) %.o: %.cpp $(HDRS) $(CXX) $(CXXFLAGS) $< -c -o $@ blas_quda.o: blas_quda.cu blas_param.h $(HDRS) $(NVCC) $(NVCCFLAGS) $(MAXREG) $< -c -o $@ %.o: %.cu $(HDRS) $(CORE) $(NVCC) $(NVCCFLAGS) $< -c -o $@ .PHONY: all gen clean
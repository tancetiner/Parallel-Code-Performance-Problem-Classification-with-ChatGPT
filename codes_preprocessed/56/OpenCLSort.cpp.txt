#ifdef _MSC_VER #define NOMINMAX #endif #include "OpenCLSort.h" #include "OpenCLKernelSources.h" #include <algorithm> #include <map> using namespace OpenMM; using namespace std; OpenCLSort::OpenCLSort(OpenCLContext& context, SortTrait* trait, unsigned int length) : context(context), trait(trait), dataLength(length) { std::map<std::string, std::string> replacements; replacements["DATA_TYPE"] = trait->getDataType(); replacements["KEY_TYPE"] = trait->getKeyType(); replacements["SORT_KEY"] = trait->getSortKey(); replacements["MIN_KEY"] = trait->getMinKey(); replacements["MAX_KEY"] = trait->getMaxKey(); replacements["MAX_VALUE"] = trait->getMaxValue(); cl::Program program = context.createProgram(context.replaceStrings(OpenCLKernelSources::sort, replacements)); shortListKernel = cl::Kernel(program, "sortShortList"); shortList2Kernel = cl::Kernel(program, "sortShortList2"); computeRangeKernel = cl::Kernel(program, "computeRange"); assignElementsKernel = cl::Kernel(program, "assignElementsToBuckets"); computeBucketPositionsKernel = cl::Kernel(program, "computeBucketPositions"); copyToBucketsKernel = cl::Kernel(program, "copyDataToBuckets"); sortBucketsKernel = cl::Kernel(program, "sortBuckets"); unsigned int maxGroupSize = std::min(256, (int) context.getDevice().getInfo<CL_DEVICE_MAX_WORK_GROUP_SIZE>()); int maxSharedMem = context.getDevice().getInfo<CL_DEVICE_LOCAL_MEM_SIZE>(); unsigned int maxRangeSize = std::min(maxGroupSize, (unsigned int) computeRangeKernel.getWorkGroupInfo<CL_KERNEL_WORK_GROUP_SIZE>(context.getDevice())); unsigned int maxPositionsSize = std::min(maxGroupSize, (unsigned int) computeBucketPositionsKernel.getWorkGroupInfo<CL_KERNEL_WORK_GROUP_SIZE>(context.getDevice())); int maxLocalBuffer = (maxSharedMem/trait->getDataSize())/2; unsigned int maxShortList = min(8192, max(maxLocalBuffer, (int) OpenCLContext::ThreadBlockSize*context.getNumThreadBlocks())); isShortList = (length <= maxShortList); for (rangeKernelSize = 1; rangeKernelSize*2 <= maxRangeSize; rangeKernelSize *= 2) ; positionsKernelSize = std::min(rangeKernelSize, maxPositionsSize); sortKernelSize = (isShortList ? rangeKernelSize : rangeKernelSize/2); if (rangeKernelSize > length) rangeKernelSize = length; if (sortKernelSize > maxLocalBuffer) sortKernelSize = maxLocalBuffer; unsigned int targetBucketSize = sortKernelSize/2; unsigned int numBuckets = length/targetBucketSize; if (numBuckets < 1) numBuckets = 1; if (positionsKernelSize > numBuckets) positionsKernelSize = numBuckets; if (!isShortList) { dataRange.initialize(context, 2, trait->getKeySize(), "sortDataRange"); bucketOffset.initialize<cl_uint>(context, numBuckets, "bucketOffset"); bucketOfElement.initialize<cl_uint>(context, length, "bucketOfElement"); offsetInBucket.initialize<cl_uint>(context, length, "offsetInBucket"); } buckets.initialize(context, length, trait->getDataSize(), "buckets"); } OpenCLSort::~OpenCLSort() { delete trait; } void OpenCLSort::sort(OpenCLArray& data) { if (data.getSize() != dataLength || data.getElementSize() != trait->getDataSize()) throw OpenMMException("OpenCLSort called with different data size"); if (data.getSize() == 0) return; if (isShortList) { if (dataLength <= OpenCLContext::ThreadBlockSize*context.getNumThreadBlocks()) { shortList2Kernel.setArg<cl::Buffer>(0, data.getDeviceBuffer()); shortList2Kernel.setArg<cl::Buffer>(1, buckets.getDeviceBuffer()); shortList2Kernel.setArg<cl_int>(2, dataLength); context.executeKernel(shortList2Kernel, dataLength); buckets.copyTo(data); } else { shortListKernel.setArg<cl::Buffer>(0, data.getDeviceBuffer()); shortListKernel.setArg<cl_uint>(1, dataLength); shortListKernel.setArg(2, dataLength*trait->getDataSize(), NULL); context.executeKernel(shortListKernel, sortKernelSize, sortKernelSize); } } else { unsigned int numBuckets = bucketOffset.getSize(); computeRangeKernel.setArg<cl::Buffer>(0, data.getDeviceBuffer()); computeRangeKernel.setArg<cl_uint>(1, data.getSize()); computeRangeKernel.setArg<cl::Buffer>(2, dataRange.getDeviceBuffer()); computeRangeKernel.setArg(3, rangeKernelSize*trait->getKeySize(), NULL); computeRangeKernel.setArg(4, rangeKernelSize*trait->getKeySize(), NULL); computeRangeKernel.setArg<cl_int>(5, numBuckets); computeRangeKernel.setArg<cl::Buffer>(6, bucketOffset.getDeviceBuffer()); context.executeKernel(computeRangeKernel, rangeKernelSize, rangeKernelSize); assignElementsKernel.setArg<cl::Buffer>(0, data.getDeviceBuffer()); assignElementsKernel.setArg<cl_int>(1, data.getSize()); assignElementsKernel.setArg<cl_int>(2, numBuckets); assignElementsKernel.setArg<cl::Buffer>(3, dataRange.getDeviceBuffer()); assignElementsKernel.setArg<cl::Buffer>(4, bucketOffset.getDeviceBuffer()); assignElementsKernel.setArg<cl::Buffer>(5, bucketOfElement.getDeviceBuffer()); assignElementsKernel.setArg<cl::Buffer>(6, offsetInBucket.getDeviceBuffer()); context.executeKernel(assignElementsKernel, data.getSize()); computeBucketPositionsKernel.setArg<cl_int>(0, numBuckets); computeBucketPositionsKernel.setArg<cl::Buffer>(1, bucketOffset.getDeviceBuffer()); computeBucketPositionsKernel.setArg(2, positionsKernelSize*sizeof(cl_int), NULL); context.executeKernel(computeBucketPositionsKernel, positionsKernelSize, positionsKernelSize); copyToBucketsKernel.setArg<cl::Buffer>(0, data.getDeviceBuffer()); copyToBucketsKernel.setArg<cl::Buffer>(1, buckets.getDeviceBuffer()); copyToBucketsKernel.setArg<cl_int>(2, data.getSize()); copyToBucketsKernel.setArg<cl::Buffer>(3, bucketOffset.getDeviceBuffer()); copyToBucketsKernel.setArg<cl::Buffer>(4, bucketOfElement.getDeviceBuffer()); copyToBucketsKernel.setArg<cl::Buffer>(5, offsetInBucket.getDeviceBuffer()); context.executeKernel(copyToBucketsKernel, data.getSize()); sortBucketsKernel.setArg<cl::Buffer>(0, data.getDeviceBuffer()); sortBucketsKernel.setArg<cl::Buffer>(1, buckets.getDeviceBuffer()); sortBucketsKernel.setArg<cl_int>(2, numBuckets); sortBucketsKernel.setArg<cl::Buffer>(3, bucketOffset.getDeviceBuffer()); sortBucketsKernel.setArg(4, sortKernelSize*trait->getDataSize(), NULL); context.executeKernel(sortBucketsKernel, ((data.getSize()+sortKernelSize-1)/sortKernelSize)*sortKernelSize, sortKernelSize); } }
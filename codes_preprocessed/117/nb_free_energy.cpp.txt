#include "gmxpre.h" #include "nb_free_energy.h" #include <cmath> #include <algorithm> #include "gromacs/gmxlib/nrnb.h" #include "gromacs/gmxlib/nonbonded/nb_kernel.h" #include "gromacs/gmxlib/nonbonded/nonbonded.h" #include "gromacs/math/functions.h" #include "gromacs/math/vec.h" #include "gromacs/mdtypes/forcerec.h" #include "gromacs/mdtypes/md_enums.h" #include "gromacs/utility/fatalerror.h" enum class SoftCoreTreatment { None, RPower6, RPower48 }; template <SoftCoreTreatment softCoreTreatment> struct SoftCoreReal { using Real = real; }; template <> struct SoftCoreReal<SoftCoreTreatment::RPower48> { using Real = double; }; template<SoftCoreTreatment softCoreTreatment> static void nb_free_energy_kernel(const t_nblist * gmx_restrict nlist, rvec * gmx_restrict xx, rvec * gmx_restrict ff, t_forcerec * gmx_restrict fr, const t_mdatoms * gmx_restrict mdatoms, nb_kernel_data_t * gmx_restrict kernel_data, t_nrnb * gmx_restrict nrnb) { using SCReal = typename SoftCoreReal<softCoreTreatment>::Real; constexpr bool useSoftCore = (softCoreTreatment != SoftCoreTreatment::None); #define STATE_A 0 #define STATE_B 1 #define NSTATES 2 int i, n, ii, is3, ii3, k, nj0, nj1, jnr, j3, ggid; real shX, shY, shZ; real tx, ty, tz, Fscal; SCReal FscalC[NSTATES], FscalV[NSTATES]; SCReal Vcoul[NSTATES], Vvdw[NSTATES]; real rinv6, r; real iqA, iqB; real qq[NSTATES], vctot; int ntiA, ntiB, tj[NSTATES]; real Vvdw6, Vvdw12, vvtot; real ix, iy, iz, fix, fiy, fiz; real dx, dy, dz, rsq, rinv; real c6[NSTATES], c12[NSTATES], c6grid; real LFC[NSTATES], LFV[NSTATES], DLF[NSTATES]; SCReal dvdl_coul, dvdl_vdw; real lfac_coul[NSTATES], dlfac_coul[NSTATES], lfac_vdw[NSTATES], dlfac_vdw[NSTATES]; real sigma6[NSTATES], alpha_vdw_eff, alpha_coul_eff; SCReal rp, rpm2, rC, rV, rinvC, rpinvC, rinvV, rpinvV; real sigma_pow[NSTATES]; real VV, FF; int icoul, ivdw; int nri; const int * iinr; const int * jindex; const int * jjnr; const int * shift; const int * gid; const int * typeA; const int * typeB; int ntype; const real * shiftvec; real * fshift; const real * x; real * f; real facel, krf, crf; const real * chargeA; const real * chargeB; real sigma6_min, sigma6_def, lam_power; real alpha_coul, alpha_vdw, lambda_coul, lambda_vdw; real sh_lj_ewald; const real * nbfp, *nbfp_grid; real * dvdl; real * Vv; real * Vc; gmx_bool bDoForces, bDoShiftForces, bDoPotential; real rcoulomb, rvdw, sh_invrc6; gmx_bool bEwald, bEwaldLJ; real rcutoff_max2; const real * tab_ewald_F_lj = nullptr; const real * tab_ewald_V_lj = nullptr; real d, d2, sw, dsw; real vdw_swV3, vdw_swV4, vdw_swV5, vdw_swF2, vdw_swF3, vdw_swF4; gmx_bool bComputeVdwInteraction, bComputeElecInteraction; const real * ewtab = nullptr; int ewitab; real ewrt, eweps, ewtabscale = 0, ewtabhalfspace = 0, sh_ewald = 0; const real onetwelfth = 1.0/12.0; const real onesixth = 1.0/6.0; const real zero = 0.0; const real half = 0.5; const real one = 1.0; const real two = 2.0; const real six = 6.0; const interaction_const_t *ic = fr->ic; x = xx[0]; f = ff[0]; fshift = fr->fshift[0]; nri = nlist->nri; iinr = nlist->iinr; jindex = nlist->jindex; jjnr = nlist->jjnr; shift = nlist->shift; gid = nlist->gid; shiftvec = fr->shift_vec[0]; chargeA = mdatoms->chargeA; chargeB = mdatoms->chargeB; facel = fr->ic->epsfac; krf = ic->k_rf; crf = ic->c_rf; Vc = kernel_data->energygrp_elec; typeA = mdatoms->typeA; typeB = mdatoms->typeB; ntype = fr->ntype; nbfp = fr->nbfp; nbfp_grid = fr->ljpme_c6grid; Vv = kernel_data->energygrp_vdw; lambda_coul = kernel_data->lambda[efptCOUL]; lambda_vdw = kernel_data->lambda[efptVDW]; dvdl = kernel_data->dvdl; alpha_coul = fr->sc_alphacoul; alpha_vdw = fr->sc_alphavdw; lam_power = fr->sc_power; sigma6_def = fr->sc_sigma6_def; sigma6_min = fr->sc_sigma6_min; bDoForces = ((kernel_data->flags & GMX_NONBONDED_DO_FORCE) != 0); bDoShiftForces = ((kernel_data->flags & GMX_NONBONDED_DO_SHIFTFORCE) != 0); bDoPotential = ((kernel_data->flags & GMX_NONBONDED_DO_POTENTIAL) != 0); rcoulomb = ic->rcoulomb; rvdw = ic->rvdw; sh_invrc6 = ic->sh_invrc6; sh_lj_ewald = ic->sh_lj_ewald; GMX_ASSERT(ic->coulomb_modifier != eintmodPOTSWITCH, "Potential switching is not supported for Coulomb with FEP"); if (ic->vdw_modifier == eintmodPOTSWITCH) { d = ic->rvdw - ic->rvdw_switch; vdw_swV3 = -10.0/(d*d*d); vdw_swV4 = 15.0/(d*d*d*d); vdw_swV5 = -6.0/(d*d*d*d*d); vdw_swF2 = -30.0/(d*d*d); vdw_swF3 = 60.0/(d*d*d*d); vdw_swF4 = -30.0/(d*d*d*d*d); } else { vdw_swV3 = vdw_swV4 = vdw_swV5 = vdw_swF2 = vdw_swF3 = vdw_swF4 = 0.0; } if (EVDW_PME(ic->vdwtype)) { ivdw = GMX_NBKERNEL_VDW_LJEWALD; } else { ivdw = GMX_NBKERNEL_VDW_LENNARDJONES; } if (ic->eeltype == eelCUT || EEL_RF(ic->eeltype)) { icoul = GMX_NBKERNEL_ELEC_REACTIONFIELD; } else if (EEL_PME_EWALD(ic->eeltype)) { icoul = GMX_NBKERNEL_ELEC_EWALD; } else { gmx_incons("Unsupported eeltype with Verlet and free-energy"); } rcutoff_max2 = std::max(ic->rcoulomb, ic->rvdw); rcutoff_max2 = rcutoff_max2*rcutoff_max2; bEwald = (icoul == GMX_NBKERNEL_ELEC_EWALD); bEwaldLJ = (ivdw == GMX_NBKERNEL_VDW_LJEWALD); if (bEwald || bEwaldLJ) { sh_ewald = ic->sh_ewald; ewtab = ic->tabq_coul_FDV0; ewtabscale = ic->tabq_scale; ewtabhalfspace = half/ewtabscale; tab_ewald_F_lj = ic->tabq_vdw_F; tab_ewald_V_lj = ic->tabq_vdw_V; } GMX_RELEASE_ASSERT(!(bEwald && ic->coulomb_modifier == eintmodPOTSWITCH) && !(bEwaldLJ && ic->vdw_modifier == eintmodPOTSWITCH), "Can not apply soft-core to switched Ewald potentials"); dvdl_coul = 0; dvdl_vdw = 0; LFC[STATE_A] = one - lambda_coul; LFV[STATE_A] = one - lambda_vdw; LFC[STATE_B] = lambda_coul; LFV[STATE_B] = lambda_vdw; DLF[STATE_A] = -1; DLF[STATE_B] = 1; constexpr real sc_r_power = (softCoreTreatment == SoftCoreTreatment::RPower48 ? 48.0_real : 6.0_real); for (i = 0; i < NSTATES; i++) { lfac_coul[i] = (lam_power == 2 ? (1-LFC[i])*(1-LFC[i]) : (1-LFC[i])); dlfac_coul[i] = DLF[i]*lam_power/sc_r_power*(lam_power == 2 ? (1-LFC[i]) : 1); lfac_vdw[i] = (lam_power == 2 ? (1-LFV[i])*(1-LFV[i]) : (1-LFV[i])); dlfac_vdw[i] = DLF[i]*lam_power/sc_r_power*(lam_power == 2 ? (1-LFV[i]) : 1); } for (n = 0; (n < nri); n++) { int npair_within_cutoff; npair_within_cutoff = 0; is3 = 3*shift[n]; shX = shiftvec[is3]; shY = shiftvec[is3+1]; shZ = shiftvec[is3+2]; nj0 = jindex[n]; nj1 = jindex[n+1]; ii = iinr[n]; ii3 = 3*ii; ix = shX + x[ii3+0]; iy = shY + x[ii3+1]; iz = shZ + x[ii3+2]; iqA = facel*chargeA[ii]; iqB = facel*chargeB[ii]; ntiA = 2*ntype*typeA[ii]; ntiB = 2*ntype*typeB[ii]; vctot = 0; vvtot = 0; fix = 0; fiy = 0; fiz = 0; for (k = nj0; (k < nj1); k++) { jnr = jjnr[k]; j3 = 3*jnr; dx = ix - x[j3]; dy = iy - x[j3+1]; dz = iz - x[j3+2]; rsq = dx*dx + dy*dy + dz*dz; if (rsq >= rcutoff_max2) { continue; } npair_within_cutoff++; if (rsq > 0) { rinv = gmx::invsqrt(rsq); r = rsq*rinv; } else { rinv = 0; r = 0; } if (softCoreTreatment == SoftCoreTreatment::None) { rpm2 = rinv*rinv; rp = 1; } if (softCoreTreatment == SoftCoreTreatment::RPower6) { rpm2 = rsq*rsq; rp = rpm2*rsq; } if (softCoreTreatment == SoftCoreTreatment::RPower48) { rp = rsq*rsq*rsq; rp = rp*rp; rp = rp*rp; rp = rp*rp; rpm2 = rp/rsq; } Fscal = 0; qq[STATE_A] = iqA*chargeA[jnr]; qq[STATE_B] = iqB*chargeB[jnr]; tj[STATE_A] = ntiA+2*typeA[jnr]; tj[STATE_B] = ntiB+2*typeB[jnr]; if (nlist->excl_fep == nullptr || nlist->excl_fep[k]) { c6[STATE_A] = nbfp[tj[STATE_A]]; c6[STATE_B] = nbfp[tj[STATE_B]]; for (i = 0; i < NSTATES; i++) { c12[i] = nbfp[tj[i]+1]; if (useSoftCore) { if ((c6[i] > 0) && (c12[i] > 0)) { sigma6[i] = half*c12[i]/c6[i]; if (sigma6[i] < sigma6_min) { sigma6[i] = sigma6_min; } } else { sigma6[i] = sigma6_def; } if (softCoreTreatment == SoftCoreTreatment::RPower6) { sigma_pow[i] = sigma6[i]; } else { sigma_pow[i] = sigma6[i]*sigma6[i]; sigma_pow[i] = sigma_pow[i]*sigma_pow[i]; sigma_pow[i] = sigma_pow[i]*sigma_pow[i]; } } } if (useSoftCore) { if ((c12[STATE_A] > 0) && (c12[STATE_B] > 0)) { alpha_vdw_eff = 0; alpha_coul_eff = 0; } else { alpha_vdw_eff = alpha_vdw; alpha_coul_eff = alpha_coul; } } for (i = 0; i < NSTATES; i++) { FscalC[i] = 0; FscalV[i] = 0; Vcoul[i] = 0; Vvdw[i] = 0; if ( (qq[i] != 0) || (c6[i] != 0) || (c12[i] != 0) ) { if (useSoftCore) { rpinvC = one/(alpha_coul_eff*lfac_coul[i]*sigma_pow[i]+rp); rinvC = std::pow(rpinvC, one/sc_r_power); rC = one/rinvC; rpinvV = one/(alpha_vdw_eff*lfac_vdw[i]*sigma_pow[i]+rp); rinvV = std::pow(rpinvV, one/sc_r_power); rV = one/rinvV; } else { rpinvC = 1; rinvC = rinv; rC = r; rpinvV = 1; rinvV = rinv; rV = r; } bComputeElecInteraction = ( bEwald && r < rcoulomb) || (!bEwald && rC < rcoulomb); if ( (qq[i] != 0) && bComputeElecInteraction) { if (bEwald) { Vcoul[i] = qq[i]*(rinvC-sh_ewald); FscalC[i] = qq[i]*rinvC; } else { Vcoul[i] = qq[i]*(rinvC + krf*rC*rC-crf); FscalC[i] = qq[i]*(rinvC - two*krf*rC*rC); } } bComputeVdwInteraction = ( bEwaldLJ && r < rvdw) || (!bEwaldLJ && rV < rvdw); if ((c6[i] != 0 || c12[i] != 0) && bComputeVdwInteraction) { if (softCoreTreatment == SoftCoreTreatment::RPower6) { rinv6 = rpinvV; } else { rinv6 = rinvV*rinvV; rinv6 = rinv6*rinv6*rinv6; } Vvdw6 = c6[i]*rinv6; Vvdw12 = c12[i]*rinv6*rinv6; Vvdw[i] = ( (Vvdw12 - c12[i]*sh_invrc6*sh_invrc6)*onetwelfth - (Vvdw6 - c6[i]*sh_invrc6)*onesixth); FscalV[i] = Vvdw12 - Vvdw6; if (bEwaldLJ) { c6grid = nbfp_grid[tj[i]]; Vvdw[i] += c6grid*sh_lj_ewald*onesixth; } if (ic->vdw_modifier == eintmodPOTSWITCH) { d = rV - ic->rvdw_switch; d = (d > zero) ? d : zero; d2 = d*d; sw = one+d2*d*(vdw_swV3+d*(vdw_swV4+d*vdw_swV5)); dsw = d2*(vdw_swF2+d*(vdw_swF3+d*vdw_swF4)); FscalV[i] = FscalV[i]*sw - rV*Vvdw[i]*dsw; Vvdw[i] *= sw; FscalV[i] = (rV < rvdw) ? FscalV[i] : zero; Vvdw[i] = (rV < rvdw) ? Vvdw[i] : zero; } } FscalC[i] *= rpinvC; FscalV[i] *= rpinvV; } } for (i = 0; i < NSTATES; i++) { vctot += LFC[i]*Vcoul[i]; vvtot += LFV[i]*Vvdw[i]; Fscal += LFC[i]*FscalC[i]*rpm2; Fscal += LFV[i]*FscalV[i]*rpm2; if (useSoftCore) { dvdl_coul += Vcoul[i]*DLF[i] + LFC[i]*alpha_coul_eff*dlfac_coul[i]*FscalC[i]*sigma_pow[i]; dvdl_vdw += Vvdw[i]*DLF[i] + LFV[i]*alpha_vdw_eff*dlfac_vdw[i]*FscalV[i]*sigma_pow[i]; } else { dvdl_coul += Vcoul[i]*DLF[i]; dvdl_vdw += Vvdw[i]*DLF[i]; } } } else if (icoul == GMX_NBKERNEL_ELEC_REACTIONFIELD) { VV = krf*rsq - crf; FF = -two*krf; if (ii == jnr) { VV *= half; } for (i = 0; i < NSTATES; i++) { vctot += LFC[i]*qq[i]*VV; Fscal += LFC[i]*qq[i]*FF; dvdl_coul += DLF[i]*qq[i]*VV; } } if (bEwald && r < rcoulomb) { real v_lr, f_lr; ewrt = r*ewtabscale; ewitab = static_cast<int>(ewrt); eweps = ewrt-ewitab; ewitab = 4*ewitab; f_lr = ewtab[ewitab]+eweps*ewtab[ewitab+1]; v_lr = (ewtab[ewitab+2]-ewtabhalfspace*eweps*(ewtab[ewitab]+f_lr)); f_lr *= rinv; if (ii == jnr) { v_lr *= half; } for (i = 0; i < NSTATES; i++) { vctot -= LFC[i]*qq[i]*v_lr; Fscal -= LFC[i]*qq[i]*f_lr; dvdl_coul -= (DLF[i]*qq[i])*v_lr; } } if (bEwaldLJ && r < rvdw) { real rs, frac, f_lr; int ri; rs = rsq*rinv*ewtabscale; ri = static_cast<int>(rs); frac = rs - ri; f_lr = (1 - frac)*tab_ewald_F_lj[ri] + frac*tab_ewald_F_lj[ri+1]; FF = f_lr*rinv/six; VV = (tab_ewald_V_lj[ri] - ewtabhalfspace*frac*(tab_ewald_F_lj[ri] + f_lr))/six; if (ii == jnr) { VV *= half; } for (i = 0; i < NSTATES; i++) { c6grid = nbfp_grid[tj[i]]; vvtot += LFV[i]*c6grid*VV; Fscal += LFV[i]*c6grid*FF; dvdl_vdw += (DLF[i]*c6grid)*VV; } } if (bDoForces) { tx = Fscal*dx; ty = Fscal*dy; tz = Fscal*dz; fix = fix + tx; fiy = fiy + ty; fiz = fiz + tz; #pragma omp atomic f[j3] -= tx; #pragma omp atomic f[j3+1] -= ty; #pragma omp atomic f[j3+2] -= tz; } } if (npair_within_cutoff > 0) { if (bDoForces) { #pragma omp atomic f[ii3] += fix; #pragma omp atomic f[ii3+1] += fiy; #pragma omp atomic f[ii3+2] += fiz; } if (bDoShiftForces) { #pragma omp atomic fshift[is3] += fix; #pragma omp atomic fshift[is3+1] += fiy; #pragma omp atomic fshift[is3+2] += fiz; } if (bDoPotential) { ggid = gid[n]; #pragma omp atomic Vc[ggid] += vctot; #pragma omp atomic Vv[ggid] += vvtot; } } } #pragma omp atomic dvdl[efptCOUL] += dvdl_coul; #pragma omp atomic dvdl[efptVDW] += dvdl_vdw; #pragma omp atomic inc_nrnb(nrnb, eNR_NBKERNEL_FREE_ENERGY, nlist->nri*12 + nlist->jindex[n]*150); } void gmx_nb_free_energy_kernel(const t_nblist *nlist, rvec *xx, rvec *ff, t_forcerec *fr, const t_mdatoms *mdatoms, nb_kernel_data_t *kernel_data, t_nrnb *nrnb) { if (fr->sc_alphacoul == 0 && fr->sc_alphavdw == 0) { nb_free_energy_kernel<SoftCoreTreatment::None>(nlist, xx, ff, fr, mdatoms, kernel_data, nrnb); } else if (fr->sc_r_power == 6.0_real) { nb_free_energy_kernel<SoftCoreTreatment::RPower6>(nlist, xx, ff, fr, mdatoms, kernel_data, nrnb); } else if (fr->sc_r_power == 48.0_real) { nb_free_energy_kernel<SoftCoreTreatment::RPower48>(nlist, xx, ff, fr, mdatoms, kernel_data, nrnb); } else { GMX_RELEASE_ASSERT(false, "Unsupported soft-core r-power"); } }
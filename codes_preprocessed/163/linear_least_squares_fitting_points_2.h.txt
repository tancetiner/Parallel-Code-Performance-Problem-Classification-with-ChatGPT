#ifndef CGAL_LINEAR_LEAST_SQUARES_FITTING_POINTS_2_H #define CGAL_LINEAR_LEAST_SQUARES_FITTING_POINTS_2_H #include <CGAL/basic.h> #include <CGAL/Object.h> #include <CGAL/centroid.h> #include <CGAL/eigen_2.h> #include <iterator> #include <cmath> namespace CGAL { namespace internal { template < typename InputIterator, typename K > typename K::FT linear_least_squares_fitting_2(InputIterator first, InputIterator beyond, typename K::Line_2& line, typename K::Point_2& c, const typename K::Point_2*, const K&, const CGAL::Dimension_tag<0>& tag) { typedef typename K::FT FT; typedef typename K::Line_2 Line; typedef typename K::Point_2 Point; typedef typename K::Vector_2 Vector; CGAL_precondition(first != beyond); c = centroid(first,beyond,K(),tag); FT covariance[3] = {0,0,0}; for(InputIterator it = first; it != beyond; it++) { const Point& p = *it; Vector d = p - c; covariance[0] += d.x() * d.x(); covariance[1] += d.x() * d.y(); covariance[2] += d.y() * d.y(); } std::pair<FT,FT> eigen_values; std::pair<Vector,Vector> eigen_vectors; internal::eigen_symmetric_2<K>(covariance, eigen_vectors, eigen_values); if(eigen_values.first != eigen_values.second) { line = Line(c, eigen_vectors.first); return (FT)1.0 - eigen_values.second / eigen_values.first; } else { line = Line(c, Vector(FT(1), FT(0))); return (FT)0.0; } } } } #endif
#ifndef LIBMESH_PARALLEL_GHOST_SYNC_H #define LIBMESH_PARALLEL_GHOST_SYNC_H #include "libmesh/auto_ptr.h" #include "libmesh/elem.h" #include "libmesh/location_maps.h" #include "libmesh/mesh_base.h" #include "libmesh/parallel.h" namespace libMesh { namespace Parallel { template <typename Iterator, typename DofObjType, typename SyncFunctor> void sync_dofobject_data_by_xyz(const Communicator & comm, const Iterator & range_begin, const Iterator & range_end, LocationMap<DofObjType> * location_map, SyncFunctor & sync); template <typename Iterator, typename SyncFunctor> void sync_dofobject_data_by_id(const Communicator & comm, const Iterator & range_begin, const Iterator & range_end, SyncFunctor & sync); template <typename Iterator, typename DofObjectCheckFunctor, typename SyncFunctor> void sync_dofobject_data_by_id(const Communicator & comm, const Iterator & range_begin, const Iterator & range_end, const DofObjectCheckFunctor & dofobj_check, SyncFunctor & sync); template <typename Iterator, typename SyncFunctor> void sync_element_data_by_parent_id(MeshBase & mesh, const Iterator & range_begin, const Iterator & range_end, SyncFunctor & sync); template <typename ElemCheckFunctor, typename NodeCheckFunctor, typename SyncFunctor> bool sync_node_data_by_element_id_once(MeshBase & mesh, const MeshBase::const_element_iterator & range_begin, const MeshBase::const_element_iterator & range_end, const ElemCheckFunctor & elem_check, const NodeCheckFunctor & node_check, SyncFunctor & sync); template <typename ElemCheckFunctor, typename NodeCheckFunctor, typename SyncFunctor> void sync_node_data_by_element_id(MeshBase & mesh, const MeshBase::const_element_iterator & range_begin, const MeshBase::const_element_iterator & range_end, const ElemCheckFunctor & elem_check, const NodeCheckFunctor & node_check, SyncFunctor & sync); struct SyncEverything { SyncEverything() {} bool operator() (const DofObject *) const { return true; } bool operator() (const Elem *, unsigned int) const { return true; } }; template <typename Iterator, typename DofObjType, typename SyncFunctor> void sync_dofobject_data_by_xyz(const Communicator & comm, const Iterator & range_begin, const Iterator & range_end, LocationMap<DofObjType> & location_map, SyncFunctor & sync) { libmesh_parallel_only(comm); #ifdef DEBUG bool need_map_update = (range_begin != range_end && location_map.empty()); comm.max(need_map_update); libmesh_assert(!need_map_update); #endif std::vector<dof_id_type> ghost_objects_from_proc(comm.size(), 0); for (Iterator it = range_begin; it != range_end; ++it) { DofObjType * obj = *it; libmesh_assert (obj); processor_id_type obj_procid = obj->processor_id(); if (obj_procid != DofObject::invalid_processor_id) ghost_objects_from_proc[obj_procid]++; } std::vector<std::vector<Real>> requested_objs_x(comm.size()), requested_objs_y(comm.size()), requested_objs_z(comm.size()); std::vector<std::vector<dof_id_type>> requested_objs_id(comm.size()); for (processor_id_type p=0; p != comm.size(); ++p) if (p != comm.rank()) { requested_objs_x[p].reserve(ghost_objects_from_proc[p]); requested_objs_y[p].reserve(ghost_objects_from_proc[p]); requested_objs_z[p].reserve(ghost_objects_from_proc[p]); requested_objs_id[p].reserve(ghost_objects_from_proc[p]); } for (Iterator it = range_begin; it != range_end; ++it) { DofObjType * obj = *it; processor_id_type obj_procid = obj->processor_id(); if (obj_procid == comm.rank() || obj_procid == DofObject::invalid_processor_id) continue; Point p = location_map.point_of(*obj); requested_objs_x[obj_procid].push_back(p(0)); requested_objs_y[obj_procid].push_back(p(1)); requested_objs_z[obj_procid].push_back(p(2)); requested_objs_id[obj_procid].push_back(obj->id()); } for (processor_id_type p=1; p != comm.size(); ++p) { const processor_id_type procup = cast_int<processor_id_type> ((comm.rank() + p) % comm.size()); const processor_id_type procdown = cast_int<processor_id_type> ((comm.size() + comm.rank() - p) % comm.size()); std::vector<Real> request_to_fill_x, request_to_fill_y, request_to_fill_z; comm.send_receive(procup, requested_objs_x[procup], procdown, request_to_fill_x); comm.send_receive(procup, requested_objs_y[procup], procdown, request_to_fill_y); comm.send_receive(procup, requested_objs_z[procup], procdown, request_to_fill_z); std::vector<dof_id_type> request_to_fill_id(request_to_fill_x.size()); for (std::size_t i=0; i != request_to_fill_x.size(); ++i) { Point pt(request_to_fill_x[i], request_to_fill_y[i], request_to_fill_z[i]); DofObjType * obj = location_map.find(pt); libmesh_assert (obj); request_to_fill_id[i] = obj->id(); } std::vector<typename SyncFunctor::datum> data; sync.gather_data(request_to_fill_id, data); std::vector<typename SyncFunctor::datum> received_data; comm.send_receive(procdown, data, procup, received_data); libmesh_assert_equal_to (requested_objs_x[procup].size(), received_data.size()); sync.act_on_data(requested_objs_id[procup], received_data); } } template <typename Iterator, typename SyncFunctor> void sync_dofobject_data_by_id(const Communicator & comm, const Iterator & range_begin, const Iterator & range_end, SyncFunctor & sync) { sync_dofobject_data_by_id(comm, range_begin, range_end, SyncEverything(), sync); } template <typename Iterator, typename DofObjectCheckFunctor, typename SyncFunctor> void sync_dofobject_data_by_id(const Communicator & comm, const Iterator & range_begin, const Iterator & range_end, const DofObjectCheckFunctor & dofobj_check, SyncFunctor & sync) { libmesh_parallel_only(comm); std::vector<dof_id_type> ghost_objects_from_proc(comm.size(), 0); for (Iterator it = range_begin; it != range_end; ++it) { DofObject * obj = *it; libmesh_assert (obj); if (!dofobj_check(*it)) continue; processor_id_type obj_procid = obj->processor_id(); if (obj_procid != DofObject::invalid_processor_id) ghost_objects_from_proc[obj_procid]++; } std::vector<std::vector<dof_id_type>> requested_objs_id(comm.size()); for (processor_id_type p=0; p != comm.size(); ++p) if (p != comm.rank()) { requested_objs_id[p].reserve(ghost_objects_from_proc[p]); } for (Iterator it = range_begin; it != range_end; ++it) { DofObject * obj = *it; if (!dofobj_check(*it)) continue; processor_id_type obj_procid = obj->processor_id(); if (obj_procid == comm.rank() || obj_procid == DofObject::invalid_processor_id) continue; requested_objs_id[obj_procid].push_back(obj->id()); } for (processor_id_type p=1; p != comm.size(); ++p) { const processor_id_type procup = cast_int<processor_id_type> ((comm.rank() + p) % comm.size()); const processor_id_type procdown = cast_int<processor_id_type> ((comm.size() + comm.rank() - p) % comm.size()); std::vector<dof_id_type> request_to_fill_id; comm.send_receive(procup, requested_objs_id[procup], procdown, request_to_fill_id); std::vector<typename SyncFunctor::datum> data; sync.gather_data(request_to_fill_id, data); std::vector<typename SyncFunctor::datum> received_data; comm.send_receive(procdown, data, procup, received_data); libmesh_assert_equal_to (requested_objs_id[procup].size(), received_data.size()); sync.act_on_data(requested_objs_id[procup], received_data); } } #ifdef LIBMESH_ENABLE_AMR template <typename Iterator, typename SyncFunctor> void sync_element_data_by_parent_id(MeshBase & mesh, const Iterator & range_begin, const Iterator & range_end, SyncFunctor & sync) { const Communicator & comm (mesh.comm()); libmesh_parallel_only(comm); std::vector<dof_id_type> ghost_objects_from_proc(comm.size(), 0); for (Iterator it = range_begin; it != range_end; ++it) { DofObject * obj = *it; libmesh_assert (obj); processor_id_type obj_procid = obj->processor_id(); if (obj_procid != DofObject::invalid_processor_id) ghost_objects_from_proc[obj_procid]++; } std::vector<std::vector<dof_id_type>> requested_objs_id(comm.size()), requested_objs_parent_id(comm.size()); std::vector<std::vector<unsigned char>> requested_objs_child_num(comm.size()); for (processor_id_type p=0; p != comm.size(); ++p) if (p != comm.rank()) { requested_objs_id[p].reserve(ghost_objects_from_proc[p]); requested_objs_parent_id[p].reserve(ghost_objects_from_proc[p]); requested_objs_child_num[p].reserve(ghost_objects_from_proc[p]); } for (Iterator it = range_begin; it != range_end; ++it) { Elem * elem = *it; processor_id_type obj_procid = elem->processor_id(); if (obj_procid == comm.rank() || obj_procid == DofObject::invalid_processor_id) continue; const Elem * parent = elem->parent(); if (!parent || !elem->active()) continue; requested_objs_id[obj_procid].push_back(elem->id()); requested_objs_parent_id[obj_procid].push_back(parent->id()); requested_objs_child_num[obj_procid].push_back (cast_int<unsigned char> (parent->which_child_am_i(elem))); } for (processor_id_type p=1; p != comm.size(); ++p) { const processor_id_type procup = cast_int<processor_id_type> ((comm.rank() + p) % comm.size()); const processor_id_type procdown = cast_int<processor_id_type> ((comm.size() + comm.rank() - p) % comm.size()); std::vector<dof_id_type> request_to_fill_parent_id; std::vector<unsigned char> request_to_fill_child_num; comm.send_receive(procup, requested_objs_parent_id[procup], procdown, request_to_fill_parent_id); comm.send_receive(procup, requested_objs_child_num[procup], procdown, request_to_fill_child_num); std::size_t request_size = request_to_fill_parent_id.size(); std::vector<dof_id_type> request_to_fill_id(request_size); for (std::size_t i=0; i != request_size; ++i) { Elem & parent = mesh.elem_ref(request_to_fill_parent_id[i]); libmesh_assert(parent.has_children()); Elem * child = parent.child_ptr(request_to_fill_child_num[i]); libmesh_assert(child); libmesh_assert(child->active()); request_to_fill_id[i] = child->id(); } std::vector<typename SyncFunctor::datum> data; sync.gather_data(request_to_fill_id, data); std::vector<typename SyncFunctor::datum> received_data; comm.send_receive(procdown, data, procup, received_data); libmesh_assert_equal_to (requested_objs_id[procup].size(), received_data.size()); sync.act_on_data(requested_objs_id[procup], received_data); } } #else template <typename Iterator, typename SyncFunctor> void sync_element_data_by_parent_id(MeshBase &, const Iterator &, const Iterator &, SyncFunctor &) { } #endif template <typename ElemCheckFunctor, typename NodeCheckFunctor, typename SyncFunctor> bool sync_node_data_by_element_id_once(MeshBase & mesh, const MeshBase::const_element_iterator & range_begin, const MeshBase::const_element_iterator & range_end, const ElemCheckFunctor & elem_check, const NodeCheckFunctor & node_check, SyncFunctor & sync) { const Communicator & comm (mesh.comm()); bool data_changed = false; std::vector<dof_id_type> ghost_objects_from_proc(comm.size(), 0); for (const auto & elem : as_range(range_begin, range_end)) { libmesh_assert (elem); if (!elem_check(elem)) continue; const processor_id_type proc_id = elem->processor_id(); if (proc_id == comm.rank() || proc_id == DofObject::invalid_processor_id) continue; for (auto n : elem->node_index_range()) { if (!node_check(elem, n)) continue; ghost_objects_from_proc[proc_id]++; } } std::vector<std::vector<dof_id_type>> requested_objs_elem_id(comm.size()); std::vector<std::vector<unsigned char>> requested_objs_node_num(comm.size()); std::vector<std::vector<dof_id_type>> requested_objs_id(comm.size()); for (processor_id_type p=0; p != comm.size(); ++p) if (p != comm.rank()) { requested_objs_elem_id[p].reserve(ghost_objects_from_proc[p]); requested_objs_node_num[p].reserve(ghost_objects_from_proc[p]); requested_objs_id[p].reserve(ghost_objects_from_proc[p]); } for (const auto & elem : as_range(range_begin, range_end)) { libmesh_assert (elem); if (!elem_check(elem)) continue; const processor_id_type proc_id = elem->processor_id(); if (proc_id == comm.rank() || proc_id == DofObject::invalid_processor_id) continue; const dof_id_type elem_id = elem->id(); for (auto n : elem->node_index_range()) { if (!node_check(elem, n)) continue; const Node & node = elem->node_ref(n); const dof_id_type node_id = node.id(); requested_objs_elem_id[proc_id].push_back(elem_id); requested_objs_node_num[proc_id].push_back (cast_int<unsigned char>(n)); requested_objs_id[proc_id].push_back(node_id); } } for (processor_id_type p=1; p != comm.size(); ++p) { const processor_id_type procup = cast_int<processor_id_type> ((comm.rank() + p) % comm.size()); const processor_id_type procdown = cast_int<processor_id_type> ((comm.size() + comm.rank() - p) % comm.size()); libmesh_assert_equal_to (requested_objs_id[procup].size(), ghost_objects_from_proc[procup]); libmesh_assert_equal_to (requested_objs_elem_id[procup].size(), ghost_objects_from_proc[procup]); libmesh_assert_equal_to (requested_objs_node_num[procup].size(), ghost_objects_from_proc[procup]); std::vector<dof_id_type> request_to_fill_elem_id; std::vector<unsigned char> request_to_fill_node_num; comm.send_receive(procup, requested_objs_elem_id[procup], procdown, request_to_fill_elem_id); comm.send_receive(procup, requested_objs_node_num[procup], procdown, request_to_fill_node_num); std::size_t request_size = request_to_fill_elem_id.size(); std::vector<dof_id_type> request_to_fill_id(request_size); for (std::size_t i=0; i != request_size; ++i) { const Elem & elem = mesh.elem_ref(request_to_fill_elem_id[i]); const unsigned int n = request_to_fill_node_num[i]; libmesh_assert_less (n, elem.n_nodes()); const Node & node = elem.node_ref(n); request_to_fill_id[i] = node.id(); } std::vector<typename SyncFunctor::datum> data; sync.gather_data(request_to_fill_id, data); std::vector<typename SyncFunctor::datum> received_data; comm.send_receive(procdown, data, procup, received_data); libmesh_assert_equal_to (requested_objs_elem_id[procup].size(), received_data.size()); if (sync.act_on_data(requested_objs_id[procup], received_data)) data_changed = true; } comm.max(data_changed); return data_changed; } template <typename ElemCheckFunctor, typename NodeCheckFunctor, typename SyncFunctor> void sync_node_data_by_element_id(MeshBase & mesh, const MeshBase::const_element_iterator & range_begin, const MeshBase::const_element_iterator & range_end, const ElemCheckFunctor & elem_check, const NodeCheckFunctor & node_check, SyncFunctor & sync) { libmesh_parallel_only(mesh.comm()); bool need_sync = false; do { need_sync = sync_node_data_by_element_id_once (mesh, range_begin, range_end, elem_check, node_check, sync); } while (need_sync); } } struct SyncNodalPositions { explicit SyncNodalPositions(MeshBase & m); typedef Point datum; void gather_data (const std::vector<dof_id_type> & ids, std::vector<datum> & data) const; void act_on_data (const std::vector<dof_id_type> & ids, std::vector<datum> & data) const; MeshBase & mesh; }; } #endif
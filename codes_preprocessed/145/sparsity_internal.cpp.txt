#include "sparsity_internal.hpp" #include "casadi_misc.hpp" #include <climits> #include <cstdlib> #include <cmath> #include "matrix.hpp" using namespace std; namespace casadi { void SparsityInternal::etree(const casadi_int* sp, casadi_int* parent, casadi_int *w, casadi_int ata) { casadi_int r, c, k, rnext; casadi_int nrow = *sp++, ncol = *sp++; const casadi_int *colind = sp, *row = sp+ncol+1; casadi_int *ancestor=w; casadi_int *prev; if (ata) { prev=w+ncol; for (r=0; r<nrow; ++r) prev[r] = -1; } for (c=0; c<ncol; ++c) { parent[c] = -1; ancestor[c] = -1; for (k=colind[c]; k<colind[c+1]; ++k) { r = row[k]; if (ata) r = prev[r]; while (r!=-1 && r<c) { rnext = ancestor[r]; ancestor[r] = c; if (rnext==-1) parent[r] = c; r = rnext; } if (ata) prev[row[k]] = c; } } } casadi_int SparsityInternal::postorder_dfs(casadi_int j, casadi_int k, casadi_int* head, casadi_int* next, casadi_int* post, casadi_int* stack) { casadi_int i, p, top=0; stack[0] = j; while (top>=0) { p = stack[top]; i = head[p]; if (i==-1) { top--; post[k++] = p; } else { head[p] = next[i]; stack[++top] = i; } } return k; } void SparsityInternal::postorder(const casadi_int* parent, casadi_int n, casadi_int* post, casadi_int* w) { casadi_int j, k=0; casadi_int *head, *next, *stack; head=w; w+=n; next=w; w+=n; stack=w; w+=n; for (j=0; j<n; ++j) head[j] = -1; for (j=n-1; j>=0; --j) { if (parent[j]!=-1) { next[j] = head[parent[j]]; head[parent[j]] = j; } } for (j=0; j<n; j++) { if (parent[j]==-1) { k = postorder_dfs(j, k, head, next, post, stack); } } } casadi_int SparsityInternal:: leaf(casadi_int i, casadi_int j, const casadi_int* first, casadi_int* maxfirst, casadi_int* prevleaf, casadi_int* ancestor, casadi_int* jleaf) { casadi_int q, s, sparent, jprev; *jleaf = 0; if (i<=j || first[j]<=maxfirst[i]) return -1; maxfirst[i] = first[j]; jprev = prevleaf[i]; prevleaf[i] = j; *jleaf = (jprev == -1) ? 1 : 2; if (*jleaf==1) return i; for (q=jprev; q!=ancestor[q]; q=ancestor[q]) {} for (s=jprev; s!=q; s=sparent) { sparent = ancestor[s]; ancestor[s] = q; } return q; } casadi_int SparsityInternal:: qr_counts(const casadi_int* tr_sp, const casadi_int* parent, const casadi_int* post, casadi_int* counts, casadi_int* w) { casadi_int ncol = *tr_sp++, nrow = *tr_sp++; const casadi_int *rowind=tr_sp, *col=tr_sp+nrow+1; casadi_int i, j, k, J, p, q, jleaf, *maxfirst, *prevleaf, *ancestor, *head=0, *next=0, *first; ancestor=w; w+=ncol; maxfirst=w; w+=ncol; prevleaf=w; w+=ncol; first=w; w+=ncol; head=w; w+=ncol+1; next=w; w+=nrow; for (k=0; k<ncol; ++k) first[k]=-1; for (k=0; k<ncol; ++k) { j=post[k]; counts[j] = (first[j]==-1) ? 1 : 0; for (; j!=-1 && first[j]==-1; j=parent[j]) first[j]=k; } for (k=0; k<ncol; ++k) ancestor[post[k]] = k; for (k=0; k<ncol+1; ++k) head[k]=-1; for (i=0; i<nrow; ++i) { for (k=ncol, p=rowind[i]; p<rowind[i+1]; ++p) { k = std::min(k, ancestor[col[p]]); } next[i] = head[k]; head[k] = i; } for (k=0; k<ncol; ++k) maxfirst[k]=-1; for (k=0; k<ncol; ++k) prevleaf[k]=-1; for (i=0; i<ncol; ++i) ancestor[i]=i; for (k=0; k<ncol; ++k) { j=post[k]; if (parent[j]!=-1) counts[parent[j]]--; J=head[k]; while (J!=-1) { for (p=rowind[J]; p<rowind[J+1]; ++p) { i=col[p]; q = leaf(i, j, first, maxfirst, prevleaf, ancestor, &jleaf); if (jleaf>=1) counts[j]++; if (jleaf==2) counts[q]--; } J = next[J]; } if (parent[j]!=-1) ancestor[j]=parent[j]; } for (j=0; j<ncol; ++j) { if (parent[j]!=-1) counts[parent[j]] += counts[j]; } casadi_int sum_counts = 0; for (j=0; j<ncol; ++j) sum_counts += counts[j]; return sum_counts; } casadi_int SparsityInternal:: qr_nnz(const casadi_int* sp, casadi_int* pinv, casadi_int* leftmost, const casadi_int* parent, casadi_int* nrow_ext, casadi_int* w) { casadi_int nrow = sp[0], ncol = sp[1]; const casadi_int *colind=sp+2, *row=sp+2+ncol+1; casadi_int *next=w; w+=nrow; casadi_int *head=w; w+=ncol; casadi_int *tail=w; w+=ncol; casadi_int *nque=w; w+=ncol; casadi_int r, c, k, pa; for (c=0; c<ncol; ++c) head[c] = -1; for (c=0; c<ncol; ++c) tail[c] = -1; for (c=0; c<ncol; ++c) nque[c] = 0; for (r=0; r<nrow; ++r) leftmost[r] = -1; for (c=ncol-1; c>=0; --c) { for (k=colind[c]; k<colind[c+1]; ++k) { leftmost[row[k]] = c; } } for (r=nrow-1; r>=0; --r) { pinv[r] = -1; c=leftmost[r]; if (c==-1) continue; if (nque[c]++ == 0) tail[c]=r; next[r] = head[c]; head[c] = r; } casadi_int v_nnz = 0; casadi_int nrow_new = nrow; for (c=0; c<ncol; ++c) { r = head[c]; v_nnz++; if (r<0) r=nrow_new++; pinv[r] = c; if (--nque[c]<=0) continue; v_nnz += nque[c]; if ((pa=parent[c]) != -1) { if (nque[pa]==0) tail[pa] = tail[c]; next[tail[c]] = head[pa]; head[pa] = next[r]; nque[pa] += nque[c]; } } for (r=0; r<nrow; ++r) if (pinv[r]<0) pinv[r] = c++; if (nrow_ext) *nrow_ext = nrow_new; return v_nnz; } void SparsityInternal:: qr_init(const casadi_int* sp, const casadi_int* sp_tr, casadi_int* leftmost, casadi_int* parent, casadi_int* pinv, casadi_int* nrow_ext, casadi_int* v_nnz, casadi_int* r_nnz, casadi_int* w) { casadi_int ncol = sp[1]; etree(sp, parent, w, 1); casadi_int* post = w; w += ncol; postorder(parent, ncol, post, w); *r_nnz = qr_counts(sp_tr, parent, post, w, w+ncol); *v_nnz = qr_nnz(sp, pinv, leftmost, parent, nrow_ext, w); } void SparsityInternal:: qr_sparsities(const casadi_int* sp_a, casadi_int nrow_ext, casadi_int* sp_v, casadi_int* sp_r, const casadi_int* leftmost, const casadi_int* parent, const casadi_int* pinv, casadi_int* iw) { casadi_int ncol = sp_a[1]; const casadi_int *colind=sp_a+2, *row=sp_a+2+ncol+1; casadi_int *v_colind=sp_v+2, *v_row=sp_v+2+ncol+1; casadi_int *r_colind=sp_r+2, *r_row=sp_r+2+ncol+1; sp_v[0] = sp_r[0] = nrow_ext; sp_v[1] = sp_r[1] = ncol; casadi_int* s = iw; iw += ncol; casadi_int r, c, k, k1, top, len, k2, r2; for (r=0; r<nrow_ext; ++r) iw[r] = -1; casadi_int nnz_r=0, nnz_v=0; for (c=0; c<ncol; ++c) { r_colind[c] = nnz_r; v_colind[c] = k1 = nnz_v; iw[c] = c; v_row[nnz_v++] = c; top = ncol; for (k=colind[c]; k<colind[c+1]; ++k) { r = leftmost[row[k]]; for (len=0; iw[r]!=c; r=parent[r]) { s[len++] = r; iw[r] = c; } while (len>0) s[--top] = s[--len]; r = pinv[row[k]]; if (r>c && iw[r]<c) { v_row[nnz_v++] = r; iw[r] = c; } } for (k = top; k<ncol; ++k) { r = s[k]; r_row[nnz_r++] = r; if (parent[r]==c) { for (k2=v_colind[r]; k2<v_colind[r+1]; ++k2) { r2 = v_row[k2]; if (iw[r2]<c) { iw[r2] = c; v_row[nnz_v++] = r2; } } } } r_row[nnz_r++] = c; } r_colind[ncol] = nnz_r; v_colind[ncol] = nnz_v; } void SparsityInternal:: ldl_colind(const casadi_int* sp, casadi_int* parent, casadi_int* l_colind, casadi_int* w) { casadi_int n = sp[0]; const casadi_int *colind=sp+2, *row=sp+2+n+1; casadi_int r, c, k; casadi_int* visited=w; w+=n; for (c=0; c<n; ++c) { parent[c] = -1; visited[c] = c; l_colind[1+c] = 0; for (k=colind[c]; k<colind[c+1] && (r=row[k])<c; ++k) { while (visited[r]!=c) { if (parent[r]==-1) parent[r]=c; l_colind[1+r]++; visited[r] = c; r=parent[r]; } } } l_colind[0] = 0; for (c=0; c<n; ++c) l_colind[c+1] += l_colind[c]; } void SparsityInternal:: ldl_row(const casadi_int* sp, const casadi_int* parent, casadi_int* l_colind, casadi_int* l_row, casadi_int *w) { casadi_int n = sp[0]; const casadi_int *colind = sp+2, *row = sp+n+3; casadi_int *visited=w; w+=n; casadi_int r, c, k; for (c=0; c<n; ++c) { visited[c] = c; for (k=colind[c]; k<colind[c+1] && (r=row[k])<c; ++k) { while (visited[r]!=c) { l_row[l_colind[r]++] = c; visited[r] = c; r=parent[r]; } } } k=0; for (c=0; c<n; ++c) { r=l_colind[c]; l_colind[c]=k; k=r; } } SparsityInternal:: SparsityInternal(casadi_int nrow, casadi_int ncol, const casadi_int* colind, const casadi_int* row) : sp_(2 + ncol+1 + colind[ncol]), btf_(0) { sp_[0] = nrow; sp_[1] = ncol; std::copy(colind, colind+ncol+1, sp_.begin()+2); std::copy(row, row+colind[ncol], sp_.begin()+2+ncol+1); } SparsityInternal::~SparsityInternal() { if (btf_) delete btf_; } const SparsityInternal::Btf& SparsityInternal::btf() const { if (!btf_) { btf_ = new SparsityInternal::Btf(); btf_->nb = btf(btf_->rowperm, btf_->colperm, btf_->rowblock, btf_->colblock, btf_->coarse_rowblock, btf_->coarse_colblock); } return *btf_; } casadi_int SparsityInternal::numel() const { return size1()*size2(); } void SparsityInternal::disp(ostream &stream, bool more) const { stream << dim(!is_dense()); if (more) { stream << endl; stream << "colind: " << get_colind() << endl; stream << "row: " << get_row() << endl; } } vector<casadi_int> SparsityInternal::get_col() const { const casadi_int* colind = this->colind(); vector<casadi_int> col(nnz()); for (casadi_int r=0; r<size2(); ++r) { for (casadi_int el = colind[r]; el < colind[r+1]; ++el) { col[el] = r; } } return col; } Sparsity SparsityInternal::T() const { vector<casadi_int> mapping; return transpose(mapping); } Sparsity SparsityInternal::transpose(vector<casadi_int>& mapping, bool invert_mapping) const { vector<casadi_int> trans_col = get_row(); vector<casadi_int> trans_row = get_col(); return Sparsity::triplet(size2(), size1(), trans_row, trans_col, mapping, invert_mapping); } casadi_int SparsityInternal::dfs(casadi_int j, casadi_int top, std::vector<casadi_int>& xi, std::vector<casadi_int>& pstack, const std::vector<casadi_int>& pinv, std::vector<bool>& marked) const { casadi_int head = 0; const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); xi[0] = j; while (head >= 0) { j = xi[head]; casadi_int jnew = !pinv.empty() ? (pinv[j]) : j; if (!marked[j]) { marked[j]=true; pstack[head] = (jnew < 0) ? 0 : colind[jnew]; } casadi_int done = 1; casadi_int p2 = (jnew < 0) ? 0 : colind[jnew+1]; for (casadi_int p = pstack[head]; p< p2; ++p) { casadi_int i = row[p]; if (marked[i]) continue ; pstack[head] = p; xi[++head] = i; done = 0; break; } if (done) { head--; xi[--top] = j ; } } return (top) ; } casadi_int SparsityInternal::scc(std::vector<casadi_int>& p, std::vector<casadi_int>& r) const { vector<casadi_int> tmp; Sparsity AT = T(); vector<casadi_int> xi(2*size2()+1); vector<casadi_int>& Blk = xi; vector<casadi_int> pstack(size2()+1); p.resize(size2()); r.resize(size2()+6); vector<bool> marked(size2(), false); casadi_int top = size2(); for (casadi_int i = 0; i<size2(); ++i) { if (!marked[i]) top = dfs(i, top, xi, pstack, tmp, marked); } fill(marked.begin(), marked.end(), false); top = size2(); casadi_int nb = size2(); for (casadi_int k=0 ; k < size2() ; ++k) { casadi_int i = xi[k]; if (marked[i]) continue; r[nb--] = top; top = AT.dfs(i, top, p, pstack, tmp, marked); } r[nb] = 0; for (casadi_int k = nb ; k <= size2() ; ++k) r[k-nb] = r[k] ; nb = size2()-nb; for (casadi_int b = 0 ; b < nb ; b++) { for (casadi_int k = r[b]; k<r[b+1] ; ++k) Blk[p[k]] = b ; } for (casadi_int i=0; i<size2(); ++i) { p[r[Blk[i]]++] = i; } r.resize(nb+1); for (casadi_int i=nb; i>0; --i) { r[i]=r[i-1]; } r[0]=0; return nb; } std::vector<casadi_int> SparsityInternal::amd() const { casadi_assert(is_symmetric(), "AMD requires a symmetric matrix"); casadi_int n=size2(); vector<casadi_int> colind = get_colind(); vector<casadi_int> row = get_row(); casadi_int nnz = 0; casadi_int col_begin, col_end=0; for (casadi_int c=0; c<n; ++c) { col_begin = col_end; col_end = colind[c+1]; for (casadi_int k=col_begin; k<col_end; ++k) { if (row[k]!=c) { row[nnz++] = row[k]; } } colind[c+1] = nnz; } casadi_int dense = static_cast<casadi_int>(10*sqrt(static_cast<double>(n))); dense = std::max(casadi_int(16), dense); dense = std::min(n-2, dense); vector<casadi_int> P(n+1); vector<casadi_int> len(n+1), nv(n+1), next(n+1), head(n+1), elen(n+1), degree(n+1), w(n+1), hhead(n+1); casadi_int nel = 0; casadi_int mindeg = 0; casadi_int lemax = 0; casadi_int d; casadi_uint h; #define FLIP(i) (-(i)-2) for (casadi_int k = 0; k<n; ++k) len[k] = colind[k+1] - colind[k]; len[n] = 0; casadi_int nzmax = row.size(); for (casadi_int i=0; i<=n; ++i) { head[i] = -1; P[i] = -1; next[i] = -1; hhead[i] = -1; nv[i] = 1; w[i] = 1; elen[i] = 0; degree[i] = len[i]; } casadi_int mark = wclear(0, 0, get_ptr(w), n); elen[n] = -2; colind[n] = -1; w[n] = 0; for (casadi_int i = 0; i < n; ++i) { d = degree[i]; if (d == 0) { elen[i] = -2; nel++; colind[i] = -1; w[i] = 0; } else if (d > dense) { nv[i] = 0; elen[i] = -1; nel++; colind[i] = FLIP(n); nv[n]++; } else { if (head[d] != -1) P[head[d]] = i; next[i] = head[d]; head[d] = i; } } while (nel < n) { casadi_int k; for (k = -1; mindeg < n && (k = head[mindeg]) == -1; mindeg++) {} if (next[k] != -1) P[next[k]] = -1; head[mindeg] = next[k]; casadi_int elenk = elen[k]; casadi_int nvk = nv[k]; nel += nvk; if (elenk > 0 && nnz + mindeg >= nzmax) { for (casadi_int j = 0; j < n; j++) { casadi_int p; if ((p = colind[j]) >= 0) { colind[j] = row[p]; row[p] = FLIP(j); } } casadi_int q, p; for (q = 0, p = 0; p < nnz; ) { casadi_int j; if ((j = FLIP(row[p++])) >= 0) { row[q] = colind[j]; colind[j] = q++; for (casadi_int k3 = 0; k3 < len[j]-1; k3++) row[q++] = row[p++]; } } nnz = q; } casadi_int dk = 0; nv[k] = -nvk; casadi_int p = colind[k]; casadi_int pk1 = (elenk == 0) ? p : nnz; casadi_int pk2 = pk1; casadi_int e, pj, ln; for (casadi_int k1 = 1; k1 <= elenk + 1; k1++) { if (k1 > elenk) { e = k; pj = p; ln = len[k] - elenk; } else { e = row[p++]; pj = colind[e]; ln = len[e]; } for (casadi_int k2 = 1; k2 <= ln; k2++) { casadi_int i = row[pj++]; casadi_int nvi; if ((nvi = nv[i]) <= 0) continue; dk += nvi; nv[i] = -nvi; row[pk2++] = i; if (next[i] != -1) P[next[i]] = P[i]; if (P[i] != -1) { next[P[i]] = next[i]; } else { head[degree[i]] = next[i]; } } if (e != k) { colind[e] = FLIP(k); w[e] = 0; } } if (elenk != 0) nnz = pk2; degree[k] = dk; colind[k] = pk1; len[k] = pk2 - pk1; elen[k] = -2; mark = wclear(mark, lemax, get_ptr(w), n); for (casadi_int pk = pk1; pk < pk2; pk++) { casadi_int i = row[pk]; casadi_int eln; if ((eln = elen[i]) <= 0) continue; casadi_int nvi = -nv[i]; casadi_int wnvi = mark - nvi; for (p = colind[i]; p <= colind[i] + eln - 1; p++) { e = row[p]; if (w[e] >= mark) { w[e] -= nvi; } else if (w[e] != 0) { w[e] = degree[e] + wnvi; } } } for (casadi_int pk = pk1; pk < pk2; pk++) { casadi_int i = row[pk]; casadi_int p1 = colind[i]; casadi_int p2 = p1 + elen[i] - 1; casadi_int pn = p1; for (h = 0, d = 0, p = p1; p <= p2; p++) { e = row[p]; if (w[e] != 0) { casadi_int dext = w[e] - mark; if (dext > 0) { d += dext; row[pn++] = e; h += e; } else { colind[e] = FLIP(k); w[e] = 0; } } } elen[i] = pn - p1 + 1; casadi_int p3 = pn; casadi_int p4 = p1 + len[i]; for (p = p2 + 1; p < p4; p++) { casadi_int j = row[p]; casadi_int nvj; if ((nvj = nv[j]) <= 0) continue; d += nvj; row[pn++] = j; h += j; } if (d == 0) { colind[i] = FLIP(k); casadi_int nvi = -nv[i]; dk -= nvi; nvk += nvi; nel += nvi; nv[i] = 0; elen[i] = -1; } else { degree[i] = std::min(degree[i], d); row[pn] = row[p3]; row[p3] = row[p1]; row[p1] = k; len[i] = pn - p1 + 1; h %= n; next[i] = hhead[h]; hhead[h] = i; P[i] = h; } } degree[k] = dk; lemax = std::max(lemax, dk); mark = wclear(mark+lemax, lemax, get_ptr(w), n); for (casadi_int pk = pk1; pk < pk2; pk++) { casadi_int i = row[pk]; if (nv[i] >= 0) continue; h = P[i]; i = hhead[h]; hhead[h] = -1; for (; i != -1 && next[i] != -1; i = next[i], mark++) { ln = len[i]; casadi_int eln = elen[i]; for (p = colind[i]+1; p <= colind[i] + ln-1; p++) w[row[p]] = mark; casadi_int jlast = i; for (casadi_int j = next[i]; j != -1; ) { casadi_int ok = (len[j] == ln) && (elen[j] == eln); for (p = colind[j] + 1; ok && p <= colind[j] + ln - 1; p++) { if (w[row[p]] != mark) ok = 0; } if (ok) { colind[j] = FLIP(i); nv[i] += nv[j]; nv[j] = 0; elen[j] = -1; j = next[j]; next[jlast] = j; } else { jlast = j; j = next[j]; } } } } casadi_int pk; for (p = pk1, pk = pk1; pk < pk2; pk++) { casadi_int i = row[pk]; casadi_int nvi; if ((nvi = -nv[i]) <= 0) continue; nv[i] = nvi; d = degree[i] + dk - nvi; d = std::min(d, n - nel - nvi); if (head[d] != -1) P[head[d]] = i; next[i] = head[d]; P[i] = -1; head[d] = i; mindeg = std::min(mindeg, d); degree[i] = d; row[p++] = i; } nv[k] = nvk; if ((len[k] = p-pk1) == 0) { colind[k] = -1; w[k] = 0; } if (elenk != 0) nnz = p; } for (casadi_int i = 0; i < n; i++) colind[i] = FLIP(colind[i]); for (casadi_int j = 0; j <= n; j++) head[j] = -1; for (casadi_int j = n; j >= 0; j--) { if (nv[j] > 0) continue; next[j] = head[colind[j]]; head[colind[j]] = j; } for (casadi_int e = n; e >= 0; e--) { if (nv[e] <= 0) continue; if (colind[e] != -1) { next[e] = head[colind[e]]; head[colind[e]] = e; } } for (casadi_int k = 0, i = 0; i <= n; i++) { if (colind[i] == -1) k = postorder_dfs(i, k, get_ptr(head), get_ptr(next), get_ptr(P), get_ptr(w)); } P.resize(n); return P; #undef FLIP } void SparsityInternal::bfs(casadi_int n, std::vector<casadi_int>& wi, std::vector<casadi_int>& wj, std::vector<casadi_int>& queue, const std::vector<casadi_int>& imatch, const std::vector<casadi_int>& jmatch, casadi_int mark) const { casadi_int head = 0, tail = 0, j, i, p, j2 ; for (j=0; j<n; ++j) { if (imatch[j] >= 0) continue; wj[j] = 0; queue[tail++] = j; } if (tail == 0) return; Sparsity trans; const casadi_int *C_row, *C_colind; if (mark == 1) { C_row = row(); C_colind = colind(); } else { trans = T(); C_row = trans.row(); C_colind = trans.colind(); } while (head < tail) { j = queue[head++]; for (p = C_colind[j] ; p < C_colind[j+1] ; p++) { i = C_row[p] ; if (wi[i] >= 0) continue; wi[i] = mark; j2 = jmatch[i]; if (wj[j2] >= 0) continue; wj[j2] = mark; queue[tail++] = j2; } } } void SparsityInternal::matched(casadi_int n, const std::vector<casadi_int>& wj, const std::vector<casadi_int>& imatch, std::vector<casadi_int>& p, std::vector<casadi_int>& q, std::vector<casadi_int>& cc, std::vector<casadi_int>& rr, casadi_int set, casadi_int mark) { casadi_int kc = cc[set]; casadi_int kr = rr[set-1] ; for (casadi_int j=0; j<n; ++j) { if (wj[j] != mark) continue; p[kr++] = imatch[j] ; q[kc++] = j ; } cc[set+1] = kc ; rr[set] = kr ; } void SparsityInternal::unmatched(casadi_int m, const std::vector<casadi_int>& wi, std::vector<casadi_int>& p, std::vector<casadi_int>& rr, casadi_int set) { casadi_int i, kr = rr[set] ; for (i=0; i<m; i++) if (wi[i] == 0) p[kr++] = i; rr[set+1] = kr; } casadi_int SparsityInternal::rprune(casadi_int i, casadi_int j, double aij, void *other) { vector<casadi_int> &rr = *static_cast<vector<casadi_int> *>(other); return (i >= rr[1] && i < rr[2]) ; } void SparsityInternal::augment(casadi_int k, std::vector<casadi_int>& jmatch, casadi_int *cheap, std::vector<casadi_int>& w, casadi_int *js, casadi_int *is, casadi_int *ps) const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); casadi_int found = 0, p, i = -1, head = 0, j ; js[0] = k ; while (head >= 0) { j = js[head]; if (w[j] != k) { w[j] = k; for (p = cheap[j] ; p < colind[j+1] && !found; ++p) { i = row[p] ; found = (jmatch[i] == -1) ; } cheap[j] = p; if (found) { is[head] = i; break; } ps[head] = colind[j]; } for (p = ps[head]; p<colind[j+1]; ++p) { i = row[p]; if (w[jmatch[i]] == k) continue; ps[head] = p + 1; is[head] = i; js[++head] = jmatch[i]; break ; } if (p == colind[j+1]) head--; } if (found) for (p = head; p>=0; --p) jmatch[is[p]] = js[p]; } void SparsityInternal::maxtrans(std::vector<casadi_int>& imatch, std::vector<casadi_int>& jmatch, Sparsity& trans, casadi_int seed) const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); casadi_int n2 = 0, m2 = 0; jmatch.resize(size1()); imatch.resize(size2()); vector<casadi_int> w(size1()+size2()); casadi_int k=0; for (casadi_int j=0; j<size2(); ++j) { n2 += (colind[j] < colind[j+1]); for (casadi_int p=colind[j]; p < colind[j+1]; ++p) { w[row[p]] = 1; k += (j == row[p]); } } if (k == std::min(size1(), size2())) { casadi_int i; for (i=0; i<k; ++i) jmatch[i] = i; for (; i<size1(); ++i) jmatch[i] = -1; casadi_int j; for (j=0; j<k; ++j) imatch[j] = j; for (; j<size2(); ++j) imatch[j] = -1; } for (casadi_int i=0; i<size1(); ++i) m2 += w[i]; if (m2 < n2 && trans.is_null()) trans = T(); const SparsityInternal* C = m2 < n2 ? static_cast<const SparsityInternal*>(trans.get()) : this; const casadi_int* C_colind = C->colind(); std::vector<casadi_int>& Cjmatch = m2 < n2 ? imatch : jmatch; std::vector<casadi_int>& Cimatch = m2 < n2 ? jmatch : imatch; w.resize(5 * C->size2()); casadi_int *cheap = &w.front() + C->size2(); casadi_int *js = &w.front() + 2*C->size2(); casadi_int *is = &w.front() + 3*C->size2(); casadi_int *ps = &w.front() + 4*C->size2(); for (casadi_int j=0; j<C->size2(); ++j) cheap[j] = C_colind[j]; for (casadi_int j=0; j<C->size2(); ++j) w[j] = -1; for (casadi_int i=0; i<C->size1(); ++i) Cjmatch[i] = -1; std::vector<casadi_int> q = randperm(C->size2(), seed); for (k=0; k<C->size2(); ++k) { C->augment(!q.empty() ? q[k]: k, Cjmatch, cheap, w, js, is, ps); } for (casadi_int j=0; j<C->size2(); ++j) Cimatch[j] = -1; for (casadi_int i = 0; i<C->size1(); ++i) if (Cjmatch[i] >= 0) Cimatch[Cjmatch[i]] = i; } void SparsityInternal::dmperm(std::vector<casadi_int>& rowperm, std::vector<casadi_int>& colperm, std::vector<casadi_int>& rowblock, std::vector<casadi_int>& colblock, std::vector<casadi_int>& coarse_rowblock, std::vector<casadi_int>& coarse_colblock) const { casadi_int seed = 0; Sparsity trans; rowperm.resize(size1()); colperm.resize(size2()); rowblock.resize(size1()+6); colblock.resize(size2()+6); coarse_rowblock.resize(5); fill(coarse_rowblock.begin(), coarse_rowblock.end(), 0); coarse_colblock.resize(5); fill(coarse_colblock.begin(), coarse_colblock.end(), 0); vector<casadi_int> imatch, jmatch; maxtrans(imatch, jmatch, trans, seed); vector<casadi_int>& wi = rowblock; vector<casadi_int>& wj = colblock; for (casadi_int j=0; j<size2(); ++j) wj[j] = -1; for (casadi_int i=0; i<size1(); ++i) wi[i] = -1 ; bfs(size2(), wi, wj, colperm, imatch, jmatch, 1); bfs(size1(), wj, wi, rowperm, jmatch, imatch, 3); unmatched(size2(), wj, colperm, coarse_colblock, 0); matched(size2(), wj, imatch, rowperm, colperm, coarse_colblock, coarse_rowblock, 1, 1); matched(size2(), wj, imatch, rowperm, colperm, coarse_colblock, coarse_rowblock, 2, -1); matched(size2(), wj, imatch, rowperm, colperm, coarse_colblock, coarse_rowblock, 3, 3); unmatched(size1(), wi, rowperm, coarse_rowblock, 3); vector<casadi_int> pinv = invertPermutation(rowperm); std::vector<casadi_int> colind_C, row_C; permute(pinv, colperm, 0, colind_C, row_C); casadi_int nc = coarse_colblock[3] - coarse_colblock[2]; if (coarse_colblock[2] > 0) { for (casadi_int j = coarse_colblock[2]; j <= coarse_colblock[3]; ++j) colind_C[j-coarse_colblock[2]] = colind_C[j]; } casadi_int ncol_C = nc; colind_C.resize(nc+1); if (coarse_rowblock[2] - coarse_rowblock[1] < size1()) { drop(rprune, &coarse_rowblock, size1(), ncol_C, colind_C, row_C); casadi_int cnz = colind_C[nc]; if (coarse_rowblock[1] > 0) for (casadi_int k=0; k<cnz; ++k) row_C[k] -= coarse_rowblock[1]; } row_C.resize(colind_C.back()); casadi_int nrow_C = nc ; Sparsity C(nrow_C, ncol_C, colind_C, row_C, true); vector<casadi_int> scc_p, scc_r; casadi_int scc_nb = C.scc(scc_p, scc_r); vector<casadi_int> ps = scc_p; vector<casadi_int> rs = scc_r; casadi_int nb1 = scc_nb; for (casadi_int k=0; k<nc; ++k) wj[k] = colperm[ps[k] + coarse_colblock[2]]; for (casadi_int k=0; k<nc; ++k) colperm[k + coarse_colblock[2]] = wj[k]; for (casadi_int k=0; k<nc; ++k) wi[k] = rowperm[ps[k] + coarse_rowblock[1]]; for (casadi_int k=0; k<nc; ++k) rowperm[k + coarse_rowblock[1]] = wi[k]; casadi_int nb2 = 0; rowblock[0] = colblock[0] = 0; if (coarse_colblock[2] > 0) nb2++ ; for (casadi_int k=0; k<nb1; ++k) { rowblock[nb2] = rs[k] + coarse_rowblock[1]; colblock[nb2] = rs[k] + coarse_colblock[2] ; nb2++ ; } if (coarse_rowblock[2] < size1()) { rowblock[nb2] = coarse_rowblock[2]; colblock[nb2] = coarse_colblock[3]; nb2++ ; } rowblock[nb2] = size1(); colblock[nb2] = size2() ; rowblock.resize(nb2+1); colblock.resize(nb2+1); } std::vector<casadi_int> SparsityInternal::randperm(casadi_int n, casadi_int seed) { std::vector<casadi_int> p; if (seed==0) return p; p.resize(n); for (casadi_int k=0; k<n; ++k) p[k] = n-k-1; if (seed==-1) return p; #if defined(_WIN32) srand(seed); #else unsigned int seedu = static_cast<unsigned int>(seed); #endif for (casadi_int k=0; k<n; ++k) { #if defined(_WIN32) casadi_int j = k + (rand() % (n-k)); #else casadi_int j = k + (rand_r(&seedu) % (n-k)); #endif casadi_int t = p[j]; p[j] = p[k]; p[k] = t; } return p; } std::vector<casadi_int> SparsityInternal::invertPermutation(const std::vector<casadi_int>& p) { vector<casadi_int> pinv(p.size()); for (casadi_int k=0; k<p.size(); ++k) pinv[p[k]] = k; return pinv; } Sparsity SparsityInternal::permute(const std::vector<casadi_int>& pinv, const std::vector<casadi_int>& q, casadi_int values) const { std::vector<casadi_int> colind_C, row_C; permute(pinv, q, values, colind_C, row_C); return Sparsity(size1(), size2(), colind_C, row_C); } void SparsityInternal::permute(const std::vector<casadi_int>& pinv, const std::vector<casadi_int>& q, casadi_int values, std::vector<casadi_int>& colind_C, std::vector<casadi_int>& row_C) const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); colind_C.resize(size2()+1); row_C.resize(nnz()); casadi_int nz = 0; for (casadi_int k = 0; k<size2(); ++k) { colind_C[k] = nz; casadi_int j = !q.empty() ? (q[k]) : k; for (casadi_int t = colind[j]; t<colind[j+1]; ++t) { row_C[nz++] = !pinv.empty() ? (pinv[row[t]]) : row[t] ; } } colind_C[size2()] = nz; } casadi_int SparsityInternal::drop(casadi_int (*fkeep)(casadi_int, casadi_int, double, void *), void *other, casadi_int nrow, casadi_int ncol, std::vector<casadi_int>& colind, std::vector<casadi_int>& row) { casadi_int nz = 0; for (casadi_int j = 0; j<ncol; ++j) { casadi_int p = colind[j]; colind[j] = nz; for ( ; p < colind[j+1] ; ++p) { if (fkeep(row[p], j, 1, other)) { row[nz++] = row[p] ; } } } colind[ncol] = nz; return nz ; } casadi_int SparsityInternal::wclear(casadi_int mark, casadi_int lemax, casadi_int *w, casadi_int n) { if (mark < 2 || (mark + lemax < 0)) { for (casadi_int k = 0; k<n; ++k) if (w[k] != 0) w[k] = 1; mark = 2 ; } return mark; } casadi_int SparsityInternal::diag(casadi_int i, casadi_int j, double aij, void *other) { return (i != j) ; } casadi_int SparsityInternal::scatter(casadi_int j, std::vector<casadi_int>& w, casadi_int mark, casadi_int* Ci, casadi_int nz) const { casadi_int i, p; const casadi_int *Ap = colind(); const casadi_int *Ai = row(); for (p = Ap[j]; p<Ap[j+1]; ++p) { i = Ai[p]; if (w[i] < mark) { w[i] = mark; Ci[nz++] = i; } } return nz; } Sparsity SparsityInternal::multiply(const Sparsity& B) const { casadi_int nz = 0; casadi_assert(size2() == B.size1(), "Dimension mismatch."); casadi_int m = size1(); casadi_int anz = nnz(); casadi_int n = B.size2(); const casadi_int* Bp = B.colind(); const casadi_int* Bi = B.row(); casadi_int bnz = Bp[n]; vector<casadi_int> w(m); vector<casadi_int> C_colind(n+1, 0), C_row; C_colind.resize(anz + bnz); casadi_int* Cp = &C_colind.front(); for (casadi_int j=0; j<n; ++j) { if (nz+m > C_row.size()) { C_row.resize(2*(C_row.size())+m); } Cp[j] = nz; for (casadi_int p = Bp[j] ; p<Bp[j+1] ; ++p) { nz = scatter(Bi[p], w, j+1, &C_row.front(), nz); } } Cp[n] = nz; C_row.resize(nz); return Sparsity(m, n, C_colind, C_row); } Sparsity SparsityInternal::get_diag(std::vector<casadi_int>& mapping) const { casadi_int nrow = this->size1(); casadi_int ncol = this->size2(); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); mapping.clear(); if (is_vector()) { casadi_int n = nrow * ncol; vector<casadi_int> ret_colind(n+1, 0), ret_row; casadi_int ret_i=0; for (casadi_int cc=0; cc<ncol; ++cc) { for (casadi_int k = colind[cc]; k<colind[cc+1]; ++k) { casadi_int rr=row[k]; casadi_int el=rr+nrow*cc; while (ret_i<=el) ret_colind[ret_i++]=ret_row.size(); ret_row.push_back(el); mapping.push_back(k); } } while (ret_i<=n) ret_colind[ret_i++]=ret_row.size(); return Sparsity(n, n, ret_colind, ret_row); } else { casadi_int n = std::min(nrow, ncol); vector<casadi_int> ret_row, ret_colind(2, 0); for (casadi_int cc=0; cc<n; ++cc) { for (casadi_int el = colind[cc]; el<colind[cc+1]; ++el) { if (row[el]==cc) { ret_row.push_back(row[el]); ret_colind[1]++; mapping.push_back(el); } } } return Sparsity(n, 1, ret_colind, ret_row); } } bool SparsityInternal::has_diag() const { casadi_int nrow = this->size1(); casadi_int ncol = this->size2(); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); for (casadi_int c=0; c<ncol && c<nrow; ++c) { for (casadi_int k=colind[c]; k<colind[c+1]; ++k) { if (row[k]==c) return true; } } return false; } Sparsity SparsityInternal::drop_diag() const { casadi_int nrow = this->size1(); casadi_int ncol = this->size2(); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); vector<casadi_int> ret_colind(ncol+1), ret_row; ret_colind[0] = 0; ret_row.reserve(nnz()); for (casadi_int c=0; c<ncol; ++c) { for (casadi_int k=colind[c]; k<colind[c+1]; ++k) { if (row[k]!=c) { ret_row.push_back(row[k]); } } ret_colind[c+1] = ret_row.size(); } return Sparsity(nrow, ncol, ret_colind, ret_row); } std::string SparsityInternal::dim(bool with_nz) const { std::string ret = str(size1()) + "x" + str(size2()); if (with_nz) ret += "," + str(nnz()) + "nz"; return ret; } std::string SparsityInternal::repr_el(casadi_int k) const { std::stringstream ss; if (numel()!=nnz()) { ss << "nonzero index " << k << " "; } casadi_int r = row()[k]; casadi_int c = get_col()[k]; ss << "(row " << r << ", col " << c << ")"; return ss.str(); } Sparsity SparsityInternal::_mtimes(const Sparsity& y) const { casadi_int d1 = size1(); casadi_int d2 = y.size2(); if (is_scalar(false)) { return is_dense() ? y : Sparsity(y.size()); } else if (y.is_scalar(false)) { return y.is_dense() ? shared_from_this<Sparsity>() : Sparsity(size()); } if (is_dense() && y.is_dense()) { return !is_empty() && !y.is_empty() ? Sparsity::dense(d1, d2) : Sparsity(d1, d2); } if (is_diag()) return y; if (y.is_diag()) return shared_from_this<Sparsity>(); const casadi_int* x_row = row(); const casadi_int* x_colind = colind(); const casadi_int* y_row = y.row(); const casadi_int* y_colind = y.colind(); vector<casadi_int> row, col; vector<casadi_int> tmp(d1, -1); for (casadi_int cc=0; cc<d2; ++cc) { for (casadi_int kk=y_colind[cc]; kk<y_colind[cc+1]; ++kk) { casadi_int rr = y_row[kk]; for (casadi_int kk1=x_colind[rr]; kk1<x_colind[rr+1]; ++kk1) { casadi_int rr1 = x_row[kk1]; if (tmp[rr1]!=cc) { tmp[rr1] = cc; row.push_back(rr1); col.push_back(cc); } } } } return Sparsity::triplet(d1, d2, row, col); } bool SparsityInternal::is_scalar(bool scalar_and_dense) const { return size2()==1 && size1()==1 && (!scalar_and_dense || nnz()==1); } bool SparsityInternal::is_dense() const { return nnz() == numel(); } bool SparsityInternal::is_row() const { return size1()==1; } bool SparsityInternal::is_column() const { return size2()==1; } bool SparsityInternal::is_vector() const { return is_row() || is_column(); } bool SparsityInternal::is_empty(bool both) const { return both ? size2()==0 && size1()==0 : size2()==0 || size1()==0; } bool SparsityInternal::is_diag() const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); if (size2() != size1()) return false; if (nnz() != size2()) return false; for (casadi_int i=0; i<nnz(); ++i) { if (row[i]!=i) return false; } for (casadi_int i=0; i<size2(); ++i) { if (colind[i]!=i) return false; } return true; } bool SparsityInternal::is_square() const { return size2() == size1(); } bool SparsityInternal::is_symmetric() const { return is_transpose(*this); } casadi_int SparsityInternal::nnz_lower(bool strictly) const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); casadi_int nnz = 0; for (casadi_int cc=0; cc<size2(); ++cc) { for (casadi_int el = colind[cc]; el<colind[cc+1]; ++el) { if (cc<row[el] || (!strictly && cc==row[el])) nnz++; } } return nnz; } casadi_int SparsityInternal::nnz_diag() const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); casadi_int nnz = 0; for (casadi_int cc=0; cc<size2(); ++cc) { for (casadi_int el = colind[cc]; el < colind[cc+1]; ++el) { nnz += row[el]==cc; } } return nnz; } casadi_int SparsityInternal::nnz_upper(bool strictly) const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); casadi_int nnz = 0; for (casadi_int cc=0; cc<size2(); ++cc) { for (casadi_int el = colind[cc]; el<colind[cc+1]; ++el) { if (cc>row[el] || (!strictly && cc==row[el])) nnz++; } } return nnz; } std::pair<casadi_int, casadi_int> SparsityInternal::size() const { return std::pair<casadi_int, casadi_int>(size1(), size2()); } Sparsity SparsityInternal::_erase(const vector<casadi_int>& rr, bool ind1, std::vector<casadi_int>& mapping) const { if (rr.empty()) { mapping = range(nnz()); return shared_from_this<Sparsity>(); } casadi_assert_in_range(rr, -numel()+ind1, numel()+ind1); if (ind1 || has_negative(rr)) { std::vector<casadi_int> rr_mod = rr; for (vector<casadi_int>::iterator i=rr_mod.begin(); i!=rr_mod.end(); ++i) { if (ind1) (*i)--; if (*i<0) *i += numel(); } return _erase(rr_mod, false, mapping); } if (!is_nondecreasing(rr)) { std::vector<casadi_int> rr_sorted = rr; std::sort(rr_sorted.begin(), rr_sorted.end()); return _erase(rr_sorted, false, mapping); } mapping.resize(0); if (numel()==0) return shared_from_this<Sparsity>(); mapping.reserve(nnz()); casadi_int nz=0; vector<casadi_int>::const_iterator next_rr = rr.begin(); vector<casadi_int> ret_colind = get_colind(), ret_row = get_row(); casadi_int k_first, k_last=0; for (casadi_int j=0; j<size2(); ++j) { k_first = k_last; k_last = ret_colind[j+1]; for (casadi_int k=k_first; k<k_last; ++k) { casadi_int i=ret_row[k]; casadi_int el = i+j*size1(); while (next_rr!=rr.end() && *next_rr<el) next_rr++; if (next_rr!=rr.end() && *next_rr==el) { next_rr++; continue; } mapping.push_back(k); ret_row[nz++] = i; } ret_colind[j+1] = nz; } ret_row.resize(nz); return Sparsity(size1(), size2(), ret_colind, ret_row); } Sparsity SparsityInternal::_erase(const vector<casadi_int>& rr, const vector<casadi_int>& cc, bool ind1, std::vector<casadi_int>& mapping) const { casadi_assert_in_range(rr, -size1()+ind1, size1()+ind1); casadi_assert_in_range(cc, -size2()+ind1, size2()+ind1); if (ind1 || has_negative(rr) || has_negative(cc) || !is_nondecreasing(rr) || !is_nondecreasing(cc)) { std::vector<casadi_int> rr_mod = rr; for (vector<casadi_int>::iterator i=rr_mod.begin(); i!=rr_mod.end(); ++i) { if (ind1) (*i)--; if (*i<0) *i += size1(); } std::sort(rr_mod.begin(), rr_mod.end()); std::vector<casadi_int> cc_mod = cc; for (vector<casadi_int>::iterator i=cc_mod.begin(); i!=cc_mod.end(); ++i) { if (ind1) (*i)--; if (*i<0) *i += size2(); } std::sort(cc_mod.begin(), cc_mod.end()); return _erase(rr_mod, cc_mod, false, mapping); } mapping.resize(0); if (numel()==0) return shared_from_this<Sparsity>(); mapping.reserve(nnz()); vector<casadi_int> ret_colind = get_colind(), ret_row = get_row(); casadi_int nz=0; vector<casadi_int>::const_iterator ie = cc.begin(); casadi_int el_first=0, el_last=0; for (casadi_int i=0; i<size2(); ++i) { el_first = el_last; el_last = ret_colind[i+1]; bool deletable_col = ie!=cc.end() && *ie==i; if (deletable_col) { ie++; vector<casadi_int>::const_iterator je = rr.begin(); for (casadi_int el=el_first; el<el_last; ++el) { casadi_int j=ret_row[el]; for (; je!=rr.end() && *je<j; ++je) {} if (je!=rr.end() && *je==j) { je++; continue; } mapping.push_back(el); ret_row[nz++] = j; } } else { for (casadi_int el=el_first; el<el_last; ++el) { casadi_int j=ret_row[el]; mapping.push_back(el); ret_row[nz++] = j; } } ret_colind[i+1]=nz; } ret_row.resize(nz); return Sparsity(size1(), size2(), ret_colind, ret_row); } vector<casadi_int> SparsityInternal::get_nz(const vector<casadi_int>& rr, const vector<casadi_int>& cc) const { casadi_assert_bounded(rr, size1()); casadi_assert_bounded(cc, size2()); std::vector<casadi_int> rr_sorted; std::vector<casadi_int> rr_sorted_index; sort(rr, rr_sorted, rr_sorted_index); vector<casadi_int> ret(cc.size()*rr.size()); casadi_int stride = rr.size(); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); for (casadi_int i=0;i<cc.size();++i) { casadi_int it = cc[i]; casadi_int el=colind[it]; for (casadi_int j=0;j<rr_sorted.size();++j) { casadi_int jt=rr_sorted[j]; for (; el<colind[it+1] && row[el]<jt; ++el) {} if (el<colind[it+1] && row[el]== jt) { ret[i*stride+rr_sorted_index[j]] = el; } else { ret[i*stride+rr_sorted_index[j]] = -1; } } } return ret; } Sparsity SparsityInternal::sub(const vector<casadi_int>& rr, const SparsityInternal& sp, vector<casadi_int>& mapping, bool ind1) const { casadi_assert_dev(rr.size()==sp.nnz()); casadi_assert_in_range(rr, -numel()+ind1, numel()+ind1); if (ind1 || has_negative(rr)) { std::vector<casadi_int> rr_mod = rr; for (vector<casadi_int>::iterator i=rr_mod.begin(); i!=rr_mod.end(); ++i) { casadi_assert(!(ind1 && (*i)<=0), "Matlab is 1-based, but requested index " + str(*i) + ". " "Note that negative slices are disabled in the Matlab interface. " "Possibly you may want to use 'end'."); if (ind1) (*i)--; if (*i<0) *i += numel(); } return sub(rr_mod, sp, mapping, false); } mapping.resize(rr.size()); std::copy(rr.begin(), rr.end(), mapping.begin()); get_nz(mapping); vector<casadi_int> ret_colind(sp.size2()+1), ret_row; ret_colind[0] = 0; const casadi_int* sp_colind = sp.colind(); const casadi_int* sp_row = sp.row(); for (casadi_int c=0; c<sp.size2(); ++c) { for (casadi_int el=sp_colind[c]; el<sp_colind[c+1]; ++el) { if (mapping[el]>=0) { mapping[ret_row.size()] = mapping[el]; ret_row.push_back(sp_row[el]); } } ret_colind[c+1] = ret_row.size(); } mapping.resize(ret_row.size()); return Sparsity(sp.size1(), sp.size2(), ret_colind, ret_row); } Sparsity SparsityInternal::sub(const vector<casadi_int>& rr, const vector<casadi_int>& cc, vector<casadi_int>& mapping, bool ind1) const { casadi_assert_in_range(rr, -size1()+ind1, size1()+ind1); casadi_assert_in_range(cc, -size2()+ind1, size2()+ind1); std::vector<casadi_int> tmp = rr; for (vector<casadi_int>::iterator i=tmp.begin(); i!=tmp.end(); ++i) { if (ind1) (*i)--; if (*i<0) *i += size1(); } std::vector<casadi_int> rr_sorted, rr_sorted_index; sort(tmp, rr_sorted, rr_sorted_index, false); tmp = cc; for (vector<casadi_int>::iterator i=tmp.begin(); i!=tmp.end(); ++i) { if (ind1) (*i)--; if (*i<0) *i += size2(); } std::vector<casadi_int> cc_sorted, cc_sorted_index; sort(tmp, cc_sorted, cc_sorted_index, false); vector<casadi_int> columns, rows; bool with_lookup = static_cast<double>(cc.size())*static_cast<double>(rr.size()) > nnz(); std::vector<casadi_int> rrlookup; if (with_lookup) { rrlookup = lookupvector(rr_sorted, size1()); } casadi_int nnz = 0; const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); for (casadi_int i=0; i<cc.size(); ++i) { casadi_int it = cc_sorted[i]; if (with_lookup) { for (casadi_int el=colind[it]; el<colind[it+1]; ++el) { casadi_int j = row[el]; casadi_int ji = rrlookup[j]; if (ji!=-1) { casadi_int jv = rr_sorted[ji]; while (ji>=0 && jv == rr_sorted[ji--]) nnz++; } } } else { casadi_int el = colind[it]; for (casadi_int j=0; j<rr_sorted.size(); ++j) { casadi_int jt=rr_sorted[j]; while (el<colind[it+1] && row[el]<jt) el++; if (el<colind[it+1] && row[el]== jt) nnz++; } } } mapping.resize(nnz); columns.resize(nnz); rows.resize(nnz); casadi_int k = 0; for (casadi_int i=0; i<cc.size(); ++i) { casadi_int it = cc_sorted[i]; if (with_lookup) { for (casadi_int el=colind[it]; el<colind[it+1]; ++el) { casadi_int jt = row[el]; casadi_int ji = rrlookup[jt]; if (ji!=-1) { casadi_int jv = rr_sorted[ji]; while (ji>=0 && jv == rr_sorted[ji]) { rows[k] = rr_sorted_index[ji]; columns[k] = cc_sorted_index[i]; mapping[k] = el; k++; ji--; } } } } else { casadi_int el = colind[it]; for (casadi_int j=0; j<rr_sorted.size(); ++j) { casadi_int jt=rr_sorted[j]; while (el<colind[it+1] && row[el]<jt) el++; if (el<colind[it+1] && row[el]== jt) { rows[k] = rr_sorted_index[j]; columns[k] = cc_sorted_index[i]; mapping[k] = el; k++; } } } } std::vector<casadi_int> sp_mapping; std::vector<casadi_int> mapping_ = mapping; Sparsity ret = Sparsity::triplet(rr.size(), cc.size(), rows, columns, sp_mapping, false); for (casadi_int i=0; i<mapping.size(); ++i) mapping[i] = mapping_[sp_mapping[i]]; return ret; } Sparsity SparsityInternal::combine(const Sparsity& y, bool f0x_is_zero, bool function0_is_zero) const { static vector<unsigned char> mapping; return combineGen1<false>(y, f0x_is_zero, function0_is_zero, mapping); } Sparsity SparsityInternal::combine(const Sparsity& y, bool f0x_is_zero, bool function0_is_zero, vector<unsigned char>& mapping) const { return combineGen1<true>(y, f0x_is_zero, function0_is_zero, mapping); } template<bool with_mapping> Sparsity SparsityInternal::combineGen1(const Sparsity& y, bool f0x_is_zero, bool function0_is_zero, std::vector<unsigned char>& mapping) const { if (is_equal(y)) { if (with_mapping) { mapping.resize(y.nnz()); fill(mapping.begin(), mapping.end(), 1 | 2); } return y; } if (f0x_is_zero) { if (function0_is_zero) { return combineGen<with_mapping, true, true>(y, mapping); } else { return combineGen<with_mapping, true, false>(y, mapping); } } else if (function0_is_zero) { return combineGen<with_mapping, false, true>(y, mapping); } else { return combineGen<with_mapping, false, false>(y, mapping); } } template<bool with_mapping, bool f0x_is_zero, bool function0_is_zero> Sparsity SparsityInternal::combineGen(const Sparsity& y, vector<unsigned char>& mapping) const { casadi_assert(size2()==y.size2() && size1()==y.size1(), "Dimension mismatch"); const casadi_int* y_colind = y.colind(); const casadi_int* y_row = y.row(); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); vector<casadi_int> ret_colind(size2()+1, 0); vector<casadi_int> ret_row; if (with_mapping) mapping.clear(); for (casadi_int i=0; i<size2(); ++i) { casadi_int el1 = colind[i]; casadi_int el2 = y_colind[i]; casadi_int el1_last = colind[i+1]; casadi_int el2_last = y_colind[i+1]; while (el1<el1_last || el2<el2_last) { casadi_int row1 = el1<el1_last ? row[el1] : size1(); casadi_int row2 = el2<el2_last ? y_row[el2] : size1(); if (row1==row2) { ret_row.push_back(row1); if (with_mapping) mapping.push_back( 1 | 2); el1++; el2++; } else if (row1<row2) { if (!function0_is_zero) { ret_row.push_back(row1); if (with_mapping) mapping.push_back(1); } else { if (with_mapping) mapping.push_back(1 | 4); } el1++; } else { if (!f0x_is_zero) { ret_row.push_back(row2); if (with_mapping) mapping.push_back(2); } else { if (with_mapping) mapping.push_back(2 | 4); } el2++; } } ret_colind[i+1] = ret_row.size(); } return Sparsity(size1(), size2(), ret_colind, ret_row); } bool SparsityInternal::is_equal(const Sparsity& y) const { if (this == y.get()) return true; return is_equal(y.size1(), y.size2(), y.colind(), y.row()); } Sparsity SparsityInternal::pattern_inverse() const { if (is_empty()) return Sparsity::dense(size1(), size2()); if (is_dense()) return Sparsity(size1(), size2()); std::vector<casadi_int> row_ret; std::vector<casadi_int> colind_ret=get_colind(); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); for (casadi_int i=0;i<size2();++i) { colind_ret[i+1]=colind_ret[i]+size1()-(colind[i+1]-colind[i]); casadi_int j=0; for (casadi_int k=colind[i];k<colind[i+1];++k) { while (j<row[k]) { row_ret.push_back(j); j++; } j++; } while (j < size1()) { row_ret.push_back(j); j++; } } return Sparsity(size1(), size2(), colind_ret, row_ret); } bool SparsityInternal::is_equal(casadi_int y_nrow, casadi_int y_ncol, const std::vector<casadi_int>& y_colind, const std::vector<casadi_int>& y_row) const { casadi_assert_dev(y_colind.size()==y_ncol+1); casadi_assert_dev(y_row.size()==y_colind.back()); return is_equal(y_nrow, y_ncol, get_ptr(y_colind), get_ptr(y_row)); } bool SparsityInternal::is_equal(casadi_int y_nrow, casadi_int y_ncol, const casadi_int* y_colind, const casadi_int* y_row) const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); casadi_int nz = y_colind[y_ncol]; if (nnz()!=nz || size2()!=y_ncol || size1()!=y_nrow) return false; if (nnz()==numel()) return true; if (!equal(colind, colind+size2()+1, y_colind)) return false; if (!equal(row, row+nz, y_row)) return false; return true; } Sparsity SparsityInternal::_appendVector(const SparsityInternal& sp) const { casadi_assert(size2() == 1 && sp.size2() == 1, "_appendVector(sp): Both arguments must be vectors but got " + str(size2()) + " columns for lhs, and " + str(sp.size2()) + " columns for rhs."); casadi_int sz = nnz(); vector<casadi_int> new_row = get_row(); const casadi_int* sp_row = sp.row(); new_row.resize(sz + sp.nnz()); for (casadi_int i=sz; i<new_row.size(); ++i) new_row[i] = sp_row[i-sz] + size1(); vector<casadi_int> new_colind(2, 0); new_colind[1] = new_row.size(); return Sparsity(size1()+sp.size1(), 1, new_colind, new_row); } Sparsity SparsityInternal::_appendColumns(const SparsityInternal& sp) const { casadi_assert(size1()== sp.size1(), "_appendColumns(sp): row sizes must match but got " + str(size1()) + " for lhs, and " + str(sp.size1()) + " for rhs."); vector<casadi_int> new_row = get_row(); const casadi_int* sp_row = sp.row(); new_row.insert(new_row.end(), sp_row, sp_row+sp.nnz()); vector<casadi_int> new_colind = get_colind(); const casadi_int* sp_colind = sp.colind(); new_colind.resize(size2() + sp.size2() + 1); for (casadi_int i = size2()+1; i<new_colind.size(); ++i) new_colind[i] = sp_colind[i-size2()] + nnz(); return Sparsity(size1(), size2()+sp.size2(), new_colind, new_row); } Sparsity SparsityInternal::_enlargeColumns(casadi_int ncol, const std::vector<casadi_int>& cc, bool ind1) const { casadi_assert_in_range(cc, -ncol+ind1, ncol+ind1); if (ind1 || has_negative(cc)) { std::vector<casadi_int> cc_mod = cc; for (vector<casadi_int>::iterator i=cc_mod.begin(); i!=cc_mod.end(); ++i) { if (ind1) (*i)--; if (*i<0) *i += ncol; } return _enlargeColumns(ncol, cc_mod, false); } vector<casadi_int> new_colind = get_colind(); new_colind.resize(ncol+1, nnz()); casadi_int ik=cc.back(); casadi_int nz=nnz(); for (casadi_int i=cc.size()-1; i>=0; --i) { for (; ik>cc[i]; --ik) { new_colind[ik] = nz; } nz = new_colind[i]; new_colind[cc[i]] = nz; } for (; ik>=0; --ik) { new_colind[ik] = 0; } return Sparsity(size1(), ncol, new_colind, get_row()); } Sparsity SparsityInternal::_enlargeRows(casadi_int nrow, const std::vector<casadi_int>& rr, bool ind1) const { casadi_assert_in_range(rr, -nrow+ind1, nrow+ind1); if (ind1 || has_negative(rr)) { std::vector<casadi_int> rr_mod = rr; for (vector<casadi_int>::iterator i=rr_mod.begin(); i!=rr_mod.end(); ++i) { if (ind1) (*i)--; if (*i<0) *i += nrow; } return _enlargeRows(nrow, rr_mod, false); } casadi_assert_dev(rr.size() == size1()); vector<casadi_int> new_row = get_row(); for (casadi_int k=0; k<nnz(); ++k) { new_row[k] = rr[new_row[k]]; } return Sparsity(nrow, size2(), get_colind(), new_row); } Sparsity SparsityInternal::makeDense(std::vector<casadi_int>& mapping) const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); mapping.resize(nnz()); for (casadi_int i=0; i<size2(); ++i) { for (casadi_int el=colind[i]; el<colind[i+1]; ++el) { casadi_int j = row[el]; mapping[el] = j + i*size1(); } } return Sparsity::dense(size1(), size2()); } casadi_int SparsityInternal::get_nz(casadi_int rr, casadi_int cc) const { if (rr<0) rr += size1(); if (cc<0) cc += size2(); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); casadi_assert(rr>=0 && rr<size1(), "Row index " + str(rr) + " out of bounds [0, " + str(size1()) + ")"); casadi_assert(cc>=0 && cc<size2(), "Column index " + str(cc) + " out of bounds [0, " + str(size2()) + ")"); if (is_dense()) return rr+cc*size1(); if (colind[cc]==nnz() || (colind[cc+1]==nnz() && row[nnz()-1]<rr)) return -1; for (casadi_int ind=colind[cc]; ind<colind[cc+1]; ++ind) { if (row[ind] == rr) { return ind; } else if (row[ind] > rr) { break; } } return -1; } Sparsity SparsityInternal::_reshape(casadi_int nrow, casadi_int ncol) const { if (nrow<0 && ncol>0) { return _reshape(numel()/ncol, ncol); } else if (nrow>0 && ncol<0) { return _reshape(nrow, numel()/nrow); } casadi_assert(numel() == nrow*ncol, "reshape: number of elements must remain the same. Old shape is " + dim() + ". New shape is " + str(nrow) + "x" + str(ncol) + "=" + str(nrow*ncol) + "."); std::vector<casadi_int> ret_col(nnz()); std::vector<casadi_int> ret_row(nnz()); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); for (casadi_int i=0; i<size2(); ++i) { for (casadi_int el=colind[i]; el<colind[i+1]; ++el) { casadi_int j = row[el]; casadi_int k_ret = j+i*size1(); casadi_int i_ret = k_ret/nrow; casadi_int j_ret = k_ret%nrow; ret_col[el] = i_ret; ret_row[el] = j_ret; } } return Sparsity::triplet(nrow, ncol, ret_row, ret_col); } Sparsity SparsityInternal::_resize(casadi_int nrow, casadi_int ncol) const { vector<casadi_int> row_new, colind_new(ncol+1, 0); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); casadi_int i; for (i=0; i<size2() && i<ncol; ++i) { colind_new[i] = row_new.size(); for (casadi_int el=colind[i]; el<colind[i+1] && row[el]<nrow; ++el) { row_new.push_back(row[el]); } } for (; i<ncol+1; ++i) { colind_new[i] = row_new.size(); } return Sparsity(nrow, ncol, colind_new, row_new); } bool SparsityInternal::rowsSequential(bool strictly) const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); for (casadi_int i=0; i<size2(); ++i) { casadi_int lastrow = -1; for (casadi_int k=colind[i]; k<colind[i+1]; ++k) { if (row[k] < lastrow) return false; if (strictly && row[k] == lastrow) return false; lastrow = row[k]; } } return true; } Sparsity SparsityInternal::_removeDuplicates(std::vector<casadi_int>& mapping) const { casadi_assert_dev(mapping.size()==nnz()); vector<casadi_int> ret_colind = get_colind(), ret_row = get_row(); casadi_int k_strict=0; for (casadi_int i=0; i<size2(); ++i) { casadi_int lastrow = -1; casadi_int new_colind = k_strict; for (casadi_int k=ret_colind[i]; k<ret_colind[i+1]; ++k) { casadi_assert(ret_row[k] >= lastrow, "rows are not sequential"); if (ret_row[k] == lastrow) continue; lastrow = ret_row[k]; mapping[k_strict] = mapping[k]; ret_row[k_strict] = ret_row[k]; k_strict++; } ret_colind[i] = new_colind; } ret_colind[size2()] = k_strict; ret_row.resize(k_strict); mapping.resize(k_strict); return Sparsity(size1(), size2(), ret_colind, ret_row); } void SparsityInternal::find(std::vector<casadi_int>& loc, bool ind1) const { casadi_assert(!mul_overflows(size1(), size2()), "Integer overflow detected"); if (is_dense()) { loc = range(ind1, numel()+ind1); return; } const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); loc.resize(nnz()); for (casadi_int cc=0; cc<size2(); ++cc) { for (casadi_int el=colind[cc]; el<colind[cc+1]; ++el) { casadi_int rr = row[el]; loc[el] = rr+cc*size1()+ind1; } } } void SparsityInternal::get_nz(std::vector<casadi_int>& indices) const { if (indices.empty()) return; if (is_dense()) return; const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); casadi_int last=-1; for (vector<casadi_int>::iterator it=indices.begin(); it!=indices.end(); ++it) { if (*it>=0) { casadi_int el = *it; if (el<last) { std::vector<casadi_int> indices_sorted, mapping; sort(indices, indices_sorted, mapping, false); get_nz(indices_sorted); for (size_t i=0; i<indices.size(); ++i) { indices[mapping[i]] = indices_sorted[i]; } return; } last = el; } } if (last<0) return; vector<casadi_int>::iterator it=indices.begin(); while (*it<0) it++; casadi_int el_row = *it % size1(); casadi_int el_col = *it / size1(); for (casadi_int i=0; i<size2(); ++i) { for (casadi_int el=colind[i]; el<colind[i+1] && el_col<=i; ++el) { casadi_int j = row[el]; while (i>el_col || (i==el_col && j>el_row)) { *it = -1; if (++it==indices.end()) return; el_row = *it % size1(); el_col = *it / size1(); } while (i==el_col && j==el_row) { *it = el; do { if (++it==indices.end()) return; } while (*it<0); el_row = *it % size1(); el_col = *it / size1(); } } } fill(it, indices.end(), -1); } Sparsity SparsityInternal::uni_coloring(const Sparsity& AT, casadi_int cutoff) const { vector<casadi_int> forbiddenColors; forbiddenColors.reserve(size2()); vector<casadi_int> color(size2(), 0); const casadi_int* AT_colind = AT.colind(); const casadi_int* AT_row = AT.row(); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); for (casadi_int i=0; i<size2(); ++i) { for (casadi_int el=colind[i]; el<colind[i+1]; ++el) { casadi_int c = row[el]; for (casadi_int el_prev=AT_colind[c]; el_prev<AT_colind[c+1]; ++el_prev) { casadi_int i_prev = AT_row[el_prev]; if (i_prev>=i) break; casadi_int color_prev = color[i_prev]; forbiddenColors[color_prev] = i; } } casadi_int color_i; for (color_i=0; color_i<forbiddenColors.size(); ++color_i) { if (forbiddenColors[color_i]!=i) break; } color[i] = color_i; if (color_i==forbiddenColors.size()) { forbiddenColors.push_back(0); if (forbiddenColors.size()>cutoff) { return Sparsity(); } } } vector<casadi_int> ret_colind(forbiddenColors.size()+1, 0), ret_row; for (casadi_int i=0; i<color.size(); ++i) { ret_colind[color[i]+1]++; } for (casadi_int j=0; j<forbiddenColors.size(); ++j) { ret_colind[j+1] += ret_colind[j]; } ret_row.resize(color.size()); for (casadi_int j=0; j<ret_row.size(); ++j) { ret_row[ret_colind[color[j]]++] = j; } for (casadi_int j=ret_colind.size()-2; j>=0; --j) { ret_colind[j+1] = ret_colind[j]; } ret_colind[0] = 0; return Sparsity(size2(), forbiddenColors.size(), ret_colind, ret_row); ; } Sparsity SparsityInternal::star_coloring2(casadi_int ordering, casadi_int cutoff) const { if (!is_square()) { casadi_message("StarColoring requires a square matrix, got " + dim() + "."); } const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); if (ordering!=0) { casadi_assert_dev(ordering==1); vector<casadi_int> ord = largest_first(); Sparsity sp_permuted = pmult(ord, true, true, true); Sparsity ret_permuted = sp_permuted.star_coloring2(0); return ret_permuted.pmult(ord, true, false, false); } vector<casadi_int> forbiddenColors; forbiddenColors.reserve(size2()); vector<casadi_int> color(size2(), -1); vector<casadi_int> firstNeighborP(size2(), -1); vector<casadi_int> firstNeighborQ(size2(), -1); vector<casadi_int> firstNeighborQ_el(size2(), -1); vector<casadi_int> treated(size2(), -1); vector<casadi_int> hub(nnz_upper(), -1); vector<casadi_int> Tmapping; transpose(Tmapping); vector<casadi_int> star(nnz()); casadi_int k = 0; for (casadi_int i=0; i<size2(); ++i) { for (casadi_int j_el=colind[i]; j_el<colind[i+1]; ++j_el) { casadi_int j = row[j_el]; if (i<j) { star[j_el] = k; star[Tmapping[j]] = k; k++; } } } casadi_int starID = 0; for (casadi_int v=0; v<size2(); ++v) { for (casadi_int w_el=colind[v]; w_el<colind[v+1]; ++w_el) { casadi_int w = row[w_el]; casadi_int colorW = color[w]; if (colorW==-1) continue; forbiddenColors[colorW] = v; casadi_int p = firstNeighborP[colorW]; casadi_int q = firstNeighborQ[colorW]; if (v==p) { if (treated[q]!=v) { for (casadi_int x_el=colind[q]; x_el<colind[q+1]; ++x_el) { casadi_int x = row[x_el]; if (color[x]==-1) continue; forbiddenColors[color[x]] = v; } treated[q] = v; } for (casadi_int x_el=colind[w]; x_el<colind[w+1]; ++x_el) { casadi_int x = row[x_el]; if (color[x]==-1) continue; forbiddenColors[color[x]] = v; } treated[w] = v; } else { firstNeighborP[colorW] = v; firstNeighborQ[colorW] = w; firstNeighborQ_el[colorW] = w_el; casadi_int x_el_end = colind[w+1]; casadi_int x, colorx; for (casadi_int x_el=colind[w]; x_el < x_el_end; ++x_el) { x = row[x_el]; colorx = color[x]; if (colorx==-1 || x==v) continue; if (hub[star[x_el]]==x) { forbiddenColors[colorx] = v; } } } } bool new_color = true; for (casadi_int color_i=0; color_i<forbiddenColors.size(); ++color_i) { if (forbiddenColors[color_i]!=v) { color[v] = color_i; new_color = false; break; } } if (new_color) { color[v] = forbiddenColors.size(); forbiddenColors.push_back(-1); if (forbiddenColors.size()>cutoff) { return Sparsity(); } } for (casadi_int w_el=colind[v]; w_el<colind[v+1]; ++w_el) { casadi_int w = row[w_el]; casadi_int colorW = color[w]; if (colorW==-1) continue; bool check = false; casadi_int x; casadi_int x_el; for (x_el=colind[w]; x_el<colind[w+1]; ++x_el) { x = row[x_el]; if (x==v || color[x]!=color[v]) continue; check = true; break; } if (check) { casadi_int starwx = star[x_el]; hub[starwx] = w; star[w_el] = starwx; star[Tmapping[w_el]] = starwx; } else { casadi_int p = firstNeighborP[colorW]; casadi_int q = firstNeighborQ[colorW]; casadi_int q_el = firstNeighborQ_el[colorW]; if (p==v && q!=w) { casadi_int starvq = star[q_el]; hub[starvq] = v; star[w_el] = starvq; star[Tmapping[w_el]] = starvq; } else { starID+= 1; star[w_el] = starID; star[Tmapping[w_el]]= starID; } } } } vector<casadi_int> ret_colind(forbiddenColors.size()+1, 0), ret_row; for (casadi_int i=0; i<color.size(); ++i) { ret_colind[color[i]+1]++; } for (casadi_int j=0; j<forbiddenColors.size(); ++j) { ret_colind[j+1] += ret_colind[j]; } ret_row.resize(color.size()); for (casadi_int j=0; j<ret_row.size(); ++j) { ret_row[ret_colind[color[j]]++] = j; } for (casadi_int j=ret_colind.size()-2; j>=0; --j) { ret_colind[j+1] = ret_colind[j]; } ret_colind[0] = 0; return Sparsity(size2(), forbiddenColors.size(), ret_colind, ret_row); } Sparsity SparsityInternal::star_coloring(casadi_int ordering, casadi_int cutoff) const { if (!is_square()) { casadi_message("StarColoring requires a square matrix, got " + dim() + "."); } if (ordering!=0) { casadi_assert_dev(ordering==1); vector<casadi_int> ord = largest_first(); Sparsity sp_permuted = pmult(ord, true, true, true); Sparsity ret_permuted = sp_permuted.star_coloring(0); return ret_permuted.pmult(ord, true, false, false); } const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); vector<casadi_int> forbiddenColors; forbiddenColors.reserve(size2()); vector<casadi_int> color(size2(), -1); for (casadi_int i=0; i<size2(); ++i) { for (casadi_int w_el=colind[i]; w_el<colind[i+1]; ++w_el) { casadi_int w = row[w_el]; if (color[w]!=-1) { forbiddenColors[color[w]] = i; } for (casadi_int x_el=colind[w]; x_el<colind[w+1]; ++x_el) { casadi_int x = row[x_el]; if (color[x]==-1) continue; if (color[w]==-1) { forbiddenColors[color[x]] = i; } else { for (casadi_int y_el=colind[x]; y_el<colind[x+1]; ++y_el) { casadi_int y = row[y_el]; if (color[y]==-1 || y==w) continue; if (color[y]==color[w]) { forbiddenColors[color[x]] = i; break; } } } } } bool new_color = true; for (casadi_int color_i=0; color_i<forbiddenColors.size(); ++color_i) { if (forbiddenColors[color_i]!=i) { color[i] = color_i; new_color = false; break; } } if (new_color) { color[i] = forbiddenColors.size(); forbiddenColors.push_back(-1); if (forbiddenColors.size()>cutoff) { return Sparsity(); } } } casadi_int num_colors = forbiddenColors.size(); return Sparsity::triplet(size2(), num_colors, range(color.size()), color); } std::vector<casadi_int> SparsityInternal::largest_first() const { vector<casadi_int> degree = get_colind(); casadi_int max_degree = 0; for (casadi_int k=0; k<size2(); ++k) { degree[k] = degree[k+1]-degree[k]; max_degree = max(max_degree, 1+degree[k]); } degree.resize(size2()); vector<casadi_int> degree_count(max_degree+1, 0); for (vector<casadi_int>::const_iterator it=degree.begin(); it!=degree.end(); ++it) { degree_count.at(*it+1)++; } for (casadi_int d=0; d<max_degree; ++d) { degree_count[d+1] += degree_count[d]; } vector<casadi_int> ordering(size2()); for (casadi_int k=size2()-1; k>=0; --k) { ordering[degree_count[degree[k]]++] = k; } vector<casadi_int>& reverse_ordering = degree_count; reverse_ordering.resize(ordering.size()); copy(ordering.begin(), ordering.end(), reverse_ordering.rbegin()); return reverse_ordering; } Sparsity SparsityInternal::pmult(const std::vector<casadi_int>& p, bool permute_rows, bool permute_columns, bool invert_permutation) const { vector<casadi_int> p_inv; if (invert_permutation) { p_inv.resize(p.size()); for (casadi_int k=0; k<p.size(); ++k) { p_inv[p[k]] = k; } } const vector<casadi_int>& pp = invert_permutation ? p_inv : p; vector<casadi_int> col = get_col(); const casadi_int* row = this->row(); vector<casadi_int> new_row(col.size()), new_col(col.size()); if (permute_columns) { casadi_assert_dev(p.size()==size2()); for (casadi_int k=0; k<col.size(); ++k) { new_col[k] = pp[col[k]]; } } else { copy(col.begin(), col.end(), new_col.begin()); } if (permute_rows) { casadi_assert_dev(p.size()==size1()); for (casadi_int k=0; k<nnz(); ++k) { new_row[k] = pp[row[k]]; } } else { copy(row, row+nnz(), new_row.begin()); } return Sparsity::triplet(size1(), size2(), new_row, new_col); } bool SparsityInternal::is_transpose(const SparsityInternal& y) const { if (size2()!=y.size1() || size1()!=y.size2() || nnz()!=y.nnz()) return false; if (nnz()==0 || is_dense()) return true; if (size1()>size2()) return y.is_transpose(*this); vector<casadi_int> y_col_count(y.size2(), 0); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); const casadi_int* y_colind = y.colind(); const casadi_int* y_row = y.row(); for (casadi_int i=0; i<size2(); ++i) { for (casadi_int el=colind[i]; el<colind[i+1]; ++el) { casadi_int j=row[el]; casadi_int el_y = y_colind[j] + y_col_count[j]++; if (el_y>=y_colind[j+1]) return false; casadi_int j_y = y_row[el_y]; if (j_y != i) return false; } } return true; } bool SparsityInternal::is_reshape(const SparsityInternal& y) const { if (this==&y) return true; if (numel()!=y.numel() || nnz()!=y.nnz()) return false; if (nnz()==0 || is_dense()) return true; const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); const casadi_int* y_colind = y.colind(); const casadi_int* y_row = y.row(); if (size1()==y.size1()) return is_equal(y.size1(), y.size2(), y_colind, y_row); for (casadi_int cc=0; cc<size2(); ++cc) { for (casadi_int el=colind[cc]; el<colind[cc+1]; ++el) { casadi_int rr=row[el]; casadi_int loc = rr+size1()*cc; casadi_int rr_y = loc % y.size1(); casadi_int cc_y = loc / y.size1(); if (rr_y != y_row[el] || el<y_colind[cc_y] || el>=y_colind[cc_y+1]) return false; } } return true; } void SparsityInternal::spy(std::ostream &stream) const { std::vector<casadi_int> cind = get_colind(); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); for (casadi_int rr=0; rr<size1(); ++rr) { for (casadi_int cc=0; cc<size2(); ++cc) { if (cind[cc]<colind[cc+1] && row[cind[cc]]==rr) { stream << "*"; cind[cc]++; } else { stream << "."; } } stream << endl; } } void SparsityInternal::export_code(const std::string& lang, std::ostream &stream, const Dict& options) const { casadi_assert(lang=="matlab", "Only matlab language supported for now."); bool opt_inline = false; std::string name = "sp"; bool as_matrix = true; casadi_int indent_level = 0; for (auto&& op : options) { if (op.first=="inline") { opt_inline = op.second; } else if (op.first=="name") { name = op.second.to_string(); } else if (op.first=="as_matrix") { as_matrix = op.second; } else if (op.first=="indent_level") { indent_level = op.second; } else { casadi_error("Unknown option '" + op.first + "'."); } } std::string indent = ""; for (casadi_int i=0;i<indent_level;++i) { indent += " "; } casadi_assert(!opt_inline, "Inline not supported for now."); stream << indent << name << "_m = " << size1() << ";" << endl; stream << indent << name << "_n = " << size2() << ";" << endl; const casadi_int index_offset = 1; const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); stream << indent << name<< "_j = ["; bool first = true; for (casadi_int i=0; i<size2(); ++i) { for (casadi_int el=colind[i]; el<colind[i+1]; ++el) { if (!first) stream << ", "; stream << (i+index_offset); first = false; } } stream << "];" << endl; stream << indent << name << "_i = ["; first = true; casadi_int nz = nnz(); for (casadi_int i=0; i<nz; ++i) { if (!first) stream << ", "; stream << (row[i]+index_offset); first = false; } stream << "];" << endl; if (as_matrix) { stream << indent << name << " = sparse(" << name << "_i, " << name << "_j, "; stream << "ones(size(" << name << "_i)), "; stream << name << "_m, " << name << "_n);" << endl; } } void SparsityInternal::spy_matlab(const std::string& mfile_name) const { ofstream mfile; mfile.open(mfile_name.c_str()); mfile << "% This function was automatically generated by CasADi" << endl; Dict opts; opts["name"] = "A"; export_code("matlab", mfile, opts); mfile << "spy(A);" << endl; mfile.close(); } std::size_t SparsityInternal::hash() const { return hash_sparsity(size1(), size2(), colind(), row()); } bool SparsityInternal::is_tril() const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); for (casadi_int i=0; i<size2(); ++i) { if (colind[i] != colind[i+1]) { casadi_int rr = row[colind[i]]; if (rr<i) return false; } } return true; } bool SparsityInternal::is_triu() const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); for (casadi_int i=0; i<size2(); ++i) { if (colind[i] != colind[i+1]) { casadi_int rr = row[colind[i+1]-1]; if (rr>i) return false; } } return true; } Sparsity SparsityInternal::_tril(bool includeDiagonal) const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); vector<casadi_int> ret_colind, ret_row; ret_colind.reserve(size2()+1); ret_colind.push_back(0); for (casadi_int cc=0; cc<size2(); ++cc) { for (casadi_int el=colind[cc]; el<colind[cc+1]; ++el) { casadi_int rr=row[el]; if (rr>cc || (includeDiagonal && rr==cc)) { ret_row.push_back(rr); } } ret_colind.push_back(ret_row.size()); } return Sparsity(size1(), size2(), ret_colind, ret_row); } Sparsity SparsityInternal::_triu(bool includeDiagonal) const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); vector<casadi_int> ret_colind, ret_row; ret_colind.reserve(size2()+1); ret_colind.push_back(0); for (casadi_int cc=0; cc<size2(); ++cc) { for (casadi_int el=colind[cc]; el<colind[cc+1]; ++el) { casadi_int rr=row[el]; if (rr<cc || (includeDiagonal && rr==cc)) { ret_row.push_back(rr); } } ret_colind.push_back(ret_row.size()); } return Sparsity(size1(), size2(), ret_colind, ret_row); } std::vector<casadi_int> SparsityInternal::get_lower() const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); vector<casadi_int> ret; for (casadi_int cc=0; cc<size2(); ++cc) { for (casadi_int el = colind[cc]; el<colind[cc+1]; ++el) { if (row[el]>=cc) { ret.push_back(el); } } } return ret; } std::vector<casadi_int> SparsityInternal::get_upper() const { const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); vector<casadi_int> ret; for (casadi_int cc=0; cc<size2(); ++cc) { for (casadi_int el = colind[cc]; el<colind[cc+1] && row[el]<=cc; ++el) { ret.push_back(el); } } return ret; } casadi_int SparsityInternal::bw_upper() const { casadi_int bw = 0; const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); for (casadi_int cc=0; cc<size2(); ++cc) { if (colind[cc] != colind[cc+1]) { casadi_int rr = row[colind[cc]]; bw = std::max(bw, cc-rr); } } return bw; } casadi_int SparsityInternal::bw_lower() const { casadi_int bw = 0; const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); for (casadi_int cc=0; cc<size2(); ++cc) { if (colind[cc] != colind[cc+1]) { casadi_int rr = row[colind[cc+1]-1]; bw = std::max(bw, rr-cc); } } return bw; } vector<casadi_int> SparsityInternal::get_colind() const { const casadi_int* colind = this->colind(); return vector<casadi_int>(colind, colind+size2()+1); } vector<casadi_int> SparsityInternal::get_row() const { const casadi_int* row = this->row(); return vector<casadi_int>(row, row+nnz()); } void SparsityInternal:: spsolve(bvec_t* X, const bvec_t* B, bool tr) const { const Btf& btf = this->btf(); const casadi_int* colind = this->colind(); const casadi_int* row = this->row(); if (!tr) { for (casadi_int b=0; b<btf.nb; ++b) { bvec_t block_dep = 0; for (casadi_int el=btf.rowblock[b]; el<btf.rowblock[b+1]; ++el) { casadi_int rr = btf.rowperm[el]; block_dep |= B[rr]; } for (casadi_int el=btf.colblock[b]; el<btf.colblock[b+1]; ++el) { casadi_int cc = btf.colperm[el]; block_dep |= X[cc]; } for (casadi_int el=btf.colblock[b]; el<btf.colblock[b+1]; ++el) { casadi_int cc = btf.colperm[el]; X[cc] |= block_dep; for (casadi_int k=colind[cc]; k<colind[cc+1]; ++k) { casadi_int rr=row[k]; X[rr] |= block_dep; } } } } else { for (casadi_int b=btf.nb-1; b>=0; --b) { bvec_t block_dep = 0; for (casadi_int el=btf.colblock[b]; el<btf.colblock[b+1]; ++el) { casadi_int cc = btf.colperm[el]; block_dep |= B[cc]; for (casadi_int k=colind[cc]; k<colind[cc+1]; ++k) { casadi_int rr=row[k]; block_dep |= X[rr]; } } for (casadi_int el=btf.rowblock[b]; el<btf.rowblock[b+1]; ++el) { casadi_int rr = btf.rowperm[el]; X[rr] |= block_dep; } } } } }
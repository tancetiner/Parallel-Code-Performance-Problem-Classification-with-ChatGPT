#ifndef LIBMESH_CHECKPOINT_IO_H #define LIBMESH_CHECKPOINT_IO_H #include "libmesh/compare_elems_by_level.h" #include "libmesh/mesh_input.h" #include "libmesh/mesh_output.h" #include "libmesh/parallel_object.h" #include <string> #include <vector> namespace libMesh { class Xdr; class CheckpointIO; std::unique_ptr<CheckpointIO> split_mesh(MeshBase & mesh, processor_id_type nsplits); class CheckpointIO : public MeshInput<MeshBase>, public MeshOutput<MeshBase>, public ParallelObject { public: typedef largest_id_type xdr_id_type; typedef uint64_t header_id_type; explicit CheckpointIO (MeshBase &, const bool=false); explicit CheckpointIO (const MeshBase &, const bool=false); virtual ~CheckpointIO (); virtual void read (const std::string & input_name) override; virtual void write (const std::string & name) override; static void cleanup(const std::string & input_name, processor_id_type n_procs); bool binary() const { return _binary; } bool & binary() { return _binary; } bool parallel() const { return _parallel; } bool & parallel() { return _parallel; } const std::string & version () const { return _version; } std::string & version () { return _version; } const std::vector<processor_id_type> & current_processor_ids() const { return _my_processor_ids; } std::vector<processor_id_type> & current_processor_ids() { return _my_processor_ids; } const processor_id_type & current_n_processors() const { return _my_n_processors; } processor_id_type & current_n_processors() { return _my_n_processors; } private: void write_subdomain_names(Xdr & io) const; void write_connectivity (Xdr & io, const std::set<const Elem *, CompareElemIdsByLevel> & elements) const; void write_remote_elem (Xdr & io, const std::set<const Elem *, CompareElemIdsByLevel> & elements) const; void write_nodes (Xdr & io, const std::set<const Node *> & nodeset) const; void write_bcs (Xdr & io, const std::set<const Elem *, CompareElemIdsByLevel> & elements) const; void write_nodesets (Xdr & io, const std::set<const Node *> & nodeset) const; void write_bc_names (Xdr & io, const BoundaryInfo & info, bool is_sideset) const; template <typename file_id_type> file_id_type read_header(const std::string & name); template <typename file_id_type> void read_subfile(Xdr & io, bool expect_all_remote); template <typename file_id_type> void read_subdomain_names(Xdr & io); template <typename file_id_type> void read_connectivity (Xdr & io); template <typename file_id_type> void read_remote_elem (Xdr & io, bool expect_all_remote); template <typename file_id_type> void read_nodes (Xdr & io); template <typename file_id_type> void read_bcs (Xdr & io); template <typename file_id_type> void read_nodesets (Xdr & io); template <typename file_id_type> void read_bc_names(Xdr & io, BoundaryInfo & info, bool is_sideset); unsigned int n_active_levels_in(MeshBase::const_element_iterator begin, MeshBase::const_element_iterator end) const; processor_id_type select_split_config(const std::string & input_name, header_id_type & data_size); bool _binary; bool _parallel; std::string _version; std::vector<processor_id_type> _my_processor_ids; processor_id_type _my_n_processors; }; } #endif
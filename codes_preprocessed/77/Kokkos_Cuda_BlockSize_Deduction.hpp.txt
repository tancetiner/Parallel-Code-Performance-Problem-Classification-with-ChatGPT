#ifndef KOKKOS_CUDA_INTERNAL_HPP #define KOKKOS_CUDA_INTERNAL_HPP #include <Kokkos_Macros.hpp> #ifdef KOKKOS_ENABLE_CUDA #include <Cuda/Kokkos_Cuda_Error.hpp> namespace Kokkos { namespace Impl { inline int cuda_max_active_blocks_per_sm(cudaDeviceProp const& properties, cudaFuncAttributes const& attributes, int block_size, size_t dynamic_shmem) { int const regs_per_sm = properties.regsPerMultiprocessor; int const regs_per_thread = attributes.numRegs; int const max_blocks_regs = regs_per_sm / (regs_per_thread * block_size); size_t const shmem_per_sm = properties.sharedMemPerMultiprocessor; size_t const shmem_per_block = properties.sharedMemPerBlock; size_t const static_shmem = attributes.sharedSizeBytes; size_t const dynamic_shmem_per_block = attributes.maxDynamicSharedSizeBytes; size_t const total_shmem = static_shmem + dynamic_shmem; int const max_blocks_shmem = total_shmem > shmem_per_block || dynamic_shmem > dynamic_shmem_per_block ? 0 : (total_shmem > 0 ? (int)shmem_per_sm / total_shmem : max_blocks_regs); #if CUDA_VERSION >= 11000 int const max_blocks_per_sm = properties.maxBlocksPerMultiProcessor; #else int const max_blocks_per_sm = [&properties]() { switch (properties.major) { case 3: return 16; case 5: case 6: return 32; case 7: { int isTuring = properties.minor == 5; return (isTuring) ? 16 : 32; } default: throw_runtime_exception("Unknown device in cuda block size deduction"); return 0; } }(); #endif return std::min({max_blocks_regs, max_blocks_shmem, max_blocks_per_sm}); } template <typename UnaryFunction, typename LaunchBounds> inline int cuda_deduce_block_size(bool early_termination, cudaDeviceProp const& properties, cudaFuncAttributes const& attributes, UnaryFunction block_size_to_dynamic_shmem, LaunchBounds) { int const max_threads_per_sm = properties.maxThreadsPerMultiProcessor; int const max_threads_per_block = std::min(LaunchBounds::maxTperB == 0 ? (int)properties.maxThreadsPerBlock : (int)LaunchBounds::maxTperB, attributes.maxThreadsPerBlock); int const min_blocks_per_sm = LaunchBounds::minBperSM == 0 ? 1 : LaunchBounds::minBperSM; int opt_block_size = 0; int opt_threads_per_sm = 0; for (int block_size = max_threads_per_block; block_size > 0; block_size -= 32) { size_t const dynamic_shmem = block_size_to_dynamic_shmem(block_size); int blocks_per_sm = cuda_max_active_blocks_per_sm( properties, attributes, block_size, dynamic_shmem); int threads_per_sm = blocks_per_sm * block_size; if (threads_per_sm > max_threads_per_sm) { blocks_per_sm = max_threads_per_sm / block_size; threads_per_sm = blocks_per_sm * block_size; } if (blocks_per_sm >= min_blocks_per_sm) { if (threads_per_sm >= opt_threads_per_sm) { opt_block_size = block_size; opt_threads_per_sm = threads_per_sm; } } if (early_termination && opt_block_size != 0) break; } return opt_block_size; } template <class FunctorType, class LaunchBounds> int cuda_get_max_block_size(const CudaInternal* cuda_instance, const cudaFuncAttributes& attr, const FunctorType& f, const size_t vector_length, const size_t shmem_block, const size_t shmem_thread) { (void)cuda_instance; auto const& prop = Kokkos::Cuda().cuda_device_prop(); auto const block_size_to_dynamic_shmem = [&f, vector_length, shmem_block, shmem_thread](int block_size) { size_t const functor_shmem = Kokkos::Impl::FunctorTeamShmemSize<FunctorType>::value( f, block_size / vector_length); size_t const dynamic_shmem = shmem_block + shmem_thread * (block_size / vector_length) + functor_shmem; return dynamic_shmem; }; return cuda_deduce_block_size(true, prop, attr, block_size_to_dynamic_shmem, LaunchBounds{}); } template <class FunctorType, class LaunchBounds> int cuda_get_opt_block_size(const CudaInternal* cuda_instance, const cudaFuncAttributes& attr, const FunctorType& f, const size_t vector_length, const size_t shmem_block, const size_t shmem_thread) { (void)cuda_instance; auto const& prop = Kokkos::Cuda().cuda_device_prop(); auto const block_size_to_dynamic_shmem = [&f, vector_length, shmem_block, shmem_thread](int block_size) { size_t const functor_shmem = Kokkos::Impl::FunctorTeamShmemSize<FunctorType>::value( f, block_size / vector_length); size_t const dynamic_shmem = shmem_block + shmem_thread * (block_size / vector_length) + functor_shmem; return dynamic_shmem; }; return cuda_deduce_block_size(false, prop, attr, block_size_to_dynamic_shmem, LaunchBounds{}); } inline size_t get_shmem_per_sm_prefer_l1(cudaDeviceProp const& properties) { int const compute_capability = properties.major * 10 + properties.minor; return [compute_capability]() { switch (compute_capability) { case 30: case 32: case 35: return 16; case 37: return 80; case 50: case 53: case 60: case 62: return 64; case 52: case 61: return 96; case 70: case 80: case 86: return 8; case 75: return 32; default: Kokkos::Impl::throw_runtime_exception( "Unknown device in cuda block size deduction"); } return 0; }() * 1024; } } } #endif #endif
#ifndef CGAL_POLYGON_MESH_PROCESSING_DISTANCE_H #define CGAL_POLYGON_MESH_PROCESSING_DISTANCE_H #include <CGAL/license/Polygon_mesh_processing/distance.h> #include <CGAL/Polygon_mesh_processing/internal/mesh_to_point_set_hausdorff_distance.h> #include <CGAL/Polygon_mesh_processing/internal/AABB_traversal_traits_with_Hausdorff_distance.h> #include <CGAL/Polygon_mesh_processing/measure.h> #include <CGAL/Polygon_mesh_processing/bbox.h> #include <CGAL/AABB_tree.h> #include <CGAL/AABB_traits.h> #include <CGAL/AABB_triangle_primitive.h> #include <CGAL/AABB_face_graph_triangle_primitive.h> #include <CGAL/utility.h> #include <CGAL/Polygon_mesh_processing/internal/named_function_params.h> #include <CGAL/Polygon_mesh_processing/internal/named_params_helper.h> #include <CGAL/point_generators_3.h> #include <CGAL/Spatial_sort_traits_adapter_3.h> #include <CGAL/spatial_sort.h> #include <CGAL/Real_timer.h> #include <CGAL/boost/graph/Face_filtered_graph.h> #if defined(CGAL_METIS_ENABLED) #include <CGAL/boost/graph/partition.h> #endif #ifdef CGAL_LINKED_WITH_TBB #include <tbb/parallel_reduce.h> #include <tbb/blocked_range.h> #include <atomic> #endif #include <boost/unordered_set.hpp> #include <boost/any.hpp> #include <algorithm> #include <array> #include <cmath> #include <limits> namespace CGAL { namespace Polygon_mesh_processing { namespace internal { template <class Kernel, class PointOutputIterator> PointOutputIterator triangle_grid_sampling(const typename Kernel::Point_3& p0, const typename Kernel::Point_3& p1, const typename Kernel::Point_3& p2, double distance, PointOutputIterator out) { typename Kernel::Compute_squared_distance_3 squared_distance; const double d_p0p1 = to_double(approximate_sqrt( squared_distance(p0, p1) )); const double d_p0p2 = to_double(approximate_sqrt( squared_distance(p0, p2) )); const double n = (std::max)(std::ceil( d_p0p1 / distance ), std::ceil( d_p0p2 / distance )); for(double i=1; i<n; ++i) { for(double j=1; j<n-i; ++j) { const double c0=(1-(i+j)/n), c1=i/n, c2=j/n; *out++ = typename Kernel::Point_3(p0.x()*c0+p1.x()*c1+p2.x()*c2, p0.y()*c0+p1.y()*c1+p2.y()*c2, p0.z()*c0+p1.z()*c1+p2.z()*c2); } } return out; } #if defined(CGAL_LINKED_WITH_TBB) template <class AABB_tree, class PointRange> struct Distance_computation{ typedef typename PointRange::const_iterator::value_type Point_3; const AABB_tree& tree; const PointRange& sample_points; Point_3 initial_hint; double distance; Distance_computation( const AABB_tree& tree, const Point_3& p, const PointRange& sample_points) : tree(tree) , sample_points(sample_points) , initial_hint(p) , distance(-1) {} Distance_computation(Distance_computation& s, tbb::split ) : tree(s.tree) , sample_points(s.sample_points) , initial_hint(s.initial_hint) , distance(-1) {} void operator()(const tbb::blocked_range<std::size_t>& range) { Point_3 hint = initial_hint; double hdist = 0; for( std::size_t i = range.begin(); i != range.end(); ++i) { hint = tree.closest_point(*(sample_points.begin() + i), hint); typename Kernel_traits<Point_3>::Kernel::Compute_squared_distance_3 squared_distance; double d = to_double(CGAL::approximate_sqrt( squared_distance(hint,*(sample_points.begin() + i)) )); if(d > hdist) hdist=d; } if(hdist > distance) distance = hdist; } void join( Distance_computation& rhs ) {distance = (std::max)(rhs.distance, distance); } }; #endif template <class Concurrency_tag, class Kernel, class PointRange, class AABBTree> double approximate_Hausdorff_distance_impl( const PointRange& sample_points, const AABBTree& tree, typename Kernel::Point_3 hint) { #if !defined(CGAL_LINKED_WITH_TBB) CGAL_static_assertion_msg (!(boost::is_convertible<Concurrency_tag, Parallel_tag>::value), "Parallel_tag is enabled but TBB is unavailable."); #else if(boost::is_convertible<Concurrency_tag,Parallel_tag>::value) { std::atomic<double> distance; distance=0; Distance_computation<AABBTree, PointRange> f(tree, hint, sample_points); tbb::parallel_reduce(tbb::blocked_range<std::size_t>(0, sample_points.size()), f); return f.distance; } else #endif { double hdist = 0; for(const typename Kernel::Point_3& pt : sample_points) { hint = tree.closest_point(pt, hint); typename Kernel::Compute_squared_distance_3 squared_distance; typename Kernel::FT dist = squared_distance(hint,pt); double d = to_double(CGAL::approximate_sqrt(dist)); if(d>hdist) hdist=d; } return hdist; } } template<typename PointOutputIterator, typename GeomTraits, typename NamedParameters, typename TriangleIterator, typename Randomizer, typename Creator, typename Derived> struct Triangle_structure_sampler_base { const NamedParameters np; GeomTraits gt; PointOutputIterator& out; Triangle_structure_sampler_base(PointOutputIterator& out, const NamedParameters& np) : np(np), out(out) {} void sample_points(); double get_minimum_edge_length(); template<typename Tr> double get_tr_area(const Tr&); template<typename Tr> std::array<typename GeomTraits::Point_3, 3> get_tr_points(const Tr& tr); void ms_edges_sample(const std::size_t& nb_points_per_edge, const std::size_t& nb_pts_l_u); void ru_edges_sample(); void internal_sample_triangles(double, bool, bool); Randomizer get_randomizer(); std::pair<TriangleIterator, TriangleIterator> get_range(); std::size_t get_points_size(); void procede() { using parameters::choose_parameter; using parameters::get_parameter; using parameters::is_default_parameter; gt = choose_parameter<GeomTraits>(get_parameter(np, internal_np::geom_traits)); bool use_rs = choose_parameter(get_parameter(np, internal_np::random_uniform_sampling), true); bool use_gs = choose_parameter(get_parameter(np, internal_np::grid_sampling), false); bool use_ms = choose_parameter(get_parameter(np, internal_np::monte_carlo_sampling), false); if(use_gs || use_ms) if(is_default_parameter(get_parameter(np, internal_np::random_uniform_sampling))) use_rs = false; bool smpl_vrtcs = choose_parameter(get_parameter(np, internal_np::do_sample_vertices), true); bool smpl_dgs = choose_parameter(get_parameter(np, internal_np::do_sample_edges), true); bool smpl_fcs = choose_parameter(get_parameter(np, internal_np::do_sample_faces), true); double nb_pts_a_u = choose_parameter(get_parameter(np, internal_np::nb_points_per_area_unit), 0.); double nb_pts_l_u = choose_parameter(get_parameter(np, internal_np::nb_points_per_distance_unit), 0.); if(smpl_vrtcs) static_cast<Derived*>(this)->sample_points(); if(use_gs) { double grid_spacing_ = choose_parameter(get_parameter(np, internal_np::grid_spacing), 0.); if(grid_spacing_ == 0.) { grid_spacing_ = static_cast<Derived*>(this)->get_minimum_edge_length(); } static_cast<Derived*>(this)->internal_sample_triangles(grid_spacing_, smpl_fcs, smpl_dgs); } if(use_ms) { double min_sq_edge_length = (std::numeric_limits<double>::max)(); std::size_t nb_points_per_face = choose_parameter(get_parameter(np, internal_np::number_of_points_per_face), 0); std::size_t nb_points_per_edge = choose_parameter(get_parameter(np, internal_np::number_of_points_per_edge), 0); if((nb_points_per_face == 0 && nb_pts_a_u == 0.) || (nb_points_per_edge == 0 && nb_pts_l_u == 0.)) { min_sq_edge_length = static_cast<Derived*>(this)->get_minimum_edge_length(); } if(smpl_fcs) { if(nb_points_per_face == 0 && nb_pts_a_u == 0.) nb_pts_a_u = 2. / min_sq_edge_length; for(const auto& tr : make_range(static_cast<Derived*>(this)->get_range())) { std::size_t nb_points = nb_points_per_face; if(nb_points == 0) { nb_points = (std::max)( static_cast<std::size_t>( std::ceil(static_cast<Derived*>(this)->get_tr_area(tr)) *nb_pts_a_u), std::size_t(1)); } std::array<typename GeomTraits::Point_3, 3>points = static_cast<Derived*>(this)->get_tr_points(tr); Random_points_in_triangle_3<typename GeomTraits::Point_3, Creator> g(points[0], points[1], points[2]); out = std::copy_n(g, nb_points, out); } } if(smpl_dgs) static_cast<Derived*>(this)->ms_edges_sample(nb_points_per_edge, nb_pts_l_u); } if(use_rs) { if(smpl_fcs) { std::size_t nb_points = choose_parameter(get_parameter(np, internal_np::number_of_points_on_faces), 0); typename Derived::Randomizer g = static_cast<Derived*>(this)->get_randomizer(); if(nb_points == 0) { if(nb_pts_a_u == 0.) nb_points = static_cast<Derived*>(this)->get_points_size(); else nb_points = static_cast<std::size_t>(std::ceil(g.sum_of_weights()*nb_pts_a_u)); } out = std::copy_n(g, nb_points, out); } if(smpl_dgs) static_cast<Derived*>(this)->ru_edges_sample(nb_pts_l_u,nb_pts_a_u); } } }; } template <class Kernel, class FaceRange, class TriangleMesh, class VertexPointMap, class PointOutputIterator> PointOutputIterator sample_triangles(const FaceRange& triangles, const TriangleMesh& tm, VertexPointMap vpm, double distance, PointOutputIterator out, bool sample_faces, bool sample_edges, bool add_vertices) { typedef typename boost::property_traits<VertexPointMap>::reference Point_ref; typedef typename Kernel::Vector_3 Vector_3; typedef boost::graph_traits<TriangleMesh> GT; typedef typename GT::face_descriptor face_descriptor; typedef typename GT::halfedge_descriptor halfedge_descriptor; boost::unordered_set<typename GT::edge_descriptor> sampled_edges; boost::unordered_set<typename GT::vertex_descriptor> endpoints; for(face_descriptor fd : triangles) { halfedge_descriptor hd = halfedge(fd, tm); for(int i=0;i<3; ++i) { if(sample_edges && sampled_edges.insert(edge(hd, tm)).second ) { Point_ref p0 = get(vpm, source(hd, tm)); Point_ref p1 = get(vpm, target(hd, tm)); typename Kernel::Compute_squared_distance_3 squared_distance; const double d_p0p1 = to_double(approximate_sqrt(squared_distance(p0, p1))); const double nb_pts = std::ceil( d_p0p1 / distance ); const Vector_3 step_vec = typename Kernel::Construct_scaled_vector_3()( typename Kernel::Construct_vector_3()(p0, p1), typename Kernel::FT(1)/typename Kernel::FT(nb_pts)); for(double i=1; i<nb_pts; ++i) { *out++=typename Kernel::Construct_translated_point_3()(p0, typename Kernel::Construct_scaled_vector_3()(step_vec , typename Kernel::FT(i))); } } if(add_vertices && endpoints.insert(target(hd, tm)).second) *out++ = get(vpm, target(hd, tm)); hd = next(hd, tm); } if(sample_faces) { Point_ref p0 = get(vpm, source(hd, tm)); Point_ref p1 = get(vpm, target(hd, tm)); Point_ref p2 = get(vpm, target(next(hd, tm), tm)); out = internal::triangle_grid_sampling<Kernel>(p0, p1, p2, distance, out); } } return out; } namespace internal { template<typename Mesh, typename PointOutputIterator, typename GeomTraits, typename Creator, typename Vpm, typename NamedParameters> struct Triangle_structure_sampler_for_triangle_mesh : Triangle_structure_sampler_base<PointOutputIterator, GeomTraits, NamedParameters, typename boost::graph_traits<Mesh>::face_iterator, Random_points_in_triangle_mesh_3<Mesh, Vpm, Creator>, Creator, Triangle_structure_sampler_for_triangle_mesh<Mesh, PointOutputIterator, GeomTraits, Creator, Vpm, NamedParameters> > { typedef Triangle_structure_sampler_for_triangle_mesh<Mesh, PointOutputIterator, GeomTraits, Creator, Vpm, NamedParameters> Self; typedef Triangle_structure_sampler_base<PointOutputIterator, GeomTraits, NamedParameters, typename boost::graph_traits<Mesh>::face_iterator, Random_points_in_triangle_mesh_3<Mesh, Vpm, Creator>, Creator, Self> Base; typedef boost::graph_traits<Mesh> GT; typedef typename GT::halfedge_descriptor halfedge_descriptor; typedef typename GT::edge_descriptor edge_descriptor; typedef typename GT::face_descriptor face_descriptor; typedef Random_points_in_triangle_mesh_3<Mesh, Vpm,Creator> Randomizer; typedef typename boost::graph_traits<Mesh>::face_iterator TriangleIterator; Vpm pmap; double min_sq_edge_length; const Mesh& tm; Triangle_structure_sampler_for_triangle_mesh(const Mesh& m, PointOutputIterator& out, const NamedParameters& np) : Base(out, np), tm(m) { using parameters::choose_parameter; using parameters::get_parameter; pmap = choose_parameter(get_parameter(np, internal_np::vertex_point), get_const_property_map(vertex_point, tm)); min_sq_edge_length = (std::numeric_limits<double>::max)(); } std::pair<TriangleIterator, TriangleIterator> get_range() { return std::make_pair(faces(tm).begin(), faces(tm).end()); } void sample_points() { Property_map_to_unary_function<Vpm> unary(pmap); this->out = std::copy(boost::make_transform_iterator(boost::begin(vertices(tm)), unary), boost::make_transform_iterator(boost::end(vertices(tm)), unary), this->out); } double get_minimum_edge_length() { typedef typename boost::graph_traits<Mesh>::edge_descriptor edge_descriptor; if(min_sq_edge_length != (std::numeric_limits<double>::max)()) return min_sq_edge_length; for(edge_descriptor ed : edges(tm)) { const double sq_el = CGAL::to_double( typename GeomTraits::Compute_squared_distance_3()(get(pmap, source(ed, tm)), get(pmap, target(ed, tm)))); if(sq_el > 0. && sq_el < min_sq_edge_length) min_sq_edge_length = sq_el; } return min_sq_edge_length; } double get_tr_area(const typename boost::graph_traits<Mesh>::face_descriptor& tr) { return to_double(face_area(tr,tm,parameters::geom_traits(this->gt))); } template<typename Tr> std::array<typename GeomTraits::Point_3, 3> get_tr_points(const Tr& tr) { std::array<typename GeomTraits::Point_3, 3> points; halfedge_descriptor hd(halfedge(tr,tm)); for(int i=0; i<3; ++i) { points[i] = get(pmap, target(hd, tm)); hd = next(hd, tm); } return points; } void ms_edges_sample(std::size_t nb_points_per_edge, double nb_pts_l_u) { typename GeomTraits::Compute_squared_distance_3 squared_distance = this->gt.compute_squared_distance_3_object(); if(nb_points_per_edge == 0 && nb_pts_l_u == 0.) nb_pts_l_u = 1. / CGAL::sqrt(min_sq_edge_length); for(edge_descriptor ed : edges(tm)) { std::size_t nb_points = nb_points_per_edge; if(nb_points == 0) { nb_points = (std::max)( static_cast<std::size_t>(std::ceil(std::sqrt(to_double( squared_distance(get(pmap, source(ed, tm)), get(pmap, target(ed, tm))))) * nb_pts_l_u)), std::size_t(1)); } Random_points_on_segment_3<typename GeomTraits::Point_3, Creator> g(get(pmap, source(ed,tm)), get(pmap, target(ed, tm))); this->out = std::copy_n(g, nb_points, this->out); } } void ru_edges_sample(double nb_pts_l_u, double nb_pts_a_u) { using parameters::choose_parameter; using parameters::get_parameter; std::size_t nb_points = choose_parameter(get_parameter(this->np, internal_np::number_of_points_on_edges), 0); Random_points_on_edge_list_graph_3<Mesh, Vpm, Creator> g(tm, pmap); if(nb_points == 0) { if(nb_pts_l_u == 0) nb_points = num_vertices(tm); else nb_points = static_cast<std::size_t>(std::ceil(g.mesh_length() * nb_pts_a_u)); } this->out = std::copy_n(g, nb_points, this->out); } Randomizer get_randomizer() { return Randomizer(tm, pmap); } void internal_sample_triangles(double grid_spacing_, bool smpl_fcs, bool smpl_dgs) { this->out = sample_triangles<GeomTraits>(faces(tm), tm, pmap, grid_spacing_, this->out, smpl_fcs, smpl_dgs, false); } std::size_t get_points_size() { return num_vertices(tm); } }; template<typename PointRange, typename TriangleRange, typename PointOutputIterator, typename GeomTraits, typename Creator, typename NamedParameters> struct Triangle_structure_sampler_for_triangle_soup : Triangle_structure_sampler_base<PointOutputIterator, GeomTraits, NamedParameters, typename TriangleRange::const_iterator, Random_points_in_triangle_soup<PointRange, typename TriangleRange::value_type, Creator>, Creator, Triangle_structure_sampler_for_triangle_soup<PointRange, TriangleRange, PointOutputIterator, GeomTraits, Creator, NamedParameters> > { typedef typename TriangleRange::value_type TriangleType; typedef Triangle_structure_sampler_for_triangle_soup<PointRange, TriangleRange, PointOutputIterator, GeomTraits, Creator, NamedParameters> Self; typedef Triangle_structure_sampler_base<PointOutputIterator, GeomTraits, NamedParameters, typename TriangleRange::const_iterator, Random_points_in_triangle_soup<PointRange, TriangleType, Creator>, Creator, Self> Base; typedef typename GeomTraits::Point_3 Point_3; typedef Random_points_in_triangle_soup<PointRange, TriangleType, Creator> Randomizer; typedef typename TriangleRange::const_iterator TriangleIterator; double min_sq_edge_length; const PointRange& points; const TriangleRange& triangles; Triangle_structure_sampler_for_triangle_soup(const PointRange& pts, const TriangleRange& trs, PointOutputIterator& out, const NamedParameters& np) : Base(out, np), points(pts), triangles(trs) { min_sq_edge_length = (std::numeric_limits<double>::max)(); } std::pair<TriangleIterator, TriangleIterator> get_range() { return std::make_pair(triangles.begin(), triangles.end()); } void sample_points() { this->out = std::copy(points.begin(), points.end(), this->out); } double get_minimum_edge_length() { if(min_sq_edge_length != (std::numeric_limits<double>::max)()) return min_sq_edge_length; for(const auto& tr : triangles) { for(std::size_t i = 0; i< 3; ++i) { const Point_3& a = points[tr[i]]; const Point_3& b = points[tr[(i+1)%3]]; const double sq_el = CGAL::to_double(typename GeomTraits::Compute_squared_distance_3()(a, b)); if(sq_el > 0. && sq_el < min_sq_edge_length) min_sq_edge_length = sq_el; } } return min_sq_edge_length; } template<typename Tr> double get_tr_area(const Tr& tr) { return to_double(approximate_sqrt( this->gt.compute_squared_area_3_object()( points[tr[0]], points[tr[1]], points[tr[2]]))); } template<typename Tr> std::array<Point_3, 3> get_tr_points(const Tr& tr) { std::array<Point_3, 3> points; for(int i=0; i<3; ++i) { points[i] = this->points[tr[i]]; } return points; } void ms_edges_sample(std::size_t, double) { } void ru_edges_sample(double, double) { } Randomizer get_randomizer() { return Randomizer(triangles, points); } void internal_sample_triangles(double distance, bool, bool) { for(const auto& tr : triangles) { const Point_3& p0 = points[tr[0]]; const Point_3& p1 = points[tr[1]]; const Point_3& p2 = points[tr[2]]; this->out = internal::triangle_grid_sampling<GeomTraits>(p0, p1, p2, distance, this->out); } } std::size_t get_points_size() { return points.size(); } }; } template<class PointOutputIterator, class TriangleMesh, class NamedParameters> PointOutputIterator sample_triangle_mesh(const TriangleMesh& tm, PointOutputIterator out, const NamedParameters& np) { typedef typename GetGeomTraits<TriangleMesh, NamedParameters>::type GeomTraits; typedef typename GetVertexPointMap<TriangleMesh, NamedParameters>::const_type Vpm; internal::Triangle_structure_sampler_for_triangle_mesh<TriangleMesh, PointOutputIterator, GeomTraits, Creator_uniform_3<typename GeomTraits::FT, typename GeomTraits::Point_3>, Vpm, NamedParameters> performer(tm, out, np); performer.procede(); return performer.out; } template<class PointOutputIterator, class TriangleRange, class PointRange, class NamedParameters> PointOutputIterator sample_triangle_soup(const PointRange& points, const TriangleRange& triangles, PointOutputIterator out, const NamedParameters& np) { typedef typename PointRange::value_type Point_3; typedef typename Kernel_traits<Point_3>::Kernel GeomTraits; static_assert(std::is_same<Point_3, typename GeomTraits::Point_3>::value, "Wrong point type."); internal::Triangle_structure_sampler_for_triangle_soup<PointRange, TriangleRange, PointOutputIterator, GeomTraits, Creator_uniform_3<typename GeomTraits::FT, typename GeomTraits::Point_3>, NamedParameters> performer(points, triangles, out, np); performer.procede(); return performer.out; } template<class PointOutputIterator, class TriangleMesh> PointOutputIterator sample_triangle_mesh(const TriangleMesh& tm, PointOutputIterator out) { return sample_triangle_mesh(tm, out, parameters::all_default()); } template<class PointOutputIterator, class TriangleRange, class PointRange> PointOutputIterator sample_triangle_soup(const PointRange& points, const TriangleRange& triangles, PointOutputIterator out) { return sample_triangle_soup(points, triangles, out, parameters::all_default()); } template <class Concurrency_tag, class Kernel, class PointRange, class TriangleMesh, class VertexPointMap> double approximate_Hausdorff_distance( const PointRange& original_sample_points, const TriangleMesh& tm, VertexPointMap vpm) { CGAL_assertion_code( bool is_triangle = is_triangle_mesh(tm) ); CGAL_assertion_msg (is_triangle, "Mesh is not triangulated. Distance computing impossible."); #ifdef CGAL_HAUSDORFF_DEBUG std::cout << "Nb sample points " << sample_points.size() << "\n"; #endif typedef typename Kernel::Point_3 Point_3; std::vector<Point_3> sample_points (boost::begin(original_sample_points), boost::end(original_sample_points) ); spatial_sort(sample_points.begin(), sample_points.end()); typedef AABB_face_graph_triangle_primitive<TriangleMesh> Primitive; typedef AABB_tree< AABB_traits<Kernel, Primitive> > Tree; Tree tree( faces(tm).first, faces(tm).second, tm); tree.build(); Point_3 hint = get(vpm, *vertices(tm).first); return internal::approximate_Hausdorff_distance_impl<Concurrency_tag, Kernel> (original_sample_points, tree, hint); } template <class Concurrency_tag, class Kernel, class TriangleMesh, class NamedParameters, class VertexPointMap > double approximate_Hausdorff_distance( const TriangleMesh& tm1, const TriangleMesh& tm2, const NamedParameters& np, VertexPointMap vpm_2) { std::vector<typename Kernel::Point_3> sample_points; sample_triangle_mesh(tm1, std::back_inserter(sample_points), np); return approximate_Hausdorff_distance<Concurrency_tag, Kernel>(sample_points, tm2, vpm_2); } template< class Concurrency_tag, class TriangleMesh, class NamedParameters1, class NamedParameters2> double approximate_Hausdorff_distance( const TriangleMesh& tm1, const TriangleMesh& tm2, const NamedParameters1& np1, const NamedParameters2& np2) { typedef typename GetGeomTraits<TriangleMesh, NamedParameters1>::type GeomTraits; return approximate_Hausdorff_distance<Concurrency_tag, GeomTraits>( tm1, tm2, np1, parameters::choose_parameter(parameters::get_parameter(np2, internal_np::vertex_point), get_const_property_map(vertex_point, tm2))); } template< class Concurrency_tag, class TriangleMesh, class NamedParameters1, class NamedParameters2> double approximate_symmetric_Hausdorff_distance( const TriangleMesh& tm1, const TriangleMesh& tm2, const NamedParameters1& np1, const NamedParameters2& np2) { return (std::max)( approximate_Hausdorff_distance<Concurrency_tag>(tm1,tm2,np1,np2), approximate_Hausdorff_distance<Concurrency_tag>(tm2,tm1,np2,np1) ); } template< class Concurrency_tag, class TriangleMesh, class PointRange, class NamedParameters> double max_distance_to_triangle_mesh(const PointRange& points, const TriangleMesh& tm, const NamedParameters& np) { typedef typename GetGeomTraits<TriangleMesh, NamedParameters>::type GeomTraits; return approximate_Hausdorff_distance<Concurrency_tag, GeomTraits> (points,tm,parameters::choose_parameter(parameters::get_parameter(np, internal_np::vertex_point), get_const_property_map(vertex_point, tm))); } template< class TriangleMesh, class PointRange, class NamedParameters> double approximate_max_distance_to_point_set(const TriangleMesh& tm, const PointRange& points, const double precision, const NamedParameters& np) { typedef typename GetGeomTraits<TriangleMesh, NamedParameters>::type GeomTraits; typedef boost::graph_traits<TriangleMesh> GT; typedef Orthogonal_k_neighbor_search<Search_traits_3<GeomTraits> > Knn; typedef typename Knn::Tree Tree; Tree tree(points.begin(), points.end()); CRefiner<GeomTraits> ref; for(typename GT::face_descriptor f : faces(tm)) { typename GeomTraits::Point_3 points[3]; typename GT::halfedge_descriptor hd(halfedge(f,tm)); for(int i=0; i<3; ++i) { points[i] = get(parameters::choose_parameter(parameters::get_parameter(np, internal_np::vertex_point), get_const_property_map(vertex_point, tm)), target(hd, tm)); hd = next(hd, tm); } ref.add(points[0], points[1], points[2], tree); } return to_double(ref.refine(precision, tree)); } template< class Concurrency_tag, class TriangleMesh, class PointRange> double max_distance_to_triangle_mesh(const PointRange& points, const TriangleMesh& tm) { return max_distance_to_triangle_mesh<Concurrency_tag, TriangleMesh, PointRange> (points, tm, parameters::all_default()); } template< class TriangleMesh, class PointRange> double approximate_max_distance_to_point_set(const TriangleMesh& tm, const PointRange& points, const double precision) { return approximate_max_distance_to_point_set(tm, points, precision, parameters::all_default()); } template< class Concurrency_tag, class TriangleMesh, class NamedParameters> double approximate_Hausdorff_distance(const TriangleMesh& tm1, const TriangleMesh& tm2, const NamedParameters& np) { return approximate_Hausdorff_distance<Concurrency_tag>( tm1, tm2, np, parameters::all_default()); } template< class Concurrency_tag, class TriangleMesh> double approximate_Hausdorff_distance(const TriangleMesh& tm1, const TriangleMesh& tm2) { return approximate_Hausdorff_distance<Concurrency_tag>( tm1, tm2, parameters::all_default(), parameters::all_default()); } template< class Concurrency_tag, class TriangleMesh, class NamedParameters> double approximate_symmetric_Hausdorff_distance(const TriangleMesh& tm1, const TriangleMesh& tm2, const NamedParameters& np) { return approximate_symmetric_Hausdorff_distance<Concurrency_tag>( tm1, tm2, np, parameters::all_default()); } template< class Concurrency_tag, class TriangleMesh> double approximate_symmetric_Hausdorff_distance(const TriangleMesh& tm1, const TriangleMesh& tm2) { return approximate_symmetric_Hausdorff_distance<Concurrency_tag>( tm1, tm2, parameters::all_default(), parameters::all_default()); } namespace internal { template< class Kernel, class TriangleMesh1, class TriangleMesh2, class VPM1, class VPM2, class NamedParameters1, class NamedParameters2, class TM1Tree, class TM2Tree, class FaceHandle1, class FaceHandle2 > std::pair<typename Kernel::FT, bool> preprocess_bounded_error_Hausdorff_impl( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const bool compare_meshes, const VPM1& vpm1, const VPM2& vpm2, const bool is_one_sided_distance, const NamedParameters1& np1, const NamedParameters2& np2, TM1Tree& tm1_tree, TM2Tree& tm2_tree, std::vector<FaceHandle1>& tm1_only, std::vector<FaceHandle2>& tm2_only) { using FT = typename Kernel::FT; using Point_3 = typename Kernel::Point_3; using Timer = CGAL::Real_timer; Timer timer; timer.start(); std::cout.precision(20); const auto bbox1 = bbox(tm1); const auto bbox2 = bbox(tm2); const auto bb = bbox1 + bbox2; const FT sq_dist = CGAL::squared_distance( Point_3(bb.xmin(), bb.ymin(), bb.zmin()), Point_3(bb.xmax(), bb.ymax(), bb.zmax())); FT infinity_value = CGAL::approximate_sqrt(sq_dist) * FT(2); tm1_only.clear(); tm2_only.clear(); std::vector< std::pair<FaceHandle1, FaceHandle2> > common; const auto faces1 = faces(tm1); const auto faces2 = faces(tm2); CGAL_precondition(faces1.size() > 0); CGAL_precondition(faces2.size() > 0); bool rebuild = false; if (compare_meshes) { match_faces(tm1, tm2, std::back_inserter(common), std::back_inserter(tm1_only), std::back_inserter(tm2_only), np1, np2); if (is_one_sided_distance) { if (tm1_only.size() > 0) { tm1_tree.insert(tm1_only.begin(), tm1_only.end(), tm1, vpm1); tm2_tree.insert(faces2.begin(), faces2.end(), tm2, vpm2); } else { CGAL_assertion(tm1_only.size() == 0); infinity_value = -FT(1); } } else { if (tm1_only.size() == 0 && tm2_only.size() == 0) { infinity_value = -FT(1); } else if (common.size() == 0) { tm1_tree.insert(faces1.begin(), faces1.end(), tm1, vpm1); tm2_tree.insert(faces2.begin(), faces2.end(), tm2, vpm2); } else if (tm1_only.size() == 0) { CGAL_assertion(tm2_only.size() > 0); CGAL_assertion(tm2_only.size() < faces2.size()); tm1_tree.insert(faces1.begin(), faces1.end(), tm1, vpm1); tm2_tree.insert(tm2_only.begin(), tm2_only.end(), tm2, vpm2); } else if (tm2_only.size() == 0) { CGAL_assertion(tm1_only.size() > 0); CGAL_assertion(tm1_only.size() < faces1.size()); tm1_tree.insert(tm1_only.begin(), tm1_only.end(), tm1, vpm1); tm2_tree.insert(faces2.begin(), faces2.end(), tm2, vpm2); } else { CGAL_assertion(tm1_only.size() > 0); CGAL_assertion(tm1_only.size() < faces1.size()); tm1_tree.insert(tm1_only.begin(), tm1_only.end(), tm1, vpm1); tm2_tree.insert(faces2.begin(), faces2.end(), tm2, vpm2); rebuild = true; } } } else { tm1_tree.insert(faces1.begin(), faces1.end(), tm1, vpm1); tm2_tree.insert(faces2.begin(), faces2.end(), tm2, vpm2); } timer.stop(); return std::make_pair(infinity_value, rebuild); } template< class Kernel, class TriangleMesh1, class TriangleMesh2, class VPM1, class VPM2, class TM1Tree, class TM2Tree > double bounded_error_Hausdorff_impl( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const typename Kernel::FT error_bound, const VPM1& vpm1, const VPM2& vpm2, const typename Kernel::FT infinity_value, const typename Kernel::FT initial_bound, const typename Kernel::FT distance_bound, const TM1Tree& tm1_tree, const TM2Tree& tm2_tree) { using FT = typename Kernel::FT; using Point_3 = typename Kernel::Point_3; using Triangle_3 = typename Kernel::Triangle_3; using TM1_tree = TM1Tree; using TM2_tree = TM2Tree; using TM1_traits = typename TM1_tree::AABB_traits; using TM2_traits = typename TM2_tree::AABB_traits; using TM1_hd_traits = Hausdorff_primitive_traits_tm1<TM1_traits, Point_3, Kernel, TriangleMesh1, TriangleMesh2, VPM1, VPM2>; using TM2_hd_traits = Hausdorff_primitive_traits_tm2<TM2_traits, Triangle_3, Kernel, TriangleMesh1, TriangleMesh2, VPM2>; using Face_handle_1 = typename boost::graph_traits<TriangleMesh1>::face_descriptor; using Face_handle_2 = typename boost::graph_traits<TriangleMesh2>::face_descriptor; using Candidate = Candidate_triangle<Kernel, Face_handle_1, Face_handle_2>; using Timer = CGAL::Real_timer; std::cout.precision(20); CGAL_precondition(error_bound >= FT(0)); CGAL_precondition(tm1_tree.size() > 0); CGAL_precondition(tm2_tree.size() > 0); Timer timer; timer.start(); TM1_hd_traits traversal_traits_tm1( tm1_tree.traits(), tm2_tree, tm1, tm2, vpm1, vpm2, error_bound, infinity_value, initial_bound, distance_bound); const Point_3 stub(0, 0, 0); tm1_tree.traversal_with_priority(stub, traversal_traits_tm1); auto& candidate_triangles = traversal_traits_tm1.get_candidate_triangles(); auto global_bounds = traversal_traits_tm1.get_global_bounds(); timer.stop(); timer.reset(); timer.start(); CGAL_assertion(global_bounds.lower >= FT(0)); CGAL_assertion(global_bounds.upper >= FT(0)); CGAL_assertion(global_bounds.upper >= global_bounds.lower); const FT squared_error_bound = error_bound * error_bound; while ( (global_bounds.upper - global_bounds.lower > error_bound) && !candidate_triangles.empty()) { const Candidate triangle_and_bound = candidate_triangles.top(); candidate_triangles.pop(); const auto& triangle_bounds = triangle_and_bound.bounds; CGAL_assertion(triangle_bounds.lower >= FT(0)); CGAL_assertion(triangle_bounds.upper >= FT(0)); CGAL_assertion(triangle_bounds.upper >= triangle_bounds.lower); if ( (triangle_bounds.upper > global_bounds.lower) && (triangle_bounds.upper - triangle_bounds.lower > error_bound)) { const Triangle_3& triangle_for_subdivision = triangle_and_bound.triangle; const Point_3 v0 = triangle_for_subdivision.vertex(0); const Point_3 v1 = triangle_for_subdivision.vertex(1); const Point_3 v2 = triangle_for_subdivision.vertex(2); const auto closest_triangle_v0 = tm2_tree.closest_point_and_primitive(v0); const auto closest_triangle_v1 = tm2_tree.closest_point_and_primitive(v1); const auto closest_triangle_v2 = tm2_tree.closest_point_and_primitive(v2); CGAL_assertion(closest_triangle_v0.second != boost::graph_traits<TriangleMesh2>::null_face()); CGAL_assertion(closest_triangle_v1.second != boost::graph_traits<TriangleMesh2>::null_face()); CGAL_assertion(closest_triangle_v2.second != boost::graph_traits<TriangleMesh2>::null_face()); if ( (closest_triangle_v0.second == closest_triangle_v1.second) && (closest_triangle_v1.second == closest_triangle_v2.second)) { global_bounds.lower = triangle_bounds.upper; global_bounds.lpair.second = triangle_bounds.tm2_uface; continue; } if ( CGAL::squared_distance(v0, v1) < squared_error_bound && CGAL::squared_distance(v0, v2) < squared_error_bound && CGAL::squared_distance(v1, v2) < squared_error_bound) { global_bounds.lower = triangle_bounds.upper; global_bounds.lpair.second = triangle_bounds.tm2_uface; continue; } const Point_3 v01 = CGAL::midpoint(v0, v1); const Point_3 v02 = CGAL::midpoint(v0, v2); const Point_3 v12 = CGAL::midpoint(v1, v2); const std::array<Triangle_3, 4> sub_triangles = { Triangle_3(v0, v01, v02), Triangle_3(v1 , v01, v12), Triangle_3(v2, v02, v12), Triangle_3(v01, v02, v12) }; for (std::size_t i = 0; i < 4; ++i) { TM2_hd_traits traversal_traits_tm2( tm2_tree.traits(), tm2, vpm2, triangle_bounds, infinity_value, infinity_value, infinity_value); tm2_tree.traversal_with_priority(sub_triangles[i], traversal_traits_tm2); const auto local_bounds = traversal_traits_tm2.get_local_bounds(); CGAL_assertion(local_bounds.lower >= FT(0)); CGAL_assertion(local_bounds.upper >= FT(0)); CGAL_assertion(local_bounds.upper >= local_bounds.lower); CGAL_assertion(local_bounds.lpair == local_bounds.default_face_pair()); CGAL_assertion(local_bounds.upair == local_bounds.default_face_pair()); if (local_bounds.lower > global_bounds.lower) { global_bounds.lower = local_bounds.lower; global_bounds.lpair.second = local_bounds.tm2_lface; } candidate_triangles.push( Candidate(sub_triangles[i], local_bounds, triangle_and_bound.tm1_face)); } const FT current_max = candidate_triangles.top().bounds.upper; CGAL_assertion(current_max >= FT(0)); if (current_max > global_bounds.lower) { global_bounds.upper = current_max; global_bounds.upair.second = candidate_triangles.top().bounds.tm2_uface; } else { global_bounds.upper = global_bounds.lower; global_bounds.upair.second = global_bounds.lpair.second; } } } timer.stop(); CGAL_assertion(global_bounds.lower >= FT(0)); CGAL_assertion(global_bounds.upper >= FT(0)); CGAL_assertion(global_bounds.upper >= global_bounds.lower); const double hdist = CGAL::to_double((global_bounds.lower + global_bounds.upper) / FT(2)); CGAL_assertion(global_bounds.lpair.first != boost::graph_traits<TriangleMesh1>::null_face()); CGAL_assertion(global_bounds.lpair.second != boost::graph_traits<TriangleMesh2>::null_face()); CGAL_assertion(global_bounds.upair.first != boost::graph_traits<TriangleMesh1>::null_face()); CGAL_assertion(global_bounds.upair.second != boost::graph_traits<TriangleMesh2>::null_face()); return hdist; } #if defined(CGAL_LINKED_WITH_TBB) && defined(CGAL_METIS_ENABLED) && defined(USE_PARALLEL_BEHD) template<class TriangleMesh, class VPM, class TMTree> struct Triangle_mesh_wrapper { const TriangleMesh& tm; const VPM& vpm; const bool is_tm2; TMTree& tm_tree; Triangle_mesh_wrapper( const TriangleMesh& tm, const VPM& vpm, const bool is_tm2, TMTree& tm_tree) : tm(tm), vpm(vpm), is_tm2(is_tm2), tm_tree(tm_tree) { } void build_tree() { tm_tree.insert(faces(tm).begin(), faces(tm).end(), tm, vpm); tm_tree.build(); if (is_tm2) tm_tree.accelerate_distance_queries(); else tm_tree.do_not_accelerate_distance_queries(); } }; template<class TM1Wrapper, class TM2Wrapper> struct Bounded_error_preprocessing { using Timer = CGAL::Real_timer; std::vector<boost::any>& tm_wrappers; Bounded_error_preprocessing( std::vector<boost::any>& tm_wrappers) : tm_wrappers(tm_wrappers) { } Bounded_error_preprocessing( Bounded_error_preprocessing& s, tbb::split) : tm_wrappers(s.tm_wrappers) { } bool is_tm1_wrapper(const boost::any& operand) const { return operand.type() == typeid(TM1Wrapper); } bool is_tm2_wrapper(const boost::any& operand) const { return operand.type() == typeid(TM2Wrapper); } void operator()(const tbb::blocked_range<std::size_t>& range) { Timer timer; timer.reset(); timer.start(); for (std::size_t i = range.begin(); i != range.end(); ++i) { CGAL_assertion(i < tm_wrappers.size()); auto& tm_wrapper = tm_wrappers[i]; if (is_tm1_wrapper(tm_wrapper)) { TM1Wrapper& object = boost::any_cast<TM1Wrapper&>(tm_wrapper); object.build_tree(); } else if (is_tm2_wrapper(tm_wrapper)) { TM2Wrapper& object = boost::any_cast<TM2Wrapper&>(tm_wrapper); object.build_tree(); } else { CGAL_assertion_msg(false, "Error: wrong boost any type!"); } } timer.stop(); } void join(Bounded_error_preprocessing&) { } }; template< class TriangleMesh1, class TriangleMesh2, class VPM1, class VPM2, class TM1Tree, class TM2Tree, class Kernel > struct Bounded_error_distance_computation { using FT = typename Kernel::FT; using Timer = CGAL::Real_timer; const std::vector<TriangleMesh1>& tm1_parts; const TriangleMesh2& tm2; const FT error_bound; const VPM1& vpm1; const VPM2& vpm2; const FT infinity_value; const FT initial_bound; const std::vector<TM1Tree>& tm1_trees; const TM2Tree& tm2_tree; double distance; Bounded_error_distance_computation( const std::vector<TriangleMesh1>& tm1_parts, const TriangleMesh2& tm2, const FT error_bound, const VPM1& vpm1, const VPM2& vpm2, const FT infinity_value, const FT initial_bound, const std::vector<TM1Tree>& tm1_trees, const TM2Tree& tm2_tree) : tm1_parts(tm1_parts), tm2(tm2), error_bound(error_bound), vpm1(vpm1), vpm2(vpm2), infinity_value(infinity_value), initial_bound(initial_bound), tm1_trees(tm1_trees), tm2_tree(tm2_tree), distance(-1.0) { CGAL_assertion(tm1_parts.size() == tm1_trees.size()); } Bounded_error_distance_computation( Bounded_error_distance_computation& s, tbb::split) : tm1_parts(s.tm1_parts), tm2(s.tm2), error_bound(s.error_bound), vpm1(s.vpm1), vpm2(s.vpm2), infinity_value(s.infinity_value), initial_bound(s.initial_bound), tm1_trees(s.tm1_trees), tm2_tree(s.tm2_tree), distance(-1.0) { CGAL_assertion(tm1_parts.size() == tm1_trees.size()); } void operator()(const tbb::blocked_range<std::size_t>& range) { Timer timer; timer.reset(); timer.start(); double hdist = -1.0; for (std::size_t i = range.begin(); i != range.end(); ++i) { CGAL_assertion(i < tm1_parts.size()); CGAL_assertion(i < tm1_trees.size()); const auto& tm1 = tm1_parts[i]; const auto& tm1_tree = tm1_trees[i]; const double dist = bounded_error_Hausdorff_impl<Kernel>( tm1, tm2, error_bound, vpm1, vpm2, infinity_value, initial_bound, -FT(1), tm1_tree, tm2_tree); if (dist > hdist) hdist = dist; } if (hdist > distance) distance = hdist; timer.stop(); } void join(Bounded_error_distance_computation& rhs) { distance = (CGAL::max)(rhs.distance, distance); } }; #endif template< class Concurrency_tag, class Kernel, class TriangleMesh1, class TriangleMesh2, class VPM1, class VPM2, class NamedParameters1, class NamedParameters2 > double bounded_error_one_sided_Hausdorff_impl( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const typename Kernel::FT error_bound, const typename Kernel::FT distance_bound, const bool compare_meshes, const VPM1& vpm1, const VPM2& vpm2, const NamedParameters1& np1, const NamedParameters2& np2) { #if !defined(CGAL_LINKED_WITH_TBB) || !defined(CGAL_METIS_ENABLED) CGAL_static_assertion_msg( !(boost::is_convertible<Concurrency_tag, CGAL::Parallel_tag>::value), "Parallel_tag is enabled but at least TBB or METIS is unavailable."); #endif using FT = typename Kernel::FT; using TM1 = TriangleMesh1; using TM2 = TriangleMesh2; using TM1_primitive = AABB_face_graph_triangle_primitive<TM1, VPM1>; using TM2_primitive = AABB_face_graph_triangle_primitive<TM2, VPM2>; using TM1_traits = AABB_traits<Kernel, TM1_primitive>; using TM2_traits = AABB_traits<Kernel, TM2_primitive>; using TM1_tree = AABB_tree<TM1_traits>; using TM2_tree = AABB_tree<TM2_traits>; using Face_handle_1 = typename boost::graph_traits<TM1>::face_descriptor; using Face_handle_2 = typename boost::graph_traits<TM2>::face_descriptor; using Timer = CGAL::Real_timer; #if defined(CGAL_LINKED_WITH_TBB) && defined(CGAL_METIS_ENABLED) && defined(USE_PARALLEL_BEHD) using Point_3 = typename Kernel::Point_3; using TMF = CGAL::Face_filtered_graph<TM1>; using TMF_primitive = AABB_face_graph_triangle_primitive<TMF, VPM1>; using TMF_traits = AABB_traits<Kernel, TMF_primitive>; using TMF_tree = AABB_tree<TMF_traits>; using TM1_wrapper = Triangle_mesh_wrapper<TMF, VPM1, TMF_tree>; using TM2_wrapper = Triangle_mesh_wrapper<TM2, VPM2, TM2_tree>; std::vector<TMF> tm1_parts; std::vector<TMF_tree> tm1_trees; std::vector<boost::any> tm_wrappers; #endif Timer timer; std::cout.precision(20); TM1_tree tm1_tree; TM2_tree tm2_tree; FT infinity_value = -FT(1); #if defined(CGAL_LINKED_WITH_TBB) && defined(CGAL_METIS_ENABLED) && defined(USE_PARALLEL_BEHD) const int nb_cores = 4; const std::size_t min_nb_faces_to_split = 100; if ( boost::is_convertible<Concurrency_tag, CGAL::Parallel_tag>::value && nb_cores > 1 && faces(tm1).size() >= min_nb_faces_to_split) { timer.reset(); timer.start(); const auto bbox1 = bbox(tm1); const auto bbox2 = bbox(tm2); const auto bb = bbox1 + bbox2; const FT sq_dist = CGAL::squared_distance( Point_3(bb.xmin(), bb.ymin(), bb.zmin()), Point_3(bb.xmax(), bb.ymax(), bb.zmax())); infinity_value = CGAL::approximate_sqrt(sq_dist) * FT(2); CGAL_assertion(infinity_value >= FT(0)); timer.stop(); timer.reset(); timer.start(); using Face_property_tag = CGAL::dynamic_face_property_t<int>; auto face_pid_map = get(Face_property_tag(), tm1); CGAL::METIS::partition_graph( tm1, nb_cores, CGAL::parameters:: face_partition_id_map(face_pid_map)); timer.stop(); timer.reset(); timer.start(); tm1_parts.reserve(nb_cores); for (int i = 0; i < nb_cores; ++i) { tm1_parts.emplace_back(tm1, i, face_pid_map); } CGAL_assertion(tm1_parts.size() == nb_cores); timer.stop(); timer.reset(); timer.start(); tm1_trees.resize(tm1_parts.size()); tm_wrappers.reserve(tm1_parts.size() + 1); for (std::size_t i = 0; i < tm1_parts.size(); ++i) { tm_wrappers.push_back(TM1_wrapper(tm1_parts[i], vpm1, false, tm1_trees[i])); } tm_wrappers.push_back(TM2_wrapper(tm2, vpm2, true, tm2_tree)); CGAL_assertion(tm_wrappers.size() == tm1_parts.size() + 1); Bounded_error_preprocessing<TM1_wrapper, TM2_wrapper> bep(tm_wrappers); tbb::parallel_reduce(tbb::blocked_range<std::size_t>(0, tm_wrappers.size()), bep); timer.stop(); } else #endif { timer.reset(); timer.start(); bool rebuild = false; std::vector<Face_handle_1> tm1_only; std::vector<Face_handle_2> tm2_only; std::tie(infinity_value, rebuild) = preprocess_bounded_error_Hausdorff_impl<Kernel>( tm1, tm2, compare_meshes, vpm1, vpm2, true, np1, np2, tm1_tree, tm2_tree, tm1_only, tm2_only); CGAL_assertion(!rebuild); if (infinity_value >= FT(0)) { tm1_tree.build(); tm2_tree.build(); tm1_tree.do_not_accelerate_distance_queries(); tm2_tree.accelerate_distance_queries(); } timer.stop(); } if (infinity_value < FT(0)) { return 0.0; } CGAL_assertion(error_bound >= FT(0)); CGAL_assertion(infinity_value > FT(0)); const FT initial_bound = error_bound; std::atomic<double> hdist; timer.reset(); timer.start(); #if defined(CGAL_LINKED_WITH_TBB) && defined(CGAL_METIS_ENABLED) && defined(USE_PARALLEL_BEHD) if ( boost::is_convertible<Concurrency_tag, CGAL::Parallel_tag>::value && nb_cores > 1 && faces(tm1).size() >= min_nb_faces_to_split) { Bounded_error_distance_computation<TMF, TM2, VPM1, VPM2, TMF_tree, TM2_tree, Kernel> bedc( tm1_parts, tm2, error_bound, vpm1, vpm2, infinity_value, initial_bound, tm1_trees, tm2_tree); tbb::parallel_reduce(tbb::blocked_range<std::size_t>(0, tm1_parts.size()), bedc); hdist = bedc.distance; } else #endif { hdist = bounded_error_Hausdorff_impl<Kernel>( tm1, tm2, error_bound, vpm1, vpm2, infinity_value, initial_bound, distance_bound, tm1_tree, tm2_tree); } timer.stop(); CGAL_assertion(hdist >= 0.0); return hdist; } template< class Concurrency_tag, class Kernel, class TriangleMesh1, class TriangleMesh2, class VPM1, class VPM2, class NamedParameters1, class NamedParameters2 > double bounded_error_symmetric_Hausdorff_impl( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const typename Kernel::FT error_bound, const typename Kernel::FT distance_bound, const bool compare_meshes, const VPM1& vpm1, const VPM2& vpm2, const NamedParameters1& np1, const NamedParameters2& np2) { #if !defined(CGAL_LINKED_WITH_TBB) || !defined(CGAL_METIS_ENABLED) CGAL_static_assertion_msg( !(boost::is_convertible<Concurrency_tag, CGAL::Parallel_tag>::value), "Parallel_tag is enabled but at least TBB or METIS is unavailable."); #endif using FT = typename Kernel::FT; using TM1_primitive = AABB_face_graph_triangle_primitive<TriangleMesh1, VPM1>; using TM2_primitive = AABB_face_graph_triangle_primitive<TriangleMesh2, VPM2>; using TM1_traits = AABB_traits<Kernel, TM1_primitive>; using TM2_traits = AABB_traits<Kernel, TM2_primitive>; using TM1_tree = AABB_tree<TM1_traits>; using TM2_tree = AABB_tree<TM2_traits>; using Face_handle_1 = typename boost::graph_traits<TriangleMesh1>::face_descriptor; using Face_handle_2 = typename boost::graph_traits<TriangleMesh2>::face_descriptor; std::cout.precision(20); std::vector<Face_handle_1> tm1_only; std::vector<Face_handle_2> tm2_only; TM1_tree tm1_tree; TM2_tree tm2_tree; FT infinity_value = -FT(1); bool rebuild = false; std::tie(infinity_value, rebuild) = preprocess_bounded_error_Hausdorff_impl<Kernel>( tm1, tm2, compare_meshes, vpm1, vpm2, false, np1, np2, tm1_tree, tm2_tree, tm1_only, tm2_only); if (infinity_value < FT(0)) { return 0.0; } CGAL_assertion(infinity_value > FT(0)); FT initial_bound = error_bound; double dista = CGAL::to_double(error_bound); if (!compare_meshes || (compare_meshes && tm1_only.size() > 0)) { dista = bounded_error_Hausdorff_impl<Kernel>( tm1, tm2, error_bound, vpm1, vpm2, infinity_value, initial_bound, distance_bound, tm1_tree, tm2_tree); } if (rebuild) { CGAL_assertion(compare_meshes); tm1_tree.clear(); tm2_tree.clear(); CGAL_assertion(tm2_only.size() > 0); CGAL_assertion(tm2_only.size() < faces(tm2).size()); tm1_tree.insert(faces(tm1).begin(), faces(tm1).end(), tm1, vpm1); tm2_tree.insert(tm2_only.begin(), tm2_only.end(), tm2, vpm2); } initial_bound = static_cast<FT>(dista); double distb = CGAL::to_double(error_bound); if (!compare_meshes || (compare_meshes && tm2_only.size() > 0)) { distb = bounded_error_Hausdorff_impl<Kernel>( tm2, tm1, error_bound, vpm2, vpm1, infinity_value, initial_bound, distance_bound, tm2_tree, tm1_tree); } return (CGAL::max)(dista, distb); } template<class Kernel, class TM2_tree> typename Kernel::FT recursive_hausdorff_subdivision( const typename Kernel::Point_3& v0, const typename Kernel::Point_3& v1, const typename Kernel::Point_3& v2, const TM2_tree& tm2_tree, const typename Kernel::FT squared_error_bound) { const auto max_squared_edge_length = (CGAL::max)( (CGAL::max)( CGAL::squared_distance(v0, v1), CGAL::squared_distance(v0, v2)), CGAL::squared_distance(v1, v2)); if (max_squared_edge_length < squared_error_bound) { return (CGAL::max)( (CGAL::max)( CGAL::squared_distance(v0, tm2_tree.closest_point(v0)), CGAL::squared_distance(v1, tm2_tree.closest_point(v1))), CGAL::squared_distance(v2, tm2_tree.closest_point(v2))); } const auto v01 = midpoint(v0, v1); const auto v02 = midpoint(v0, v2); const auto v12 = midpoint(v1, v2); return (CGAL::max)( (CGAL::max)( recursive_hausdorff_subdivision<Kernel>(v0, v01, v02, tm2_tree, squared_error_bound), recursive_hausdorff_subdivision<Kernel>(v1, v01, v12, tm2_tree, squared_error_bound)), (CGAL::max)( recursive_hausdorff_subdivision<Kernel>(v2 , v02, v12, tm2_tree, squared_error_bound), recursive_hausdorff_subdivision<Kernel>(v01, v02, v12, tm2_tree, squared_error_bound))); } template< class Concurrency_tag, class Kernel, class TriangleMesh1, class TriangleMesh2, class VPM1, class VPM2 > double bounded_error_Hausdorff_naive_impl( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const typename Kernel::FT error_bound, const VPM1& vpm1, const VPM2& vpm2) { using FT = typename Kernel::FT; using Point_3 = typename Kernel::Point_3; using Triangle_3 = typename Kernel::Triangle_3; using TM2_primitive = AABB_face_graph_triangle_primitive<TriangleMesh2, VPM2>; using TM2_traits = AABB_traits<Kernel, TM2_primitive>; using TM2_tree = AABB_tree<TM2_traits>; using TM1_face_to_triangle_map = Triangle_from_face_descriptor_map<TriangleMesh1, VPM1>; FT squared_lower_bound = FT(0); const FT squared_error_bound = error_bound * error_bound; TM2_tree tm2_tree(faces(tm2).begin(), faces(tm2).end(), tm2, vpm2); tm2_tree.build(); tm2_tree.accelerate_distance_queries(); const TM1_face_to_triangle_map face_to_triangle_map(&tm1, vpm1); for (const auto& face : faces(tm1)) { const Triangle_3 triangle = get(face_to_triangle_map, face); const Point_3 v0 = triangle.vertex(0); const Point_3 v1 = triangle.vertex(1); const Point_3 v2 = triangle.vertex(2); const FT triangle_bound = recursive_hausdorff_subdivision<Kernel>( v0, v1, v2, tm2_tree, squared_error_bound); if (triangle_bound > squared_lower_bound) { squared_lower_bound = triangle_bound; } } return CGAL::sqrt(CGAL::to_double(squared_lower_bound)); } } template< class Concurrency_tag, class TriangleMesh1, class TriangleMesh2, class NamedParameters1, class NamedParameters2 > double bounded_error_Hausdorff_distance( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const double error_bound, const NamedParameters1& np1, const NamedParameters2& np2) { CGAL_assertion_code( const bool is_triangle = is_triangle_mesh(tm1) && is_triangle_mesh(tm2)); CGAL_assertion_msg(is_triangle, "Both meshes must be triangulated to compute this distance!"); using Traits = typename GetGeomTraits<TriangleMesh1, NamedParameters1>::type; using FT = typename Traits::FT; const auto vpm1 = parameters::choose_parameter( parameters::get_parameter(np1, internal_np::vertex_point), get_const_property_map(vertex_point, tm1)); const auto vpm2 = parameters::choose_parameter( parameters::get_parameter(np2, internal_np::vertex_point), get_const_property_map(vertex_point, tm2)); const bool match_faces1 = parameters::choose_parameter( parameters::get_parameter(np1, internal_np::match_faces), true); const bool match_faces2 = parameters::choose_parameter( parameters::get_parameter(np2, internal_np::match_faces), true); const bool match_faces = match_faces1 && match_faces2; CGAL_precondition(error_bound >= 0.0); const FT error_threshold = static_cast<FT>(error_bound); return internal::bounded_error_one_sided_Hausdorff_impl<Concurrency_tag, Traits>( tm1, tm2, error_threshold, -FT(1), match_faces, vpm1, vpm2, np1, np2); } template< class Concurrency_tag, class TriangleMesh1, class TriangleMesh2, class NamedParameters1 > double bounded_error_Hausdorff_distance( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const double error_bound, const NamedParameters1& np1) { return bounded_error_Hausdorff_distance<Concurrency_tag>( tm1, tm2, error_bound, np1, parameters::all_default()); } template< class Concurrency_tag, class TriangleMesh1, class TriangleMesh2 > double bounded_error_Hausdorff_distance( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const double error_bound = 0.0001) { return bounded_error_Hausdorff_distance<Concurrency_tag>( tm1, tm2, error_bound, parameters::all_default()); } template< class Concurrency_tag, class TriangleMesh1, class TriangleMesh2, class NamedParameters1, class NamedParameters2 > double bounded_error_symmetric_Hausdorff_distance( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const double error_bound, const NamedParameters1& np1, const NamedParameters2& np2) { CGAL_assertion_code( const bool is_triangle = is_triangle_mesh(tm1) && is_triangle_mesh(tm2)); CGAL_assertion_msg(is_triangle, "Both meshes must be triangulated to compute this distance!"); using Traits = typename GetGeomTraits<TriangleMesh1, NamedParameters1>::type; using FT = typename Traits::FT; const auto vpm1 = parameters::choose_parameter( parameters::get_parameter(np1, internal_np::vertex_point), get_const_property_map(vertex_point, tm1)); const auto vpm2 = parameters::choose_parameter( parameters::get_parameter(np2, internal_np::vertex_point), get_const_property_map(vertex_point, tm2)); const bool match_faces1 = parameters::choose_parameter( parameters::get_parameter(np1, internal_np::match_faces), true); const bool match_faces2 = parameters::choose_parameter( parameters::get_parameter(np2, internal_np::match_faces), true); const bool match_faces = match_faces1 && match_faces2; CGAL_precondition(error_bound >= 0.0); const FT error_threshold = static_cast<FT>(error_bound); return internal::bounded_error_symmetric_Hausdorff_impl<Concurrency_tag, Traits>( tm1, tm2, error_threshold, -FT(1), match_faces, vpm1, vpm2, np1, np2); } template< class Concurrency_tag, class TriangleMesh1, class TriangleMesh2, class NamedParameters1 > double bounded_error_symmetric_Hausdorff_distance( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const double error_bound, const NamedParameters1& np1) { return bounded_error_symmetric_Hausdorff_distance<Concurrency_tag>( tm1, tm2, error_bound, np1, parameters::all_default()); } template< class Concurrency_tag, class TriangleMesh1, class TriangleMesh2> double bounded_error_symmetric_Hausdorff_distance( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const double error_bound = 0.0001) { return bounded_error_symmetric_Hausdorff_distance<Concurrency_tag>( tm1, tm2, error_bound, parameters::all_default()); } template< class Concurrency_tag, class TriangleMesh1, class TriangleMesh2, class NamedParameters1, class NamedParameters2 > bool are_within_tolerance( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const double distance_bound, const double error_bound, const NamedParameters1& np1, const NamedParameters2& np2) { CGAL_assertion_code( const bool is_triangle = is_triangle_mesh(tm1) && is_triangle_mesh(tm2)); CGAL_assertion_msg(is_triangle, "Both meshes must be triangulated in order to be compared!"); using Traits = typename GetGeomTraits<TriangleMesh1, NamedParameters1>::type; using FT = typename Traits::FT; const auto vpm1 = parameters::choose_parameter( parameters::get_parameter(np1, internal_np::vertex_point), get_const_property_map(vertex_point, tm1)); const auto vpm2 = parameters::choose_parameter( parameters::get_parameter(np2, internal_np::vertex_point), get_const_property_map(vertex_point, tm2)); const bool match_faces1 = parameters::choose_parameter( parameters::get_parameter(np1, internal_np::match_faces), true); const bool match_faces2 = parameters::choose_parameter( parameters::get_parameter(np2, internal_np::match_faces), true); const bool match_faces = match_faces1 && match_faces2; const bool use_one_sided = true; CGAL_precondition(error_bound >= 0.0); const FT error_threshold = static_cast<FT>(error_bound); CGAL_precondition(distance_bound >= 0.0); const FT distance_threshold = static_cast<FT>(distance_bound); double hdist = -1.0; if (use_one_sided) { hdist = internal::bounded_error_one_sided_Hausdorff_impl<Concurrency_tag, Traits>( tm1, tm2, error_threshold, distance_threshold, match_faces, vpm1, vpm2, np1, np2); } else { hdist = internal::bounded_error_symmetric_Hausdorff_impl<Concurrency_tag, Traits>( tm1, tm2, error_threshold, distance_threshold, match_faces, vpm1, vpm2, np1, np2); } CGAL_assertion(hdist >= 0.0); std::cout << "- fin distance: " << hdist << std::endl; std::cout << "- max distance: " << distance_bound << std::endl; CGAL_assertion_msg(false, "TODO: FINISH THE DISTANCE TOLERANCE FUNCTION!"); return false; } template< class Concurrency_tag, class TriangleMesh1, class TriangleMesh2, class NamedParameters1 > double are_within_tolerance( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const double max_distance, const double error_bound, const NamedParameters1& np1) { return are_within_tolerance<Concurrency_tag>( tm1, tm2, max_distance, error_bound, np1, parameters::all_default()); } template< class Concurrency_tag, class TriangleMesh1, class TriangleMesh2 > double are_within_tolerance( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const double max_distance = 1.0, const double error_bound = 0.0001) { return are_within_tolerance<Concurrency_tag>( tm1, tm2, max_distance, error_bound, parameters::all_default()); } template< class Concurrency_tag, class TriangleMesh1, class TriangleMesh2, class NamedParameters1, class NamedParameters2 > double bounded_error_Hausdorff_distance_naive( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const double error_bound, const NamedParameters1& np1, const NamedParameters2& np2) { CGAL_assertion_code( const bool is_triangle = is_triangle_mesh(tm1) && is_triangle_mesh(tm2)); CGAL_assertion_msg(is_triangle, "Both meshes must be triangulated to compute this distance!"); using Traits = typename GetGeomTraits<TriangleMesh1, NamedParameters1>::type; using FT = typename Traits::FT; using parameters::choose_parameter; using parameters::get_parameter; const auto vpm1 = choose_parameter(get_parameter(np1, internal_np::vertex_point), get_const_property_map(vertex_point, tm1)); const auto vpm2 = choose_parameter(get_parameter(np2, internal_np::vertex_point), get_const_property_map(vertex_point, tm2)); CGAL_precondition(error_bound >= 0.0); const FT error_threshold = static_cast<FT>(error_bound); return internal::bounded_error_Hausdorff_naive_impl<Concurrency_tag, Traits>( tm1, tm2, error_threshold, vpm1, vpm2); } template< class Concurrency_tag, class TriangleMesh1, class TriangleMesh2, class NamedParameters1 > double bounded_error_Hausdorff_distance_naive( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const double error_bound, const NamedParameters1& np1) { return bounded_error_Hausdorff_distance_naive<Concurrency_tag>( tm1, tm2, error_bound, np1, parameters::all_default()); } template< class Concurrency_tag, class TriangleMesh1, class TriangleMesh2 > double bounded_error_Hausdorff_distance_naive( const TriangleMesh1& tm1, const TriangleMesh2& tm2, const double error_bound = 0.0001) { return bounded_error_Hausdorff_distance_naive<Concurrency_tag>( tm1, tm2, error_bound, parameters::all_default()); } } } #endif
#include "global.h" #include "drap.h" #include "dra.h" #include <math.h> #include <stdlib.h> #include <stdio.h> #include "macdecls.h" #define WALLTIME 0 #if WALLTIME #include "walltime.c" #endif #ifdef SP #define DRA_DBL_BUF_SIZE 131072 #else #define DRA_DBL_BUF_SIZE 100000 #endif #define DRA_FAIL (Integer)1 #define COLUMN 1 #define ROW 0 #define ON 1 #define OFF 0 #define ILO 0 #define IHI 1 #define JLO 2 #define JHI 3 #define DRA_OP_WRITE 777 #define DRA_OP_READ 888 #define MAX_REQ 5 #define GA_TYPE_GSM 32760 - 6 #define GA_TYPE_GOP 32760 - 7 #if defined(CRAY) # define ALIGN 512 #else # define ALIGN 16 #endif #define INFINITE_NUM_PROCS 8094 #define CLIENT_TO_SERVER 2 #ifdef PARAGON # define DRA_NUM_IOPROCS 64 # define DRA_NUM_FILE_MGR INFINITE_NUM_PROCS #elif defined(CRAY_T3D) # define DRA_NUM_IOPROCS 16 #elif defined(CRAY_YMP) # define DRA_NUM_IOPROCS 4 #elif defined(SP1)|| defined(SP) || defined(LAPI) # define DRA_NUM_IOPROCS 8 #elif defined(KSR) # define DRA_NUM_IOPROCS 8 #else # define DRA_NUM_IOPROCS 1 #endif #ifndef DRA_NUM_FILE_MGR # define DRA_NUM_FILE_MGR DRA_NUM_IOPROCS #endif #define DRA_BUF_SIZE (DRA_DBL_BUF_SIZE*sizeof(DoublePrecision)) #define DRA_INT_BUF_SIZE (DRA_BUF_SIZE/sizeof(Integer)) int _dra_buffer_index = 0; #ifdef STATBUF DoublePrecision _dra_dbl_buffer[DRA_DBL_BUF_SIZE]; # ifdef DRA_DBLE_BUFFER DoublePrecision _dra_dbl_buffer_2[DRA_DBL_BUF_SIZE]; # endif #else Integer _idx_buffer, _handle_buffer; #endif disk_array_t *DRA; Integer _max_disk_array; logical dra_debug_flag; request_t Requests[MAX_REQ]; int num_pending_requests=0; Integer _dra_turn=0; int Dra_num_serv=DRA_NUM_IOPROCS; buffer_t _dra_buffer_state[2]; #ifdef STATBUF # ifdef DRA_DBLE_BUFFER _dra_buffer_state[0].buffer = (char*)_dra_dbl_buffer; _dra_buffer_state[1].buffer = (char*)_dra_dbl_buffer_2; # else _dra_buffer_state.buffer = (char*)_dra_dbl_buffer; # endif #endif #define dai_sizeofM(_type) MA_sizeof(_type, 1, MT_C_CHAR) #define dai_check_typeM(_type) if (_type != C_DBL && _type != C_INT \ && _type != C_LONG && _type != C_DCPL && _type != C_FLOAT) \ dai_error("invalid type ",_type) #define dai_check_handleM(_handle, msg) \ {\ if((_handle+DRA_OFFSET)>=_max_disk_array || (_handle+DRA_OFFSET)<0) \ {fprintf(stderr,"%s, %ld --",msg, (long)_max_disk_array);\ dai_error("invalid DRA handle",_handle);} \ if( DRA[(_handle+DRA_OFFSET)].actv == 0) \ {fprintf(stderr,"%s:",msg);\ dai_error("disk array not active",_handle);} \ } #define dai_check_rangeM(_lo, _hi, _dim, _err_msg) \ if(_lo < (Integer)1 || _lo > _dim ||_hi < _lo || _hi > _dim) \ dai_error(_err_msg, _dim) #define ga_get_sectM(sect, _buf, _ld)\ ga_get_(&sect.handle, &sect.lo[0], &sect.hi[0], &sect.lo[1], &sect.hi[1], _buf, &_ld) #define ga_put_sectM(sect, _buf, _ld)\ ga_put_(&sect.handle, &sect.lo[0], &sect.hi[0], &sect.lo[1], &sect.hi[1], _buf, &_ld) #define fill_sectionM(sect, _hndl, _ilo, _ihi, _jlo, _jhi) \ { \ sect.handle = _hndl;\ sect.ndim = 2; \ sect.lo[0] = _ilo;\ sect.hi[0] = _ihi;\ sect.lo[1] = _jlo;\ sect.hi[1] = _jhi;\ } #define sect_to_blockM(ds_a, CR)\ {\ Integer hndl = (ds_a).handle+DRA_OFFSET;\ Integer br = ((ds_a).lo[0]-1)/DRA[hndl].chunk[0];\ Integer bc = ((ds_a).lo[1]-1)/DRA[hndl].chunk[1];\ Integer R = (DRA[hndl].dims[0] + DRA[hndl].chunk[0] -1)/DRA[hndl].chunk[0];\ *(CR) = bc * R + br;\ } #define block_to_sectM(ds_a, CR)\ {\ Integer hndl = (ds_a)->handle+DRA_OFFSET;\ Integer R = (DRA[hndl].dims[0] + DRA[hndl].chunk[0]-1)/DRA[hndl].chunk[0];\ Integer br = (CR)%R;\ Integer bc = ((CR) - br)/R;\ (ds_a)-> lo[0]= br * DRA[hndl].chunk[0] +1;\ (ds_a)-> lo[1]= bc * DRA[hndl].chunk[1] +1;\ (ds_a)-> hi[0]= (ds_a)->lo[0] + DRA[hndl].chunk[0];\ (ds_a)-> hi[1]= (ds_a)->lo[1] + DRA[hndl].chunk[1];\ if( (ds_a)->hi[0] > DRA[hndl].dims[0]) (ds_a)->hi[0] = DRA[hndl].dims[0];\ if( (ds_a)->hi[1] > DRA[hndl].dims[1]) (ds_a)->hi[1] = DRA[hndl].dims[1];\ } #define INDEPFILES(x) (DRA[(x)+DRA_OFFSET].indep) char dummy_fname[DRA_MAX_FNAME]; int dai_write_allowed(Integer d_a) { Integer handle = d_a+DRA_OFFSET; if(DRA[handle].mode == DRA_W || DRA[handle].mode == DRA_RW) return 1; else return 0; } int dai_read_allowed(Integer d_a) { Integer handle = d_a+DRA_OFFSET; if(DRA[handle].mode == DRA_R || DRA[handle].mode == DRA_RW) return 1; else return 0; } Integer dai_io_procs(Integer d_a) { Integer num; num = ga_cluster_nnodes_(); return( MIN( ga_nnodes_(), num)); } Integer dai_io_nodeid(Integer d_a) { Integer me = ga_nodeid_(); Integer nodeid = ga_cluster_nodeid_(); Integer zero = 0; if(me == ga_cluster_procid_(&nodeid, &zero)) me = nodeid; else me = -1; return (me); } Integer dai_io_manage(Integer d_a) { Integer me = dai_io_nodeid(d_a); if(me >= 0 ) return (1); else return (0); } Integer dai_file_master(Integer d_a) { if(dai_io_nodeid(d_a)<0)return 0; if(INDEPFILES(d_a) || dai_io_nodeid(d_a) == 0 ) return 1; else return 0; } void dai_callback(int op, int transp, section_t gs_a, section_t ds_a, section_t ds_chunk, Integer ld[], int ibuf, Integer req) { Integer i; #if WALLTIME double ss0,tt0; #endif if (Requests[req].callback==ON) dai_error("DRA: callback not cleared",0); #if WALLTIME walltime_(&ss0,&tt0); printf("p[%d] Creating callback for buffer %d: %16.6f\n", ga_nodeid_(),ibuf,tt0); #endif Requests[req].callback = ON; Requests[req].ibuf = ibuf; _dra_buffer_state[ibuf].args.op = op; _dra_buffer_state[ibuf].args.transp = transp; _dra_buffer_state[ibuf].args.gs_a = gs_a; _dra_buffer_state[ibuf].args.ds_a = ds_a; _dra_buffer_state[ibuf].args.ds_chunk = ds_chunk; for (i=0; i<gs_a.ndim-1; i++) _dra_buffer_state[ibuf].args.ld[i] = ld[i]; } Integer FATR dra_init_( Integer *max_arrays, DoublePrecision *max_array_size, DoublePrecision *tot_disk_space, DoublePrecision *max_memory) { #define DEF_MAX_ARRAYS 16 #define MAX_ARRAYS 1024 int i; ga_sync_(); if(*max_arrays<-1 || *max_arrays> MAX_ARRAYS) dai_error("dra_init: incorrect max number of arrays",*max_arrays); _max_disk_array = (*max_arrays==-1) ? DEF_MAX_ARRAYS: *max_arrays; Dra_num_serv = drai_get_num_serv(); DRA = (disk_array_t*)malloc(sizeof(disk_array_t)* (int)*max_arrays); if(!DRA) dai_error("dra_init: memory alocation failed\n",0); for(i=0; i<_max_disk_array ; i++)DRA[i].actv=0; for(i=0; i<MAX_REQ; i++)Requests[i].num_pending=0; dra_debug_flag = FALSE; #ifndef STATBUF { Integer avail = MA_inquire_avail(MT_C_DBL); long diff; ga_igop(GA_TYPE_GOP, &avail, (Integer)1, "min"); if(avail < (ALIGN -1 + DRA_DBL_BUF_SIZE) && ga_nodeid_() == 0) dai_error("Not enough memory available from MA for DRA",avail); if(MA_alloc_get(MT_C_DBL, DRA_DBL_BUF_SIZE+ALIGN-1, "DRA buf 0", &_handle_buffer, &_idx_buffer)) MA_get_pointer(_handle_buffer, &_dra_buffer_state[0].buffer); else dai_error("dra_init: ma_alloc_get failed",DRA_DBL_BUF_SIZE); #ifdef DRA_DBL_BUFFER if(MA_alloc_get(MT_C_DBL, DRA_DBL_BUF_SIZE+ALIGN-1, "DRA buf 1", &_handle_buffer, &_idx_buffer)) MA_get_pointer(_handle_buffer, &_dra_buffer_state[1].buffer); else dai_error("dra_init: ma_alloc_get failed",DRA_DBL_BUF_SIZE); #endif diff = ((long)_dra_buffer_state[0].buffer) % (sizeof(DoublePrecision)*ALIGN); if(diff) _dra_buffer_state[0].buffer += (sizeof(DoublePrecision)*ALIGN - diff); diff = ((long)_dra_buffer_state[1].buffer) % (sizeof(DoublePrecision)*ALIGN); if(diff) _dra_buffer_state[1].buffer += (sizeof(DoublePrecision)*ALIGN - diff); } #endif _dra_buffer_state[0].id = ELIO_DONE; _dra_buffer_state[1].id = ELIO_DONE; _dra_buffer_state[0].args.gs_a.handle = 0; _dra_buffer_state[1].args.gs_a.handle = 0; ga_sync_(); return(ELIO_OK); } void dai_correct_chunking(Integer* a, Integer* b, Integer prod, double ratio) { #define EPS_SEARCH 100 Integer b0, bt, eps0, eps1, trial; double da = (double)*a, db = (double)*b; double ch_ratio = da/db; db = sqrt(prod /ch_ratio); trial = b0 = (Integer)db; eps0 = prod%b0; trial = MAX(trial,EPS_SEARCH); for (bt = trial+ EPS_SEARCH; bt> MIN(1,trial-EPS_SEARCH); bt--){ eps1 = prod%bt; if(eps1 < eps0){ b0 = bt; eps0 = eps1; } } *a = prod/b0; *b = b0; } void dai_chunking(Integer elem_size, Integer block1, Integer block2, Integer dim1, Integer dim2, Integer *chunk1, Integer *chunk2) { Integer patch_size; *chunk1 = *chunk2 =0; if(block1 <= 0 && block2 <= 0){ *chunk1 = dim1; *chunk2 = dim2; }else if(block1 <= 0){ *chunk2 = block2; *chunk1 = MAX(1, DRA_BUF_SIZE/(elem_size* (*chunk2))); }else if(block2 <= 0){ *chunk1 = block1; *chunk2 = MAX(1, DRA_BUF_SIZE/(elem_size* (*chunk1))); }else{ *chunk1 = block1; *chunk2 = block2; } patch_size = (*chunk1)* (*chunk2)*elem_size; if (patch_size > DRA_BUF_SIZE){ if( *chunk1 == 1) *chunk2 = DRA_BUF_SIZE/elem_size; else if( *chunk2 == 1) *chunk1 = DRA_BUF_SIZE/elem_size; else { double ratio = ((double)patch_size)/((double)DRA_BUF_SIZE); if(*chunk1 < *chunk2){ dai_correct_chunking(chunk2,chunk1,DRA_BUF_SIZE/elem_size,ratio); }else{ dai_correct_chunking(chunk1,chunk2,DRA_BUF_SIZE/elem_size,ratio); } } } # ifdef DEBUG printf("\n%d:CREATE chunk=(%d,%d) elem_size=%d req=(%d,%d) buf=%d\n", ga_nodeid_(),*chunk1, *chunk2, elem_size, block1, block2, DRA_DBL_BUF_SIZE); fflush(stdout); # endif } Integer dai_get_handle(void) { Integer dra_handle =-1, candidate = 0; do{ if(!DRA[candidate].actv){ dra_handle=candidate; DRA[candidate].actv =1; } candidate++; }while(candidate < _max_disk_array && dra_handle == -1); return(dra_handle); } void dai_release_handle(Integer *handle) { DRA[*handle+DRA_OFFSET].actv =0; *handle = 0; } void dai_file_location(section_t ds_a, Off_t* offset) { Integer row_blocks, handle=ds_a.handle+DRA_OFFSET, offelem, cur_ld, part_chunk1; if((ds_a.lo[0]-1)%DRA[handle].chunk[0]) dai_error("dai_file_location: not alligned ??",ds_a.lo[0]); row_blocks = (ds_a.lo[0]-1)/DRA[handle].chunk[0]; part_chunk1 = DRA[handle].dims[0]%DRA[handle].chunk[0]; cur_ld = (row_blocks == DRA[handle].dims[0] / DRA[handle].chunk[0]) ? part_chunk1: DRA[handle].chunk[0]; if(INDEPFILES(ds_a.handle)) { Integer CR, R; Integer i, num_part_block = 0; Integer ioprocs=dai_io_procs(ds_a.handle); Integer iome = dai_io_nodeid(ds_a.handle); sect_to_blockM(ds_a, &CR); R = (DRA[handle].dims[0] + DRA[handle].chunk[0]-1)/DRA[handle].chunk[0]; for(i = R -1; i< CR; i+=R) if(i%ioprocs == iome)num_part_block++; if(!part_chunk1) part_chunk1=DRA[handle].chunk[0]; offelem = ((CR/ioprocs - num_part_block)*DRA[handle].chunk[0] + num_part_block * part_chunk1 ) * DRA[handle].chunk[1]; offelem += ((ds_a.lo[1]-1) %DRA[handle].chunk[1])*cur_ld; } else { offelem = row_blocks * DRA[handle].dims[1] * DRA[handle].chunk[0]; offelem += (ds_a.lo[1]-1)*cur_ld; } *offset = offelem* dai_sizeofM(DRA[handle].type); } void dai_put( section_t ds_a, Void *buf, Integer ld, io_request_t *id) { Integer handle = ds_a.handle + DRA_OFFSET, elem; Off_t offset; Size_t bytes; dai_file_location(ds_a, &offset); if((ds_a.hi[0] - ds_a.lo[0] + 1) != ld) dai_error("dai_put: bad ld",ld); elem = (ds_a.hi[0] - ds_a.lo[0] + 1) * (ds_a.hi[1] - ds_a.lo[1] + 1); bytes= (Size_t) elem * dai_sizeofM(DRA[handle].type); if( ELIO_OK != elio_awrite(DRA[handle].fd, offset, buf, bytes, id )) dai_error("dai_put failed", ds_a.handle); } void dai_zero_eof(Integer d_a) { Integer handle = d_a+DRA_OFFSET, nelem; char byte; Off_t offset; byte = (char)0; if(INDEPFILES(d_a)) { Integer CR, i, nblocks; section_t ds_a; Integer ioprocs=dai_io_procs(d_a); Integer iome = dai_io_nodeid(d_a); nblocks = ((DRA[handle].dims[0] + DRA[handle].chunk[0]-1)/DRA[handle].chunk[0]) * ((DRA[handle].dims[1] + DRA[handle].chunk[1]-1)/DRA[handle].chunk[1]); fill_sectionM(ds_a, d_a, 0, 0, 0, 0); for(i = 0; i <ioprocs; i++){ CR = nblocks - 1 -i; if(CR % ioprocs == iome) break; } if(CR<0) return; block_to_sectM(&ds_a, CR); dai_file_location(ds_a, &offset); nelem = (ds_a.hi[0] - ds_a.lo[0] +1)*(ds_a.hi[1] - ds_a.lo[1] +1); offset += ((Off_t)nelem) * dai_sizeofM(DRA[handle].type); # ifdef DEBUG printf("me=%d zeroing EOF (%d) at %ld bytes \n",iome,CR,offset); # endif } else { nelem = DRA[handle].dims[0]*DRA[handle].dims[1]; offset = ((Off_t)nelem) * dai_sizeofM(DRA[handle].type); } if(elio_write(DRA[handle].fd, offset-1, &byte, 1) != (Size_t)1) dai_error("dai_zero_eof: write error ",0); } void dai_get(section_t ds_a, Void *buf, Integer ld, io_request_t *id) { Integer handle = ds_a.handle + DRA_OFFSET, elem, rc; Off_t offset; Size_t bytes; void dai_clear_buffer(); dai_file_location(ds_a, &offset); # ifdef CLEAR_BUF dai_clear_buffer(); # endif if((ds_a.hi[0] - ds_a.lo[0] + 1) != ld) dai_error("dai_get: bad ld",ld); elem = (ds_a.hi[0] - ds_a.lo[0] + 1) * (ds_a.hi[1] - ds_a.lo[1] + 1); bytes= (Size_t) elem * dai_sizeofM(DRA[handle].type); rc= elio_aread(DRA[handle].fd, offset, buf, bytes, id ); if(rc != ELIO_OK) dai_error("dai_get failed", rc); } void dai_assign_request_handle(Integer* request) { int i; *request = -1; for(i=0;i<MAX_REQ;i++)if(Requests[i].num_pending==0){ *request = i; break; } for(i=0;i<MAX_REQ;i++) Requests[i].ibuf = -1; if(*request ==-1) dai_error("DRA: number of pending I/O requests exceeded",MAX_REQ); Requests[*request].na=0; Requests[*request].nu=0; Requests[*request].ibuf=-1; Requests[*request].callback = OFF; Requests[i].num_pending = ON; } Integer dra_create( Integer *type, Integer *dim1, Integer *dim2, char *name, char *filename, Integer *mode, Integer *reqdim1, Integer *reqdim2, Integer *d_a) { Integer handle, elem_size, ctype; ctype = (Integer)ga_type_f2c((int)(*type)); ga_sync_(); dai_check_typeM(ctype); if( *dim1 <= 0 ) dai_error("dra_create: disk array dimension1 invalid ", *dim1); else if( *dim2 <= 0) dai_error("dra_create: disk array dimension2 invalid ", *dim2); if(strlen(filename)>DRA_MAX_FNAME) dai_error("dra_create: filename too long", DRA_MAX_FNAME); if( (handle = dai_get_handle()) == -1) dai_error("dai_create: too many disk arrays ", _max_disk_array); *d_a = handle - DRA_OFFSET; elem_size = dai_sizeofM(ctype); dai_chunking( elem_size, *reqdim1, *reqdim2, *dim1, *dim2, &DRA[handle].chunk[0], &DRA[handle].chunk[1]); DRA[handle].layout = COLUMN; DRA[handle].dims[0] = *dim1; DRA[handle].dims[1] = *dim2; DRA[handle].ndim = 2; DRA[handle].type = ctype; DRA[handle].mode = (int)*mode; strncpy (DRA[handle].fname, filename, DRA_MAX_FNAME); strncpy(DRA[handle].name, name, DRA_MAX_NAME ); dai_write_param(DRA[handle].fname, *d_a); DRA[handle].indep = dai_file_config(filename); if(dai_io_manage(*d_a)){ if (INDEPFILES(*d_a)) { sprintf(dummy_fname,"%s.%ld",DRA[handle].fname,(long)dai_io_nodeid(*d_a)); DRA[handle].fd = elio_open(dummy_fname,(int)*mode, ELIO_PRIVATE); }else{ # ifdef PARAGON DRA[handle].fd = elio_gopen(DRA[handle].fname,(int)*mode); # else DRA[handle].fd = elio_open(DRA[handle].fname,(int)*mode, ELIO_SHARED); # endif } if(DRA[handle].fd==NULL)dai_error("dra_create:failed to open file",0); if(DRA[handle].fd->fd==-1)dai_error("dra_create:failed to open file",0); } ga_sync_(); if(dai_file_master(*d_a) && dai_write_allowed(*d_a)) dai_zero_eof(*d_a); ga_sync_(); return(ELIO_OK); } Integer dra_open( char *filename, Integer *mode, Integer *d_a) { Integer handle; ga_sync_(); if( (handle = dai_get_handle()) == -1) dai_error("dra_open: too many disk arrays ", _max_disk_array); *d_a = handle - DRA_OFFSET; DRA[handle].mode = (int)*mode; strncpy (DRA[handle].fname, filename, DRA_MAX_FNAME); if(dai_read_param(DRA[handle].fname, *d_a))return((Integer)-1); DRA[handle].indep = dai_file_config(filename); if(dai_io_manage(*d_a)){ if (INDEPFILES(*d_a)) { sprintf(dummy_fname,"%s.%ld",DRA[handle].fname,(long)dai_io_nodeid(*d_a)); DRA[handle].fd = elio_open(dummy_fname,(int)*mode, ELIO_PRIVATE); }else{ # ifdef PARAGON DRA[handle].fd = elio_gopen(DRA[handle].fname,(int)*mode); # else DRA[handle].fd = elio_open(DRA[handle].fname,(int)*mode, ELIO_SHARED); # endif } if(DRA[handle].fd ==NULL)dai_error("dra_open failed (null)", ga_nodeid_()); if(DRA[handle].fd->fd ==-1)dai_error("dra_open failed (-1)", ga_nodeid_()); } # ifdef DEBUG printf("\n%d:OPEN chunking=(%d,%d) type=%d buf=%d\n", ga_nodeid_(),DRA[handle].chunk[0], DRA[handle].chunk[1], DRA[handle].type, DRA_DBL_BUF_SIZE); fflush(stdout); # endif ga_sync_(); return(ELIO_OK); } Integer FATR dra_close_(Integer* d_a) { Integer handle = *d_a+DRA_OFFSET; int rc; ga_sync_(); dai_check_handleM(*d_a, "dra_close"); if(dai_io_manage(*d_a)) if(ELIO_OK != (rc=elio_close(DRA[handle].fd))) dai_error("dra_close: close failed",rc); dai_release_handle(d_a); ga_sync_(); return(ELIO_OK); } void dai_decomp_section( section_t ds_a, Integer aligned[][2*MAXDIM], int *na, Integer cover[][2*MAXDIM], Integer unaligned[][2*MAXDIM], int *nu) { Integer a=0, u=0, handle = ds_a.handle+DRA_OFFSET, off, chunk_units, algn_flag; aligned[a][ ILO ] = ds_a.lo[0]; aligned[a][ IHI ] = ds_a.hi[0]; aligned[a][ JLO ] = ds_a.lo[1]; aligned[a][ JHI ] = ds_a.hi[1]; switch (DRA[handle].layout){ case COLUMN : algn_flag = ON; off = (ds_a.lo[0] -1) % DRA[handle].chunk[0]; if(off){ if(MAX_UNLG<= u) dai_error("dai_decomp_sect:insufficient nu",u); chunk_units = (ds_a.lo[0] -1) / DRA[handle].chunk[0]; cover[u][ ILO ] = chunk_units*DRA[handle].chunk[0] + 1; cover[u][ IHI ] = MIN(cover[u][ ILO ] + DRA[handle].chunk[0]-1, DRA[handle].dims[0]); unaligned[u][ ILO ] = ds_a.lo[0]; unaligned[u][ IHI ] = MIN(ds_a.hi[0],cover[u][ IHI ]); unaligned[u][ JLO ] = cover[u][ JLO ] = ds_a.lo[1]; unaligned[u][ JHI ] = cover[u][ JHI ] = ds_a.hi[1]; if(cover[u][ IHI ] < ds_a.hi[0]){ if(MAX_ALGN<=a) dai_error("dai_decomp_sect: na too small",a); aligned[a][ ILO ] = cover[u][ IHI ]+1; }else{ algn_flag = OFF; } u++; } off = ds_a.hi[0] % DRA[handle].chunk[0]; if(off && (ds_a.hi[0] != DRA[handle].dims[0]) && (algn_flag == ON)){ if(MAX_UNLG<=u) dai_error("dai_decomp_sect:insufficient nu",u); chunk_units = ds_a.hi[0] / DRA[handle].chunk[0]; cover[u][ ILO ] = chunk_units*DRA[handle].chunk[0] + 1; cover[u][ IHI ] = MIN(cover[u][ ILO ] + DRA[handle].chunk[0]-1, DRA[handle].dims[0]); unaligned[u][ ILO ] = cover[u][ ILO ]; unaligned[u][ IHI ] = ds_a.hi[0]; unaligned[u][ JLO ] = cover[u][ JLO ] = ds_a.lo[1]; unaligned[u][ JHI ] = cover[u][ JHI ] = ds_a.hi[1]; aligned[a][ IHI ] = MAX(1,unaligned[u][ ILO ]-1); algn_flag=(DRA[handle].chunk[0] == DRA[handle].dims[0])?OFF:ON; u++; } *nu = (int)u; if(aligned[0][ IHI ]-aligned[0][ ILO ] < 0) algn_flag= OFF; *na = (algn_flag== OFF)? 0: 1; break; case ROW : default: dai_error("dai_decomp_sect: ROW layout not yet implemented", DRA[handle].layout); } } Integer FATR dra_write_( Integer *g_a, Integer *d_a, Integer *request) { Integer gdim1, gdim2, gtype, handle=*d_a+DRA_OFFSET; logical transp = FALSE; Integer ilo, ihi, jlo, jhi; ga_sync_(); dai_check_handleM(*d_a,"dra_write"); if( !dai_write_allowed(*d_a)) dai_error("dra_write: write not allowed to this array",*d_a); ga_inquire_internal_(g_a, &gtype, &gdim1, &gdim2); if(DRA[handle].type != (int)gtype)dai_error("dra_write: type mismatch",gtype); if(DRA[handle].dims[0] != gdim1)dai_error("dra_write: dim1 mismatch",gdim1); if(DRA[handle].dims[1] != gdim2)dai_error("dra_write: dim2 mismatch",gdim2); ilo = 1; ihi = DRA[handle].dims[0]; jlo = 1; jhi = DRA[handle].dims[1]; return(dra_write_section_(&transp, g_a, &ilo, &ihi, &jlo, &jhi, d_a, &ilo, &ihi, &jlo, &jhi,request)); } int dai_next2d(Integer* i, Integer imin, Integer imax, Integer iinc, Integer* o, Integer omin, Integer omax, Integer oinc) { int retval; if (*o == 0 || *i == 0) { *o = omin; *i = imin; } else { *i = *i + iinc; } if (*i > imax) { *i = imin; *o += oinc; } retval = (*o <= omax); return retval; } int dai_next_chunk(Integer req, Integer* list, section_t* ds_chunk) { Integer handle = ds_chunk->handle+DRA_OFFSET; int retval; if(INDEPFILES(ds_chunk->handle)) if(ds_chunk->lo[1] && DRA[handle].chunk[1]>1) ds_chunk->lo[1] -= (ds_chunk->lo[1] -1) % DRA[handle].chunk[1]; retval = dai_next2d(&ds_chunk->lo[0], list[ ILO ], list[ IHI ], DRA[handle].chunk[0], &ds_chunk->lo[1], list[ JLO ], list[ JHI ], DRA[handle].chunk[1]); if(!retval) return(retval); ds_chunk->hi[0] = MIN(list[ IHI ], ds_chunk->lo[0] + DRA[handle].chunk[0] -1); ds_chunk->hi[1] = MIN(list[ JHI ], ds_chunk->lo[1] + DRA[handle].chunk[1] -1); if(INDEPFILES(ds_chunk->handle)) { Integer jhi_temp = ds_chunk->lo[1] + DRA[handle].chunk[1] -1; jhi_temp -= jhi_temp % DRA[handle].chunk[1]; ds_chunk->hi[1] = MIN(ds_chunk->hi[1], jhi_temp); if(ds_chunk->lo[1] < list[ JLO ]) ds_chunk->lo[1] = list[ JLO ]; } return 1; } #define nsect_to_blockM(ds_a, CR) \ { \ Integer hndl = (ds_a).handle+DRA_OFFSET;\ Integer _i, _ndim = DRA[hndl].ndim; \ Integer _R, _b; \ *(CR) = 0; \ _R = 0; \ for (_i=_ndim-1; _i >= 0; _i--) { \ _b = ((ds_a).lo[_i]-1)/DRA[hndl].chunk[_i]; \ _R = (DRA[hndl].dims[_i]+DRA[hndl].chunk[_i]-1)/DRA[hndl].chunk[_i];\ *(CR) = *(CR) * _R + _b; \ } \ } int dai_myturn(section_t ds_chunk) { Integer ioprocs = dai_io_procs(ds_chunk.handle); Integer iome = dai_io_nodeid(ds_chunk.handle); if(INDEPFILES(ds_chunk.handle)){ nsect_to_blockM(ds_chunk, &_dra_turn); }else{ _dra_turn++; } return ((_dra_turn%ioprocs) == iome); } #define LOAD 1 #define STORE 2 #define TRANS 1 #define NOTRANS 0 void dai_print_buf(buf, ld, rows, cols) Integer ld, rows,cols; double *buf; { int i,j; printf("\n ld=%ld rows=%ld cols=%ld\n",ld,rows,cols); for (i=0; i<rows; i++){ for (j=0; j<cols; j++) printf("%f ", buf[j*ld+i]); printf("\n"); } } void dra_set_mode_(Integer* val) { } #define dai_dest_indices_1d_M(index, id, jd, ilod, jlod, ldd) \ { \ Integer _index_;\ _index_ = (is)-(ilos);\ *(id) = (_index_)%(ldd) + (ilod);\ *(jd) = (_index_)/(ldd) + (jlod);\ } #define dai_dest_indicesM(is, js, ilos, jlos, lds, id, jd, ilod, jlod, ldd)\ { \ Integer _index_;\ _index_ = (lds)*((js)-(jlos)) + (is)-(ilos);\ *(id) = (_index_)%(ldd) + (ilod);\ *(jd) = (_index_)/(ldd) + (jlod);\ } void ga_move_1d(int op, section_t gs_a, section_t ds_a, section_t ds_chunk, void* buffer, Integer ldb) { Integer index, ldd = gs_a.hi[0] - gs_a.lo[0] + 1, one=1; Integer atype, cols, rows, elemsize, ilo, ihi, jlo, jhi; Integer istart, iend, jstart, jend; void (FATR *f)(Integer*,Integer*,Integer*,Integer*,Integer*,void*,Integer*); char *buf = (char*)buffer; if(op==LOAD) f = ga_get_; else f = ga_put_; ga_inquire_(&gs_a.handle, &atype, &rows, &cols); elemsize = MA_sizeof(atype, 1, MT_C_CHAR); index = ds_chunk.lo[0] - ds_a.lo[0]; istart = index%ldd + gs_a.lo[0]; jstart = index/ldd + gs_a.lo[1]; index = ds_chunk.hi[0] - ds_a.lo[0]; iend = index%ldd + gs_a.lo[0]; jend = index/ldd + gs_a.lo[1]; if(istart != gs_a.lo[0] || jstart==jend ){ ilo = istart; ihi = gs_a.hi[0]; if(jstart==jend) ihi=iend; f(&gs_a.handle, &ilo, &ihi, &jstart, &jstart, buf, &one); buf += elemsize*(ihi -ilo+1); if(jstart==jend) return; jstart++; } if(iend != gs_a.hi[0]) jend--; if(jstart <= jend) { f(&gs_a.handle, &gs_a.lo[0], &gs_a.hi[0], &jstart, &jend, buf, &ldd); buf += elemsize*ldd*(jend-jstart+1); } if(iend != gs_a.hi[0]){ jend++; f(&gs_a.handle, &gs_a.lo[0], &iend, &jend, &jend, buf, &one); } } void ga_move(int op, int trans, section_t gs_a, section_t ds_a, section_t ds_chunk, void* buffer, Integer ldb) { if(!trans && (gs_a.lo[0]- gs_a.hi[0] == ds_a.lo[0]- ds_a.hi[0]) ){ section_t gs_chunk = gs_a; dai_dest_indicesM(ds_chunk.lo[0], ds_chunk.lo[1], ds_a.lo[0], ds_a.lo[1], ds_a.hi[0]-ds_a.lo[0]+1, &gs_chunk.lo[0], &gs_chunk.lo[1], gs_a.lo[0], gs_a.lo[1], gs_a.hi[0] - gs_a.lo[0] + 1); dai_dest_indicesM(ds_chunk.hi[0], ds_chunk.hi[1], ds_a.lo[0], ds_a.lo[1], ds_a.hi[0]-ds_a.lo[0]+1, &gs_chunk.hi[0], &gs_chunk.hi[1], gs_a.lo[0], gs_a.lo[1], gs_a.hi[0] - gs_a.lo[0] + 1); if(op==LOAD) ga_get_sectM(gs_chunk, buffer, ldb); else ga_put_sectM(gs_chunk, buffer, ldb); #ifdef MOVE1D_ENABLED }else if(!trans && (ds_a.lo[1]==ds_a.hi[1]) ){ ga_move_1d(op, gs_a, ds_a, ds_chunk, buffer, ldb); #endif }else{ Integer ihandle, jhandle, vhandle, iindex, jindex, vindex; Integer pindex, phandle; int type = DRA[ds_a.handle+DRA_OFFSET].type; Integer i, j, ii, jj, base,nelem; char *base_addr; # define ITERATOR_2D(i,j, base, ds_chunk)\ for(j = ds_chunk.lo[1], base=0, jj=0; j<= ds_chunk.hi[1]; j++,jj++)\ for(i = ds_chunk.lo[0], ii=0; i<= ds_chunk.hi[0]; i++,ii++,base++) # define COPY_SCATTER(ADDR_BASE, TYPE, ds_chunk)\ ITERATOR_2D(i,j, base, ds_chunk) \ ADDR_BASE[base+vindex] = ((TYPE*)buffer)[ldb*jj + ii] # define COPY_GATHER(ADDR_BASE, TYPE, ds_chunk)\ for(i=0; i< nelem; i++){\ Integer ldc = ds_chunk.hi[0] - ds_chunk.lo[0]+1;\ base = INT_MB[pindex+i]; jj = base/ldc; ii = base%ldc;\ ((TYPE*)buffer)[ldb*jj + ii] = ADDR_BASE[i+vindex];\ } # define COPY_TYPE(OPERATION, MATYPE, ds_chunk)\ switch(MATYPE){\ case C_DBL: COPY_ ## OPERATION(DBL_MB,double,ds_chunk);break;\ case C_INT: COPY_ ## OPERATION(INT_MB, int, ds_chunk); break;\ case C_DCPL: COPY_ ## OPERATION(DCPL_MB, DoubleComplex, ds_chunk);break;\ case C_FLOAT: COPY_ ## OPERATION(FLT_MB, float, ds_chunk);\ } if(ga_nodeid_()==0) printf("DRA warning: using scatter/gather\n"); nelem = (ds_chunk.hi[0]-ds_chunk.lo[0]+1) * (ds_chunk.hi[1]-ds_chunk.lo[1]+1); if(!MA_push_get(C_INT, nelem, "i_", &ihandle, &iindex)) dai_error("DRA move: MA failed-i ", 0L); if(!MA_push_get(C_INT, nelem, "j_", &jhandle, &jindex)) dai_error("DRA move: MA failed-j ", 0L); if(!MA_push_get(type, nelem, "v_", &vhandle, &vindex)) dai_error("DRA move: MA failed-v ", 0L); if(!MA_get_pointer(vhandle, &base_addr)) dai_error("DRA move: MA get_pointer failed ", 0L); if(trans==TRANS) ITERATOR_2D(i,j, base, ds_chunk) { dai_dest_indicesM(j, i, ds_a.lo[0], ds_a.lo[1], ds_a.hi[0]-ds_a.lo[0]+1, INT_MB+base+iindex, INT_MB+base+jindex, gs_a.lo[0], gs_a.lo[1], gs_a.hi[0] - gs_a.lo[0] + 1); } else ITERATOR_2D(i,j, base, ds_chunk) { dai_dest_indicesM(i, j, ds_a.lo[0], ds_a.lo[1], ds_a.hi[0]-ds_a.lo[0]+1, INT_MB+base+iindex, INT_MB+base+jindex, gs_a.lo[0], gs_a.lo[1], gs_a.hi[0] - gs_a.lo[0] + 1); } if(op==LOAD){ if(!MA_push_get(C_INT, nelem, "pindex", &phandle, &pindex)) dai_error("DRA move: MA failed-p ", 0L); for(i=0; i< nelem; i++) INT_MB[pindex+i] = i; ga_sort_permut_(&gs_a.handle, INT_MB+pindex, INT_MB+iindex, INT_MB+jindex, &nelem); ga_gather_(&gs_a.handle, base_addr, INT_MB+iindex, INT_MB+jindex, &nelem); COPY_TYPE(GATHER, type, ds_chunk); MA_pop_stack(phandle); }else{ COPY_TYPE(SCATTER, type, ds_chunk); ga_scatter_(&gs_a.handle, base_addr, INT_MB+iindex, INT_MB+jindex, &nelem); } MA_pop_stack(vhandle); MA_pop_stack(jhandle); MA_pop_stack(ihandle); } } #define nga_get_sectM(sect, _buf, _ld)\ nga_get_(&sect.handle, sect.lo, sect.hi, _buf, _ld) #define nga_put_sectM(sect, _buf, _ld)\ nga_put_(&sect.handle, sect.lo, sect.hi, _buf, _ld) #define ndai_dest_indicesM(ds_chunk, ds_a, gs_chunk, gs_a) \ {\ Integer _i; \ Integer _ndim = ds_a.ndim; \ for (_i=0; _i<_ndim; _i++) { \ gs_chunk.lo[_i] = gs_a.lo[_i] + ds_chunk.lo[_i]- ds_a.lo[_i]; \ gs_chunk.hi[_i] = gs_a.lo[_i] + ds_chunk.hi[_i]- ds_a.lo[_i]; \ } \ } #define ndai_trnsp_dest_indicesM(ds_chunk, ds_a, gs_chunk, gs_a) \ {\ Integer _i; \ Integer _ndim = ds_a.ndim; \ for (_i=0; _i<_ndim; _i++) { \ gs_chunk.lo[_ndim-1-_i] = gs_a.lo[_ndim-1-_i] \ + ds_chunk.lo[_i]- ds_a.lo[_i]; \ gs_chunk.hi[_ndim-1-_i] = gs_a.lo[_ndim-1-_i] \ + ds_chunk.hi[_i]- ds_a.lo[_i]; \ } \ } void nga_move(int op, int trans, section_t gs_a, section_t ds_a, section_t ds_chunk, void* buffer, Integer ldb[]) { Integer ndim = gs_a.ndim, i; logical consistent = TRUE; #if WALLTIME double ss0,tt0; walltime_(&ss0,&tt0); printf("p[%d] Beginning nga_move: %16.6f\n",ga_nodeid_(),tt0); #endif if (!trans) { for (i=0; i<ndim-1; i++) if (gs_a.lo[i]-gs_a.hi[i] != ds_a.lo[i]-ds_a.hi[i]) consistent = FALSE; } else { for (i=0; i<ndim-1; i++) if (gs_a.lo[ndim-1-i]-gs_a.hi[ndim-1-i] != ds_a.lo[i]-ds_a.hi[i]) consistent = FALSE; } if (!trans && consistent){ section_t gs_chunk = gs_a; ndai_dest_indicesM(ds_chunk, ds_a, gs_chunk, gs_a); consistent = TRUE; for (i=0; i<ndim; i++) { if (gs_chunk.hi[i]<gs_chunk.lo[i] || gs_chunk.lo[i]<0) { consistent = FALSE; } } if (!consistent) { for(i=0; i<ndim; i++) { printf("gs_chunk[%d] %5d:%5d ds_chunk[%d] %5d:%5d", (int)i,(int)gs_chunk.lo[i],(int)gs_chunk.hi[i], (int)i,(int)ds_chunk.lo[i],(int)ds_chunk.hi[i]); printf(" gs_a[%d] %5d:%5d ds_a[%d] %5d:%5d\n", (int)i,(int)gs_a.lo[i],(int)gs_a.hi[i], (int)i,(int)ds_a.lo[i],(int)ds_a.hi[i]); } } if (op==LOAD) { nga_get_sectM(gs_chunk, buffer, ldb); } else { nga_put_sectM(gs_chunk, buffer, ldb); } } else if (trans && consistent) { Integer vhandle, vindex, index[MAXDIM]; Integer i, j, itmp, jtmp, nelem, ldt[MAXDIM], ldg[MAXDIM]; Integer nelem1, nelem2, nelem3; int type = DRA[ds_a.handle+DRA_OFFSET].type; char *base_addr; section_t gs_chunk = gs_a; nelem = 1; for (i=0; i<ndim; i++) { nelem *= (ds_chunk.hi[i] - ds_chunk.lo[i] + 1); } nelem1 = 1; ndai_trnsp_dest_indicesM(ds_chunk, ds_a, gs_chunk, gs_a); for (i=1; i<ndim; i++) nelem1 *= (gs_chunk.hi[i] - gs_chunk.lo[i] + 1); nelem2 = 1; for (i=0; i<ndim-1; i++) nelem2 *= ldb[i]; if(!MA_push_get(type, nelem, "v_", &vhandle, &vindex)) dai_error("DRA move: MA failed-v ", 0L); if(!MA_get_pointer(vhandle, &base_addr)) dai_error("DRA move: MA get_pointer failed ", 0L); for (i=1; i<ndim; i++) ldt[ndim-1-i] = ds_chunk.hi[i] - ds_chunk.lo[i] + 1; if (op == LOAD) { for (i=0; i<ndim; i++) ldg[i] = gs_chunk.hi[i] - gs_chunk.lo[i] + 1; nga_get_sectM(gs_chunk, base_addr, ldg); for (i=0; i<nelem1; i++ ) { if (ndim > 1) { itmp = i; index[1] = itmp%ldg[1]; for (j=2; j<ndim; j++) { itmp = (itmp-index[j-1])/ldg[j-1]; if (j != ndim-1) { index[j] = itmp%ldg[j]; } else { index[j] = itmp; } } nelem3 = index[1]; for (j=2; j<ndim; j++) { nelem3 *= ldb[ndim-1-j]; nelem3 += index[j]; } } else { nelem2 = 1; nelem3 = 0; } itmp = ldg[0]*i; jtmp = nelem3; for (j=0; j<ldg[0]; j++) { switch(type){ case C_DBL: ((double*)buffer)[jtmp] = ((double*)base_addr)[itmp]; break; case C_INT: ((int*)buffer)[jtmp] = ((int*)base_addr)[itmp]; break; case C_LONG: ((long*)buffer)[jtmp] = ((long*)base_addr)[itmp]; break; case C_DCPL: ((double*)buffer)[2*jtmp] = ((double*)base_addr)[2*itmp]; ((double*)buffer)[2*jtmp+1] = ((double*)base_addr)[2*itmp+1]; break; case C_FLOAT: ((float*)buffer)[jtmp] = ((float*)base_addr)[itmp]; break; } itmp++; jtmp += nelem2; } } } else { for (i=0; i<ndim; i++) ldg[i] = gs_chunk.hi[i] - gs_chunk.lo[i] + 1; for (i=0; i<nelem1; i++ ) { if (ndim > 1) { itmp = i; index[1] = itmp%ldg[1]; for (j=2; j<ndim; j++) { itmp = (itmp-index[j-1])/ldg[j-1]; if (j != ndim-1) { index[j] = itmp%ldg[j]; } else { index[j] = itmp; } } nelem3 = index[1]; for (j=2; j<ndim; j++) { nelem3 *= ldb[ndim-1-j]; nelem3 += index[j]; } } else { nelem2 = 1; nelem3 = 0; } itmp = ldg[0]*i; jtmp = nelem3; for (j=0; j<ldg[0]; j++) { switch(type){ case C_DBL: ((double*)base_addr)[itmp] = ((double*)buffer)[jtmp]; break; case C_INT: ((int*)base_addr)[itmp] = ((int*)buffer)[jtmp]; break; case C_LONG: ((long*)base_addr)[itmp] = ((long*)buffer)[jtmp]; break; case C_DCPL: ((double*)base_addr)[2*itmp] = ((double*)buffer)[2*jtmp]; ((double*)base_addr)[2*itmp+1] = ((double*)buffer)[2*jtmp+1]; break; case C_FLOAT: ((float*)base_addr)[itmp] = ((float*)buffer)[jtmp]; break; } itmp++; jtmp += nelem2; } } nga_put_sectM(gs_chunk, base_addr, ldt); } MA_pop_stack(vhandle); } else { dai_error("DRA move: Inconsistent dimensions found ", 0L); } #if WALLTIME walltime_(&ss0,&tt0); printf("p[%d] Ending nga_move: %16.6f\n",ga_nodeid_(),tt0); #endif } void dai_exec_callback(request_t *request) { args_t *arg; int ibuf; char *buf; #if WALLTIME double ss0,tt0; #endif if(request->callback==OFF)return; request->callback = OFF; ibuf = request->ibuf; #if WALLTIME walltime(&ss0,&tt0); printf("p[%d] Executing callback for buffer %d: %16.6f\n", ga_nodeid_(),ibuf,tt0); #endif arg = &_dra_buffer_state[ibuf].args; if (arg->gs_a.handle == 0) return; buf = _dra_buffer_state[ibuf].buffer; nga_move(arg->op, arg->transp, arg->gs_a, arg->ds_a, arg->ds_chunk, buf, arg->ld); } void dai_wait(Integer req0) { Integer req; int ibuf; ibuf = Requests[req0].ibuf; for(req=0; req<MAX_REQ; req++) if (Requests[req].num_pending && Requests[req].ibuf == ibuf) if (elio_wait(&_dra_buffer_state[Requests[req].ibuf].id)==ELIO_OK) dai_exec_callback(Requests + req); else dai_error("dai_wait: DRA internal error",0); } void dai_wait_buf(int ibuf) { Integer req; #if WALLTIME double ss0,tt0; #endif #if WALLTIME walltime(&ss0,&tt0); printf("p[%d] Waiting for buffer %d: %16.6f\n", ga_nodeid_(),ibuf,tt0); #endif if (elio_wait(&_dra_buffer_state[ibuf].id)==ELIO_OK) { req = _dra_buffer_state[ibuf].req; dai_exec_callback(Requests + req); } else { dai_error("dai_wait: DRA internal error",0); } } void dai_transfer_unlgn(int opcode, int transp, section_t ds_a, section_t gs_a, Integer req) { Integer chunk_ld, next, offset; int type = DRA[ds_a.handle+DRA_OFFSET].type; section_t ds_chunk, ds_unlg; char *buf, *buffer; int ibuf; ds_chunk = ds_unlg = ds_a; for(next = 0; next < Requests[req].nu; next++){ ds_chunk.lo[0] = ds_chunk.lo[1] = 0; while(dai_next_chunk(req, Requests[req].list_cover[next],&ds_chunk)){ if(dai_myturn(ds_chunk)){ #ifdef DRA_DBLE_BUFFER ibuf = _dra_buffer_index; _dra_buffer_index = 1 - ibuf; #else _dra_buffer_index = 0; ibuf = 1; #endif _dra_buffer_state[_dra_buffer_index].req = req; dai_wait_buf(_dra_buffer_index); Requests[req].ibuf = _dra_buffer_index; ds_unlg.lo[0] = Requests[req].list_unlgn[next][ ILO ]; ds_unlg.hi[0] = Requests[req].list_unlgn[next][ IHI ]; ds_unlg.lo[1] = Requests[req].list_unlgn[next][ JLO ]; ds_unlg.hi[1] = Requests[req].list_unlgn[next][ JHI ]; if(!dai_section_intersect(ds_chunk, &ds_unlg)) dai_error("dai_transfer_unlgn: inconsistent cover",0); chunk_ld = ds_chunk.hi[0] - ds_chunk.lo[0] + 1; buf = (char*)_dra_buffer_state[_dra_buffer_index].buffer; dai_get(ds_chunk, buf, chunk_ld, &_dra_buffer_state[_dra_buffer_index].id); elio_wait(&_dra_buffer_state[_dra_buffer_index].id); offset = (ds_unlg.lo[1] - ds_chunk.lo[1])*chunk_ld + ds_unlg.lo[0] - ds_chunk.lo[0]; buffer = (char*)buf; buffer += offset * dai_sizeofM(type); switch (opcode){ case DRA_OP_WRITE: ga_move(LOAD, transp, gs_a, ds_a, ds_unlg, buffer, chunk_ld); dai_put(ds_chunk, buf, chunk_ld, &_dra_buffer_state[_dra_buffer_index].id); break; case DRA_OP_READ: ga_move(STORE, transp, gs_a, ds_a, ds_unlg, buffer, chunk_ld); break; default: dai_error("dai_transfer_unlg: invalid opcode",(Integer)opcode); } # ifdef DEBUG fprintf(stderr,"%d transf unlg g[%d:%d,%d:%d]-d[%d:%d,%d:%d]\n", dai_io_nodeid(), gs_chunk.lo[0], gs_chunk.hi[0], gs_chunk.lo[1], gs_chunk.hi[1], ds_unlg.lo[0], ds_unlg.hi[0], ds_unlg.lo[1], ds_unlg.hi[1]); # endif } } } } void dai_transfer_algn(int opcode, int transp, section_t ds_a, section_t gs_a, Integer req) { Integer next, chunk_ld[MAXDIM]; section_t ds_chunk = ds_a; char *buf; int ibuf; for(next = 0; next < Requests[req].na; next++){ ds_chunk.lo[0] = ds_chunk.lo[1] = 0; while(dai_next_chunk(req, Requests[req].list_algn[next], &ds_chunk)){ if(dai_myturn(ds_chunk)){ #ifdef DRA_DBLE_BUFFER ibuf = _dra_buffer_index; _dra_buffer_index = 1 - ibuf; #else _dra_buffer_index = 0; ibuf = 1; #endif _dra_buffer_state[_dra_buffer_index].req = req; dai_wait_buf(_dra_buffer_index); Requests[req].ibuf = _dra_buffer_index; chunk_ld[0] = ds_chunk.hi[0] - ds_chunk.lo[0] + 1; buf = (char*)_dra_buffer_state[_dra_buffer_index].buffer; switch (opcode){ case DRA_OP_WRITE: ga_move(LOAD, transp, gs_a, ds_a, ds_chunk, buf, chunk_ld[0]); dai_put(ds_chunk, buf, chunk_ld[0], &_dra_buffer_state[_dra_buffer_index].id); break; case DRA_OP_READ: dai_get(ds_chunk, buf, chunk_ld[0], &_dra_buffer_state[_dra_buffer_index].id); elio_wait(&_dra_buffer_state[_dra_buffer_index].id); dai_callback(STORE,transp,gs_a,ds_a,ds_chunk,chunk_ld, _dra_buffer_index,req); break; default: dai_error("dai_transfer_algn: invalid opcode",(Integer)opcode); } # ifdef DEBUG fprintf(stderr,"%d transf algn g[%d:%d,%d:%d]-d[%d:%d,%d:%d]\n", dai_io_nodeid(), gs_chunk.lo[0], gs_chunk.hi[0], gs_chunk.lo[1], gs_chunk.hi[1], ds_chunk.lo[0], ds_chunk.hi[0], ds_chunk.lo[1], ds_chunk.hi[1]); # endif } } } } Integer FATR dra_write_section_( logical *transp, Integer *g_a, Integer *gilo, Integer *gihi, Integer *gjlo, Integer *gjhi, Integer *d_a, Integer *dilo, Integer *dihi, Integer *djlo, Integer *djhi, Integer *request) { Integer gdim1, gdim2, gtype, handle=*d_a+DRA_OFFSET; section_t d_sect, g_sect; ga_sync_(); dai_check_handleM(*d_a,"dra_write_sect"); ga_inquire_internal_(g_a, &gtype, &gdim1, &gdim2); if(!dai_write_allowed(*d_a))dai_error("dra_write_sect: write not allowed",*d_a); if(DRA[handle].type != (int)gtype)dai_error("dra_write_sect: type mismatch",gtype); dai_check_rangeM(*gilo,*gihi, gdim1, "dra_write_sect: g_a dim1 error"); dai_check_rangeM(*gjlo,*gjhi, gdim2, "dra_write_sect: g_a dim2 error"); dai_check_rangeM(*dilo,*dihi,DRA[handle].dims[0],"dra_write_sect:d_a dim1 error"); dai_check_rangeM(*djlo,*djhi,DRA[handle].dims[1],"dra_write_sect:d_a dim2 error"); if ((*dihi - *dilo + 1) * (*djhi - *djlo + 1) != (*gihi - *gilo + 1) * (*gjhi - *gjlo + 1)) dai_error("dra_write_sect: d_a and g_a sections do not match ", 0L); dai_assign_request_handle(request); Requests[*request].nu=MAX_ALGN; Requests[*request].na=MAX_UNLG; fill_sectionM(d_sect, *d_a, *dilo, *dihi, *djlo, *djhi); fill_sectionM(g_sect, *g_a, *gilo, *gihi, *gjlo, *gjhi); dai_decomp_section(d_sect, Requests[*request].list_algn, &Requests[*request].na, Requests[*request].list_cover, Requests[*request].list_unlgn, &Requests[*request].nu); _dra_turn = 0; dai_transfer_unlgn(DRA_OP_WRITE, (int)*transp, d_sect, g_sect, *request); dai_transfer_algn (DRA_OP_WRITE, (int)*transp, d_sect, g_sect, *request); ga_sync_(); return(ELIO_OK); } Integer FATR dra_read_section_( logical *transp, Integer *g_a, Integer *gilo, Integer *gihi, Integer *gjlo, Integer *gjhi, Integer *d_a, Integer *dilo, Integer *dihi, Integer *djlo, Integer *djhi, Integer *request) { Integer gdim1, gdim2, gtype, handle=*d_a+DRA_OFFSET; section_t d_sect, g_sect; ga_sync_(); dai_check_handleM(*d_a,"dra_read_sect"); if(!dai_read_allowed(*d_a))dai_error("dra_read_sect: read not allowed",*d_a); ga_inquire_internal_(g_a, &gtype, &gdim1, &gdim2); if(DRA[handle].type != (int)gtype)dai_error("dra_read_sect: type mismatch",gtype); dai_check_rangeM(*gilo, *gihi, gdim1, "dra_read_sect: g_a dim1 error"); dai_check_rangeM(*gjlo, *gjhi, gdim2, "dra_read_sect: g_a dim2 error"); dai_check_rangeM(*dilo, *dihi,DRA[handle].dims[0],"dra_read_sect:d_a dim1 error"); dai_check_rangeM(*djlo, *djhi,DRA[handle].dims[1],"dra_read_sect:d_a dim2 error"); if ((*dihi - *dilo + 1) * (*djhi - *djlo + 1) != (*gihi - *gilo + 1) * (*gjhi - *gjlo + 1)) dai_error("dra_read_sect: d_a and g_a sections do not match ", 0L); dai_assign_request_handle(request); Requests[*request].nu=MAX_ALGN; Requests[*request].na=MAX_UNLG; fill_sectionM(d_sect, *d_a, *dilo, *dihi, *djlo, *djhi); fill_sectionM(g_sect, *g_a, *gilo, *gihi, *gjlo, *gjhi); dai_decomp_section(d_sect, Requests[*request].list_algn, &Requests[*request].na, Requests[*request].list_cover, Requests[*request].list_unlgn, &Requests[*request].nu); _dra_turn = 0; dai_transfer_unlgn(DRA_OP_READ, (int)*transp, d_sect, g_sect, *request); dai_transfer_algn (DRA_OP_READ, (int)*transp, d_sect, g_sect, *request); return(ELIO_OK); } Integer FATR dra_read_(Integer* g_a, Integer* d_a, Integer* request) { Integer gdim1, gdim2, gtype, handle=*d_a+DRA_OFFSET; logical transp = FALSE; Integer ilo, ihi, jlo, jhi; ga_sync_(); dai_check_handleM(*d_a,"dra_read"); if(!dai_read_allowed(*d_a))dai_error("dra_read: read not allowed",*d_a); ga_inquire_internal_(g_a, &gtype, &gdim1, &gdim2); if(DRA[handle].type != (int)gtype)dai_error("dra_read: type mismatch",gtype); if(DRA[handle].dims[0] != gdim1)dai_error("dra_read: dim1 mismatch",gdim1); if(DRA[handle].dims[1] != gdim2)dai_error("dra_read: dim2 mismatch",gdim2); ilo = 1; ihi = DRA[handle].dims[0]; jlo = 1; jhi = DRA[handle].dims[1]; return(dra_read_section_(&transp, g_a, &ilo, &ihi, &jlo, &jhi, d_a, &ilo, &ihi, &jlo, &jhi, request)); } Integer FATR dra_wait_(Integer* request) { #if WALLTIME double ss0, tt0; #endif if(*request == DRA_REQ_INVALID) return(ELIO_OK); #if WALLTIME walltime(&ss0,&tt0); printf("p[%d] executing dra_wait: %16.6f\n",ga_nodeid_(),tt0); #endif if (_dra_buffer_state[0].req == *request) elio_wait(&_dra_buffer_state[0].id); if (_dra_buffer_state[1].req == *request) elio_wait(&_dra_buffer_state[1].id); Requests[*request].num_pending=0; dai_exec_callback(Requests + *request); ga_sync_(); return(ELIO_OK); } Integer FATR dra_probe_( Integer *request, Integer *status) { Integer done, type=GA_TYPE_GSM; char *op="*"; int stat; if(*request == DRA_REQ_INVALID){ *status = ELIO_DONE; return(ELIO_OK); } if(elio_probe(&_dra_buffer_state[Requests[*request].ibuf].id, &stat) !=ELIO_OK)return(DRA_FAIL); *status = (Integer) stat; done = (*status==ELIO_DONE)? 1: 0; ga_igop(type, &done, (Integer)1,op); if(done){ *status = ELIO_DONE; Requests[*request].num_pending = 0; dai_exec_callback(Requests + *request); } else Requests[*request].num_pending = ELIO_PENDING; return(ELIO_OK); } void dra_flick_() { Integer req; int stat; if(!num_pending_requests)return; for(req=0; req<MAX_REQ; req++) if(Requests[req].num_pending) if(elio_probe(&_dra_buffer_state[Requests[req].ibuf].id, &stat) == ELIO_OK) if(stat == ELIO_DONE) dai_exec_callback(Requests + req); } Integer dra_inquire( Integer *d_a, Integer *type, Integer *dim1, Integer *dim2, char *name, char *filename) { Integer handle=*d_a+DRA_OFFSET; dai_check_handleM(*d_a,"dra_inquire"); *type = (Integer)DRA[handle].type; *dim1 = DRA[handle].dims[0]; *dim2 = DRA[handle].dims[1]; strcpy(name, DRA[handle].name); strcpy(filename, DRA[handle].fname); return(ELIO_OK); } Integer FATR dra_delete_(Integer* d_a) { Integer handle = *d_a+DRA_OFFSET; int rc; ga_sync_(); dai_check_handleM(*d_a,"dra_delete"); dai_delete_param(DRA[handle].fname,*d_a); if(dai_io_manage(*d_a)) if(ELIO_OK != (rc=elio_close(DRA[handle].fd))) dai_error("dra_close: close failed",rc); if(dai_file_master(*d_a)) if(INDEPFILES(*d_a)){ sprintf(dummy_fname,"%s.%ld",DRA[handle].fname,(long)dai_io_nodeid(*d_a)); elio_delete(dummy_fname); }else { elio_delete(DRA[handle].fname); } dai_release_handle(d_a); ga_sync_(); return(ELIO_OK); } Integer FATR dra_terminate_() { free(DRA); MA_free_heap(_handle_buffer); ga_sync_(); return(ELIO_OK); } void dai_clear_buffer() { int i; for (i=0;i<DRA_DBL_BUF_SIZE;i++) ((double*)_dra_buffer_state[0].buffer)[i]=0.; } #define block_sortM(_ndim, _block_orig, _block_map) \ {\ Integer _i,_j,_it,_bt; \ Integer _block_tmp[MAXDIM]; \ for (_i=0; _i < (_ndim); _i++) { \ _block_map[_i] = _i; \ _block_tmp[_i] = _block_orig[_i]; \ } \ for (_j=(_ndim)-2; _j >= 0; _j--) { \ _i = _j + 1; \ _bt = _block_tmp[_j]; \ _it = _block_map[_j]; \ while (_i < (_ndim) && _bt < _block_tmp[_i]) { \ _block_tmp[_i-1] = _block_tmp[_i]; \ _block_map[_i-1] = _block_map[_i]; \ _i++; \ }\ _block_tmp[_i-1] = _bt; \ _block_map[_i-1] = _it; \ }\ } void ndai_chunking(Integer elem_size, Integer ndim, Integer block_orig[], Integer dims[], Integer chunk[]) { Integer patch_size; Integer i, j, tmp_patch, block[MAXDIM], block_map[MAXDIM]; double ratio; logical full_buf, some_neg, overfull_buf; for (i=0; i<ndim; i++) block[i] = block_orig[i]; for (i=0; i<ndim; i++) { if (block[i] > dims[i]) block[i] = dims[i]; } for (i=0; i<ndim; i++) { if (block[i] > 0 && block[i]<dims[i]) { if (dims[i]%block[i] != 0) { ratio = (double)dims[i]/(double)block[i]; j = (int)(ratio+0.5); if (dims[i]%j ==0) block[i] = dims[i]/j; } } } patch_size = 1; some_neg = FALSE; full_buf = FALSE; overfull_buf = FALSE; for (i=0; i<ndim; i++) { if (block[i] > 0) patch_size *= block[i]; else some_neg = TRUE; } if (patch_size*elem_size > DRA_BUF_SIZE) overfull_buf = TRUE; block_sortM(ndim, dims, block_map); if (!full_buf && !overfull_buf && some_neg) { for (i=ndim-1; i>=0; i--) { if (block[block_map[i]] < 0) { tmp_patch = patch_size * dims[block_map[i]]; if (tmp_patch*elem_size < DRA_BUF_SIZE) { patch_size *= dims[block_map[i]]; block[block_map[i]] = dims[block_map[i]]; } else { block[block_map[i]] = DRA_BUF_SIZE/(patch_size*elem_size); patch_size *= block[block_map[i]]; full_buf = TRUE; } } } } for (i=0; i<ndim; i++) { if (block[i] > 0) chunk[i] = block[i]; else chunk[i] = 1; } if (overfull_buf) { ratio = ((double)DRA_BUF_SIZE)/((double)(patch_size*elem_size)); ratio = pow(ratio,1.0/((double)ndim)); patch_size = 1; for (i=0; i<ndim; i++) { chunk[i] = (int)(((double)chunk[i])*ratio); if (chunk[i] < 1) chunk[i] = 1; patch_size *= chunk[i]; } } #ifdef DEBUG printf("Current patch at 2 is %d\n",(int)patch_size*elem_size); #endif for (i=0; i<ndim; i++) { if (chunk[i] == 0) chunk[i] = 1; } if (elem_size*patch_size > DRA_BUF_SIZE) { block_sortM(ndim, chunk, block_map); for (i=0; i < ndim; i++) { while (chunk[block_map[i]] > 1 && elem_size*patch_size > DRA_BUF_SIZE) { patch_size /= chunk[block_map[i]]; chunk[block_map[i]]--; patch_size *= chunk[block_map[i]]; } } } } #define nfill_sectionM(sect, _hndl, _ndim, _lo, _hi) \ { \ Integer _i; \ sect.handle = _hndl; \ sect.ndim = _ndim; \ for (_i=0; _i<_ndim; _i++) { \ sect.lo[_i] = _lo[_i]; \ sect.hi[_i] = _hi[_i]; \ } \ } #define nblock_to_sectM(ds_a, _CR) \ {\ Integer _i, _b[MAXDIM], _C = (_CR); \ Integer _hndl = (ds_a)->handle+DRA_OFFSET; \ Integer _R = (DRA[_hndl].dims[0]+DRA[_hndl].chunk[0]-1)/DRA[_hndl].chunk[0]; \ (ds_a)->ndim = DRA[_hndl].ndim; \ _b[0] = _C%_R; \ for (_i=1; _i<DRA[_hndl].ndim; _i++) { \ _C = (_C - _b[_i-1])/_R; \ _R = (DRA[_hndl].dims[_i]+DRA[_hndl].chunk[_i]-1)/DRA[_hndl].chunk[_i]; \ _b[_i] = (_C)%_R; \ } \ for (_i=0; _i<DRA[_hndl].ndim; _i++) { \ (ds_a)->lo[_i] = _b[_i]*DRA[_hndl].chunk[_i] + 1; \ (ds_a)->hi[_i] = (ds_a)->lo[_i] + DRA[_hndl].chunk[_i] - 1; \ if ((ds_a)->hi[_i] > DRA[_hndl].dims[_i]) \ (ds_a)->hi[_i] = DRA[_hndl].dims[_i]; \ } \ } #define nblock_to_indicesM(_index,_ndim,_block_dims,_CC) \ { \ Integer _i, _C=(_CC); \ _index[0] = _C%_block_dims[0]; \ for (_i=1; _i<(_ndim); _i++) { \ _C = (_C - _index[_i-1])/_block_dims[_i-1]; \ _index[_i] = _C%_block_dims[_i]; \ } \ } void ndai_file_location(section_t ds_a, Off_t* offset) { Integer handle=ds_a.handle+DRA_OFFSET, ndim, i, j; Integer blocks[MAXDIM], part_chunk[MAXDIM], cur_ld[MAXDIM]; long par_block[MAXDIM]; long offelem; ndim = DRA[handle].ndim; for (i=0; i<ndim-1; i++) { if((ds_a.lo[i]-1)%DRA[handle].chunk[i]) dai_error("ndai_file_location: not alligned ??",ds_a.lo[i]); } for (i=0; i<ndim; i++) { blocks[i] = (ds_a.lo[i]-1)/DRA[handle].chunk[i]; part_chunk[i] = DRA[handle].dims[i]%DRA[handle].chunk[i]; cur_ld[i] = (blocks[i] == DRA[handle].dims[i]/DRA[handle].chunk[i]) ? part_chunk[i]: DRA[handle].chunk[i]; } if (INDEPFILES(ds_a.handle)) { Integer CR, block_dims[MAXDIM]; Integer index[MAXDIM]; long nelem; Integer i, j; Integer ioprocs = dai_io_procs(ds_a.handle); Integer iome = dai_io_nodeid(ds_a.handle); nsect_to_blockM(ds_a, &CR); for (i=0; i<ndim; i++) { block_dims[i] = (DRA[handle].dims[i]+DRA[handle].chunk[i]-1) / DRA[handle].chunk[i]; } if (iome >= 0) { offelem = 0; for (i=iome; i<CR; i+=ioprocs) { nblock_to_indicesM(index,ndim,block_dims,i); nelem = 1; for (j=0; j<ndim; j++) { if (index[j]<block_dims[j]-1) { nelem *= (long)DRA[handle].chunk[j]; } else { if (part_chunk[j] != 0) { nelem *= (long)part_chunk[j]; } else { nelem *= (long)DRA[handle].chunk[j]; } } } offelem += nelem; } nelem = 1; nblock_to_indicesM(index,ndim,block_dims,CR); for (i=0; i<ndim-1; i++) { if (index[i]<block_dims[i]-1) { nelem *= (long)DRA[handle].chunk[i]; } else { if (part_chunk[i] != 0) { nelem *= (long)part_chunk[i]; } else { nelem *= (long)DRA[handle].chunk[i]; } } } nelem *= (long)(ds_a.lo[ndim-1]-1)%DRA[handle].chunk[ndim-1]; offelem += (long)nelem; } } else { for (i=0; i<ndim; i++) { par_block[i] = 1; for (j=0; j<ndim; j++) { if (j < i) { par_block[i] *= (long)cur_ld[j]; } else if (j == i) { if (i == ndim-1) { par_block[i] *= (long)(ds_a.lo[i]-1); } else { par_block[i] *= (long)(blocks[j]*DRA[handle].chunk[j]); } } else { par_block[i] *= (long)(DRA[handle].dims[j]); } } } offelem = 0; for (i=0; i<ndim; i++) offelem += (long)par_block[i]; } *offset = (Off_t)offelem * dai_sizeofM(DRA[handle].type); } void ndai_zero_eof(Integer d_a) { Integer handle = d_a+DRA_OFFSET, nelem, i; Integer zero[MAXDIM]; char byte; Off_t offset; byte = (char)0; if(INDEPFILES(d_a)) { Integer CR, i, nblocks; section_t ds_a; Integer ioprocs=dai_io_procs(d_a); Integer iome = dai_io_nodeid(d_a); nblocks = 1; for (i=0; i<DRA[handle].ndim; i++) { nblocks *= (DRA[handle].dims[i]+DRA[handle].chunk[i]-1) / DRA[handle].chunk[i]; zero[i] = 0; } nfill_sectionM(ds_a, d_a, DRA[handle].ndim, zero, zero); for(i = 0; i <ioprocs; i++){ CR = nblocks - 1 -i; if(CR % ioprocs == iome) break; } if(CR<0) return; nblock_to_sectM(&ds_a, CR); ndai_file_location(ds_a, &offset); nelem = 1; for (i=0; i<DRA[handle].ndim; i++) nelem *= (ds_a.hi[i] - ds_a.lo[i] + 1); offset += ((Off_t)nelem) * dai_sizeofM(DRA[handle].type); # ifdef DEBUG printf("me=%d zeroing EOF (%d) at %ld bytes \n",iome,CR,offset); # endif } else { nelem = 1; for (i=0; i<DRA[handle].ndim; i++) nelem *= DRA[handle].dims[i]; offset = ((Off_t)nelem) * dai_sizeofM(DRA[handle].type); } if(elio_write(DRA[handle].fd, offset-1, &byte, 1) != (Size_t)1) dai_error("ndai_zero_eof: write error ",0); } Integer ndra_create( Integer *type, Integer *ndim, Integer dims[], char *name, char *filename, Integer *mode, Integer reqdims[], Integer *d_a) { Integer handle, elem_size, ctype, i; ctype = (Integer)ga_type_f2c((int)(*type)); ga_sync_(); dai_check_typeM(ctype); for (i=0; i<*ndim; i++) if (dims[i] <=0) dai_error("ndra_create: disk array dimension invalid ", dims[i]); if(strlen(filename)>DRA_MAX_FNAME) dai_error("ndra_create: filename too long", DRA_MAX_FNAME); if( (handle = dai_get_handle()) == -1) dai_error("ndra_create: too many disk arrays ", _max_disk_array); *d_a = handle - DRA_OFFSET; elem_size = dai_sizeofM(ctype); ndai_chunking( elem_size, *ndim, reqdims, dims, DRA[handle].chunk); DRA[handle].layout = COLUMN; for (i=0; i<*ndim; i++) DRA[handle].dims[i] = dims[i]; DRA[handle].ndim = *ndim; DRA[handle].type = ctype; DRA[handle].mode = (int)*mode; strncpy (DRA[handle].fname, filename, DRA_MAX_FNAME); strncpy(DRA[handle].name, name, DRA_MAX_NAME ); dai_write_param(DRA[handle].fname, *d_a); DRA[handle].indep = dai_file_config(filename); if(dai_io_manage(*d_a)){ if (INDEPFILES(*d_a)) { sprintf(dummy_fname,"%s.%ld",DRA[handle].fname,(long)dai_io_nodeid(*d_a)); DRA[handle].fd = elio_open(dummy_fname,(int)*mode, ELIO_PRIVATE); }else{ # ifdef PARAGON DRA[handle].fd = elio_gopen(DRA[handle].fname,(int)*mode); # else DRA[handle].fd = elio_open(DRA[handle].fname,(int)*mode, ELIO_SHARED); # endif } if(DRA[handle].fd==NULL)dai_error("ndra_create:failed to open file",0); if(DRA[handle].fd->fd==-1)dai_error("ndra_create:failed to open file",0); } ga_sync_(); if(dai_file_master(*d_a) && dai_write_allowed(*d_a)) ndai_zero_eof(*d_a); ga_sync_(); return(ELIO_OK); } void ndai_put( section_t ds_a, Void *buf, Integer ld[], io_request_t *id) { Integer handle = ds_a.handle + DRA_OFFSET, elem, i; Integer ndim = ds_a.ndim; Off_t offset; Size_t bytes; #if WALLTIME double ss0,tt0,tt1; #endif ndai_file_location(ds_a, &offset); for (i=0; i<ndim-1; i++) if ((ds_a.hi[i]-ds_a.lo[i]+1) != ld[i]) dai_error("ndai_put: bad ld",ld[i]); elem = 1; for (i=0; i<ndim; i++) elem *= (ds_a.hi[i]-ds_a.lo[i]+1); bytes= (Size_t) elem * dai_sizeofM(DRA[handle].type); #if WALLTIME walltime_(&ss0,&tt0); #endif if( ELIO_OK != elio_awrite(DRA[handle].fd, offset, buf, bytes, id )) dai_error("ndai_put failed", ds_a.handle); #if WALLTIME walltime_(&ss0,&tt1); printf("p[%d] Beginning ndai_put: %16.6f\n",ga_nodeid_(),tt0); printf("p[%d] Ending ndai_put: %16.6f\n",ga_nodeid_(),tt1); #endif } void ndai_get(section_t ds_a, Void *buf, Integer ld[], io_request_t *id) { Integer handle = ds_a.handle + DRA_OFFSET, elem, rc; Integer ndim = DRA[handle].ndim, i; Off_t offset; Size_t bytes; void dai_clear_buffer(); #if WALLTIME double ss0,tt0,tt1; # endif ndai_file_location(ds_a, &offset); # ifdef CLEAR_BUF dai_clear_buffer(); # endif for (i=0; i<ndim-1; i++) if ((ds_a.hi[i] - ds_a.lo[i] + 1) != ld[i]) dai_error("ndai_get: bad ld",ld[i]); elem = 1; for (i=0; i<ndim; i++) elem *= (ds_a.hi[i]-ds_a.lo[i]+1); bytes= (Size_t) elem * dai_sizeofM(DRA[handle].type); #if WALLTIME walltime_(&ss0,&tt0); # endif rc= elio_aread(DRA[handle].fd, offset, buf, bytes, id ); #if WALLTIME walltime_(&ss0,&tt1); printf("p[%d] Beginning ndai_get: %16.6f\n",ga_nodeid_(),tt0); printf("p[%d] Ending ndai_get: %16.6f\n",ga_nodeid_(),tt1); # endif if(rc != ELIO_OK) dai_error("ndai_get failed", rc); } #define ndai_check_rangeM(_lo, _hi, _ndim, _dims, _err_msg) \ { \ int _range_ok = 1, _i; \ for (_i=0; _i < (_ndim); _i++) { \ if (_lo[_i] < 1 || _lo[_i] > _dims[_i] || _hi[_i] < _lo[_i] \ || _hi[_i] > _dims[_i] ) _range_ok = 0; \ } \ if(!_range_ok) dai_error(_err_msg, _dim); \ } void ndai_decomp_section( section_t ds_a, Integer aligned[][2*MAXDIM], int *na, Integer cover[][2*MAXDIM], Integer unaligned[][2*MAXDIM], int *nu) { Integer a=0, u=0, handle = ds_a.handle+DRA_OFFSET, off, chunk_units, algn_flag; Integer i, j, idir, ndim = DRA[handle].ndim; Integer off_low[MAXDIM], off_hi[MAXDIM]; Integer cover_lo[MAXDIM], cover_hi[MAXDIM]; Integer check, chunk_lo, chunk_hi; for (i=0, j=0; i<ndim; i++) { aligned[a][j] = ds_a.lo[i]; cover_lo[i] = ds_a.lo[i]; off_low[i] = (ds_a.lo[i] - 1) % DRA[handle].chunk[i]; j++; aligned[a][j] = ds_a.hi[i]; cover_hi[i] = ds_a.hi[i]; off_hi[i] = ds_a.hi[i] % DRA[handle].chunk[i]; j++; } for (i=0; i<ndim-1; i++) { if (off_low[i] !=0) { chunk_lo = (ds_a.lo[i] - 1) / DRA[handle].chunk[i]; cover_lo[i] = chunk_lo * DRA[handle].chunk[i] + 1; } if (off_hi[i] !=0) { chunk_hi = ds_a.hi[i] / DRA[handle].chunk[i] + 1; cover_hi[i] = chunk_hi * DRA[handle].chunk[i]; if (cover_hi[i] > DRA[handle].dims[i]) cover_hi[i] = DRA[handle].dims[i]; } } j = 0; check = 1; for (i=0; i<ndim-1; i++) { if (off_low[i] != 0) { chunk_lo = (ds_a.lo[i] - 1) / DRA[handle].chunk[i] + 1; aligned[a][j] = chunk_lo * DRA[handle].chunk[i] + 1; } j++; if (off_hi[i] !=0) { chunk_hi = ds_a.hi[i] / DRA[handle].chunk[i]; aligned[a][j] = chunk_hi * DRA[handle].chunk[i]; } if (aligned[a][j] < aligned[a][j-1]) check = 0; j++; } *na = (check == 1) ?1 :0; if (*na == 0) { for (i=0, j=0; i<ndim; i++) { cover[u][j] = cover_lo[i]; unaligned[u][j] = ds_a.lo[i]; j++; cover[u][j] = cover_hi[i]; unaligned[u][j] = ds_a.hi[i]; j++; } *nu = 1; return; } for (idir=0; idir<ndim-1; idir++) { check = 1; if (off_low[idir] != 0) { for (i=0, j=0; i<ndim-1; i++) { if (i < idir) { if (off_low[i] != 0) { chunk_units = (ds_a.lo[i] - 1) / DRA[handle].chunk[i]; cover[u][j] = chunk_units * DRA[handle].chunk[i] + 1; } else { cover[u][j] = ds_a.lo[i]; } unaligned[u][j] = ds_a.lo[i]; j++; if (off_hi[i] != 0) { chunk_units = ds_a.hi[i] / DRA[handle].chunk[i]+1; cover[u][j] = MIN(chunk_units * DRA[handle].chunk[i], DRA[handle].dims[i]); } else { cover[u][j] = ds_a.hi[i]; } unaligned[u][j] = ds_a.hi[i]; j++; } else if (i == idir) { chunk_units = (ds_a.lo[i] - 1) / DRA[handle].chunk[i]; cover[u][j] = chunk_units * DRA[handle].chunk[i] + 1; unaligned[u][j] = ds_a.lo[i]; j++; cover[u][j] = MIN(cover[u][j-1] + DRA[handle].chunk[i]-1, DRA[handle].dims[i]); unaligned[u][j] = MIN(ds_a.hi[i],cover[u][j]); j++; } else { if (off_low[i] != 0) { chunk_units = (ds_a.lo[i] - 1) / DRA[handle].chunk[i]+1; cover[u][j] = chunk_units * DRA[handle].chunk[i] + 1; } else { cover[u][j] = ds_a.lo[i]; } unaligned[u][j] = ds_a.lo[i]; j++; if (off_hi[i] != 0) { chunk_units = ds_a.hi[i] / DRA[handle].chunk[i]; cover[u][j] = chunk_units * DRA[handle].chunk[i]; } else { cover[u][j] = ds_a.hi[i]; } unaligned[u][j] = ds_a.hi[i]; j++; } } cover[u][j] = ds_a.lo[ndim-1]; unaligned[u][j] = ds_a.lo[ndim-1]; j++; cover[u][j] = ds_a.hi[ndim-1]; unaligned[u][j] = ds_a.hi[ndim-1]; u++; check = 1; aligned[a][2*idir] = cover[u-1][2*idir+1]+1; } if (check == 1) { if (cover[u-1][2*idir+1] >= ds_a.hi[idir]) check = 0; } else { check = 1; } if (off_hi[idir] != 0 && check == 1) { for (i=0, j=0; i<ndim-1; i++) { if (i < idir) { if (off_low[i] != 0) { chunk_units = (ds_a.lo[i] - 1) / DRA[handle].chunk[i]; cover[u][j] = chunk_units * DRA[handle].chunk[i] + 1; } else { cover[u][j] = ds_a.lo[i]; } unaligned[u][j] = ds_a.lo[i]; j++; if (off_hi[i] != 0) { chunk_units = ds_a.hi[i] / DRA[handle].chunk[i]+1; cover[u][j] = MIN(chunk_units * DRA[handle].chunk[i], DRA[handle].dims[i]); } else { cover[u][j] = ds_a.hi[i]; } unaligned[u][j] = ds_a.hi[i]; j++; } else if (i == idir) { chunk_units = ds_a.hi[i] / DRA[handle].chunk[i]; cover[u][j] = chunk_units * DRA[handle].chunk[i] + 1; unaligned[u][j] = cover[u][j]; aligned[a][2*i+1] = MIN(cover[u][j]-1,ds_a.hi[idir]); j++; cover[u][j] = MIN(cover[u][j-1] + DRA[handle].chunk[i]-1, DRA[handle].dims[i]); unaligned[u][j] = MIN(ds_a.hi[i],cover[u][j]); j++; } else { if (off_low[i] != 0) { chunk_units = (ds_a.lo[i] - 1) / DRA[handle].chunk[i]+1; cover[u][j] = chunk_units * DRA[handle].chunk[i] + 1; } else { cover[u][j] = ds_a.lo[i]; } unaligned[u][j] = ds_a.lo[i]; j++; if (off_hi[i] != 0) { chunk_units = ds_a.hi[i] / DRA[handle].chunk[i]; cover[u][j] = chunk_units * DRA[handle].chunk[i]; } else { cover[u][j] = ds_a.hi[i]; } unaligned[u][j] = ds_a.hi[i]; j++; } } cover[u][j] = ds_a.lo[ndim-1]; unaligned[u][j] = ds_a.lo[ndim-1]; j++; cover[u][j] = ds_a.hi[ndim-1]; unaligned[u][j] = ds_a.hi[ndim-1]; u++; aligned[a][2*idir+1] = cover[u-1][2*idir]-1; } } *nu = (int)u; return; } int ndai_next(Integer *lo, Integer *cover, Integer *inc, Integer ndim) { int retval=1; Integer i; for (i = 0; i<ndim; i++) { if (lo[i] == 0) retval = 0; } if (retval == 0) { for (i = 0; i<ndim; i++) { lo[i] = cover[2*i]; } } if (retval != 0) { for (i=0; i<ndim; i++) { lo[i] += inc[i]; if (lo[i] > cover[2*i+1]) { if (i<ndim-1) lo[i] = cover[2*i]; } else { break; } } } retval = (lo[ndim-1] <= cover[2*ndim-1]); return retval; } int ndai_next_chunk(Integer req, Integer* list, section_t* ds_chunk) { Integer handle = ds_chunk->handle+DRA_OFFSET; int retval, ndim = DRA[handle].ndim, i; if(INDEPFILES(ds_chunk->handle)) if(ds_chunk->lo[ndim-1] && DRA[handle].chunk[ndim-1]>1) ds_chunk->lo[ndim-1] -= (ds_chunk->lo[ndim-1] -1) % DRA[handle].chunk[ndim-1]; retval = ndai_next(ds_chunk->lo, list, DRA[handle].chunk, ndim); if(!retval) { return(retval); } for (i=0; i<ndim; i++) { ds_chunk->hi[i] = MIN(list[2*i+1], ds_chunk->lo[i]+DRA[handle].chunk[i]-1); } if(INDEPFILES(ds_chunk->handle)) { Integer nlo; Integer hi_temp = ds_chunk->lo[ndim-1] + DRA[handle].chunk[ndim-1] -1; hi_temp -= hi_temp % DRA[handle].chunk[ndim-1]; ds_chunk->hi[ndim-1] = MIN(ds_chunk->hi[ndim-1], hi_temp); nlo = 2*(ndim-1); if(ds_chunk->lo[ndim-1] < list[nlo]) ds_chunk->lo[ndim-1] = list[nlo]; } return 1; } void ndai_transfer_unlgn(int opcode, int transp, section_t ds_a, section_t gs_a, Integer req ) { Integer chunk_ld[MAXDIM], next, offset, i, j; int type = DRA[ds_a.handle+DRA_OFFSET].type; Integer ndim = DRA[ds_a.handle+DRA_OFFSET].ndim; section_t ds_chunk, ds_unlg; char *buf, *buffer; int ibuf; ds_chunk = ds_unlg = ds_a; if (dra_debug_flag && 0) { for (i=0; i<ndim; i++) { printf("ndai_transfer_unlgn: ds_chunk.lo[%d] = %d\n",i,ds_chunk.lo[i]); printf("ndai_transfer_unlgn: ds_chunk.hi[%d] = %d\n",i,ds_chunk.hi[i]); } printf("ndai_transfer_unlgn: number of unaligned chunks = %d\n", Requests[req].nu); for (j=0; j<Requests[req].nu; j++) { for (i=0; i<ndim; i++) { printf("ndai_transfer_unlgn: list_cover[%d][%d] = %d\n", j,2*i,Requests[req].list_cover[j][2*i]); printf("ndai_transfer_unlgn: list_cover[%d][%d] = %d\n", j,2*i+1,Requests[req].list_cover[j][2*i+1]); } } } for(next = 0; next < Requests[req].nu; next++){ for (i=0; i<ndim; i++) ds_chunk.lo[i] = 0; while(ndai_next_chunk(req, Requests[req].list_cover[next],&ds_chunk)){ if(dai_myturn(ds_chunk)){ ibuf = _dra_buffer_index; _dra_buffer_index = 1 - ibuf; switch (opcode){ case DRA_OP_WRITE: _dra_buffer_index = 0; ibuf = 1; break; case DRA_OP_READ: _dra_buffer_index = 0; ibuf = 1; break; default: break; } Requests[req].ibuf = _dra_buffer_index; _dra_buffer_state[_dra_buffer_index].req = req; dai_wait_buf(_dra_buffer_index); for (i=0; i<ndim; i++) { ds_unlg.lo[i] = Requests[req].list_unlgn[next][2*i]; ds_unlg.hi[i] = Requests[req].list_unlgn[next][2*i+1]; } if (dra_debug_flag && 0) { for (i=0; i<ndim; i++) { printf("ndai_transfer_unlgn: ds_chunk.lo[%d] = %d\n",i,ds_chunk.lo[i]); printf("ndai_transfer_unlgn: ds_chunk.hi[%d] = %d\n",i,ds_chunk.hi[i]); } for (i=0; i<ndim; i++) { printf("ndai_transfer_unlgn: ds_unlg.lo[%d] = %d\n",i,ds_unlg.lo[i]); printf("ndai_transfer_unlgn: ds_unlg.hi[%d] = %d\n",i,ds_unlg.hi[i]); } } if(!dai_section_intersect(ds_chunk, &ds_unlg)) dai_error("ndai_transfer_unlgn: inconsistent cover",0); for (i=0; i<ndim-1; i++) chunk_ld[i] = ds_chunk.hi[i] - ds_chunk.lo[i] + 1; buf = (char*)_dra_buffer_state[_dra_buffer_index].buffer; ndai_get(ds_chunk, buf, chunk_ld, &_dra_buffer_state[_dra_buffer_index].id); elio_wait(&_dra_buffer_state[_dra_buffer_index].id); offset = ds_unlg.lo[ndim-1]-ds_chunk.lo[ndim-1]; for (i=ndim-2; i>=0; i--) { offset = offset*chunk_ld[i]; offset += ds_unlg.lo[i] - ds_chunk.lo[i]; } buffer = (char*)buf; buffer += offset * dai_sizeofM(type); switch (opcode){ case DRA_OP_WRITE: nga_move(LOAD, transp, gs_a, ds_a, ds_unlg, buffer, chunk_ld); ndai_put(ds_chunk, buf, chunk_ld, &_dra_buffer_state[_dra_buffer_index].id); break; case DRA_OP_READ: nga_move(STORE, transp, gs_a, ds_a, ds_unlg, buffer, chunk_ld); break; default: dai_error("dai_transfer_unlg: invalid opcode",(Integer)opcode); } # ifdef DEBUG fprintf(stderr,"%d transf unlg g[%d:%d,%d:%d]-d[%d:%d,%d:%d]\n", dai_io_nodeid(), gs_chunk.lo[0], gs_chunk.hi[0], gs_chunk.lo[1], gs_chunk.hi[1], ds_unlg.lo[0], ds_unlg.hi[0], ds_unlg.lo[1], ds_unlg.hi[1]); # endif } } } } void ndai_transfer_algn(int opcode, int transp, section_t ds_a, section_t gs_a, Integer req) { Integer next, chunk_ld[MAXDIM], ndim = ds_a.ndim; Integer i; section_t ds_chunk = ds_a; char *buf; for(next = 0; next < Requests[req].na; next++){ for (i=0; i<ndim; i++) ds_chunk.lo[i] = 0; while(ndai_next_chunk(req, Requests[req].list_algn[next], &ds_chunk)){ if (dra_debug_flag && 0) { printf("ndai_transfer_algn: Request %d\n",req); for (i=0; i<ndim; i++) { printf("ndai_transfer_algn: ds_chunk.lo[%d] = %d\n",i,ds_chunk.lo[i]); printf("ndai_transfer_algn: ds_chunk.hi[%d] = %d\n",i,ds_chunk.hi[i]); } } if(dai_myturn(ds_chunk)){ _dra_buffer_index = 1 - _dra_buffer_index; switch (opcode){ case DRA_OP_WRITE: _dra_buffer_index = 0; break; case DRA_OP_READ: #ifndef DRA_DBLE_BUFFER _dra_buffer_index = 0; #endif break; default: break; } _dra_buffer_state[_dra_buffer_index].req = req; dai_wait_buf(_dra_buffer_index); Requests[req].ibuf = _dra_buffer_index; for (i=0; i<ndim-1; i++) chunk_ld[i] = ds_chunk.hi[i] - ds_chunk.lo[i] + 1; buf = (char*)_dra_buffer_state[_dra_buffer_index].buffer; switch (opcode){ case DRA_OP_WRITE: nga_move(LOAD, transp, gs_a, ds_a, ds_chunk, buf, chunk_ld); ndai_put(ds_chunk, buf, chunk_ld, &_dra_buffer_state[_dra_buffer_index].id); break; case DRA_OP_READ: ndai_get(ds_chunk, buf, chunk_ld, &_dra_buffer_state[_dra_buffer_index].id); dai_callback(STORE,transp,gs_a,ds_a,ds_chunk,chunk_ld, _dra_buffer_index,req); break; default: dai_error("dai_transfer_algn: invalid opcode",(Integer)opcode); } # ifdef DEBUG fprintf(stderr,"%d transf algn g[%d:%d,%d:%d]-d[%d:%d,%d:%d]\n", dai_io_nodeid(), gs_chunk.lo[0], gs_chunk.hi[0], gs_chunk.lo[1], gs_chunk.hi[1], ds_chunk.lo[0], ds_chunk.hi[0], ds_chunk.lo[1], ds_chunk.hi[1]); # endif } } } } Integer FATR ndra_write_section_( logical *transp, Integer *g_a, Integer glo[], Integer ghi[], Integer *d_a, Integer dlo[], Integer dhi[], Integer *request) { Integer gdims[MAXDIM], gtype, handle=*d_a+DRA_OFFSET; Integer i, gelem, delem, ndim; section_t d_sect, g_sect; ga_sync_(); dai_check_handleM(*d_a,"ndra_write_sect"); nga_inquire_internal_(g_a, &gtype, &ndim, gdims); if(!dai_write_allowed(*d_a))dai_error("ndra_write_sect: write not allowed",*d_a); if(DRA[handle].type != (int)gtype)dai_error("ndra_write_sect: type mismatch",gtype); if(DRA[handle].ndim != ndim)dai_error("ndra_write_sect: dimension mismatch", ndim); for (i=0; i<ndim; i++) dai_check_rangeM(glo[i], ghi[i], gdims[i], "ndra_write_sect: g_a dim error"); for (i=0; i<ndim; i++) dai_check_rangeM(dlo[i], dhi[i], DRA[handle].dims[i], "ndra_write_sect: d_a dim error"); gelem = 1; delem = 1; for (i=0; i<ndim; i++) { gelem *= (ghi[i]-glo[i]+1); delem *= (dhi[i]-dlo[i]+1); } if (gelem != delem) dai_error("ndra_write_sect: d_a and g_a sections do not match ", 0L); dai_assign_request_handle(request); Requests[*request].nu=MAX_ALGN; Requests[*request].na=MAX_UNLG; nfill_sectionM(d_sect, *d_a, DRA[handle].ndim, dlo, dhi); nfill_sectionM(g_sect, *g_a, ndim, glo, ghi); ndai_decomp_section(d_sect, Requests[*request].list_algn, &Requests[*request].na, Requests[*request].list_cover, Requests[*request].list_unlgn, &Requests[*request].nu); _dra_turn = 0; ndai_transfer_unlgn(DRA_OP_WRITE, (int)*transp, d_sect, g_sect, *request); ndai_transfer_algn (DRA_OP_WRITE, (int)*transp, d_sect, g_sect, *request); ga_sync_(); return(ELIO_OK); } Integer FATR ndra_write_( Integer *g_a, Integer *d_a, Integer *request) { Integer gdims[MAXDIM], gtype, handle=*d_a+DRA_OFFSET; logical transp = FALSE; Integer lo[MAXDIM], hi[MAXDIM], ndim, i; ga_sync_(); dai_check_handleM(*d_a,"ndra_write"); if( !dai_write_allowed(*d_a)) dai_error("ndra_write: write not allowed to this array",*d_a); nga_inquire_internal_(g_a, &gtype, &ndim, gdims); if(DRA[handle].type != (int)gtype)dai_error("ndra_write: type mismatch",gtype); if(DRA[handle].ndim != ndim)dai_error("ndra_write: dimension mismatch",ndim); for (i=0; i<ndim; i++) { if(DRA[handle].dims[i] != gdims[i]) dai_error("ndra_write: dims mismatch",gdims[i]); } for (i=0; i<ndim; i++) { lo[i] = 1; hi[i] = DRA[handle].dims[i]; } return(ndra_write_section_(&transp, g_a, lo, hi, d_a, lo, hi, request)); } Integer FATR ndra_read_section_( logical *transp, Integer *g_a, Integer glo[], Integer ghi[], Integer *d_a, Integer dlo[], Integer dhi[], Integer *request) { Integer gdims[MAXDIM], gtype, handle=*d_a+DRA_OFFSET; Integer i, gelem, delem, ndim, me; section_t d_sect, g_sect; ga_sync_(); me = ga_nodeid_(); dai_check_handleM(*d_a,"ndra_read_sect"); if(!dai_read_allowed(*d_a))dai_error("ndra_read_sect: read not allowed",*d_a); nga_inquire_internal_(g_a, &gtype, &ndim, gdims); if(DRA[handle].type != (int)gtype)dai_error("ndra_read_sect: type mismatch",gtype); if(DRA[handle].ndim != ndim)dai_error("ndra_read_sect: dimension mismatch", ndim); for (i=0; i<ndim; i++) dai_check_rangeM(glo[i], ghi[i], gdims[i], "ndra_write_sect: g_a dim error"); for (i=0; i<ndim; i++) dai_check_rangeM(dlo[i], dhi[i], DRA[handle].dims[i], "ndra_write_sect: d_a dim error"); gelem = 1; delem = 1; for (i=0; i<ndim; i++) { gelem *= (ghi[i] - glo[i] + 1); delem *= (dhi[i] - dlo[i] + 1); } if (gelem != delem) dai_error("ndra_read_sect: d_a and g_a sections do not match ", 0L); dai_assign_request_handle(request); Requests[*request].nu=MAX_ALGN; Requests[*request].na=MAX_UNLG; if (dra_debug_flag) { for (i=0; i<ndim; i++) { printf("proc[%d] ndra_read_section: dlo[%d] = %d\n",me,i,dlo[i]); printf("proc[%d] ndra_read_section: dhi[%d] = %d\n",me,i,dhi[i]); } for (i=0; i<ndim; i++) { printf("proc[%d] ndra_read_section: glo[%d] = %d\n",me,i,glo[i]); printf("proc[%d] ndra_read_section: ghi[%d] = %d\n",me,i,ghi[i]); } } nfill_sectionM(d_sect, *d_a, DRA[handle].ndim, dlo, dhi); nfill_sectionM(g_sect, *g_a, ndim, glo, ghi); ndai_decomp_section(d_sect, Requests[*request].list_algn, &Requests[*request].na, Requests[*request].list_cover, Requests[*request].list_unlgn, &Requests[*request].nu); _dra_turn = 0; if (dra_debug_flag && 0) { printf("ndra_read_section: Number of aligned sections %d\n", Requests[*request].na); printf("ndra_read_section: Number of unaligned sections %d\n", Requests[*request].nu); for (i=0; i<2*ndim; i++) { printf("ndra_read_section: list_algn[%d] = %d\n", i,Requests[*request].list_algn[0][i]); } for (i=0; i<2*ndim; i++) { printf("ndra_read_section: list_cover[%d] = %d\n", i,Requests[*request].list_cover[0][i]); } for (i=0; i<2*ndim; i++) { printf("ndra_read_section: list_unlgn[%d] = %d\n",i, Requests[*request].list_unlgn[0][i]); } } ndai_transfer_unlgn(DRA_OP_READ, (int)*transp, d_sect, g_sect, *request); ndai_transfer_algn (DRA_OP_READ, (int)*transp, d_sect, g_sect, *request); return(ELIO_OK); } Integer FATR ndra_read_(Integer* g_a, Integer* d_a, Integer* request) { Integer gdims[MAXDIM], gtype, handle=*d_a+DRA_OFFSET; logical transp = FALSE; Integer lo[MAXDIM], hi[MAXDIM], ndim, i; ga_sync_(); dai_check_handleM(*d_a,"ndra_read"); if(!dai_read_allowed(*d_a))dai_error("ndra_read: read not allowed",*d_a); nga_inquire_internal_(g_a, &gtype, &ndim, gdims); if(DRA[handle].type != (int)gtype)dai_error("ndra_read: type mismatch",gtype); if(DRA[handle].ndim != ndim)dai_error("ndra_read: dimension mismatch",ndim); for (i=0; i<ndim; i++) { if(DRA[handle].dims[i] != gdims[i]) dai_error("ndra_read: dims mismatch",gdims[i]); } for (i=0; i<ndim; i++) { lo[i] = 1; hi[i] = DRA[handle].dims[i]; } return(ndra_read_section_(&transp, g_a, lo, hi, d_a, lo, hi, request)); } Integer ndra_inquire( Integer *d_a, Integer *type, Integer *ndim, Integer dims[], char *name, char *filename) { Integer handle=*d_a+DRA_OFFSET; dai_check_handleM(*d_a,"dra_inquire"); *type = (Integer)DRA[handle].type; *ndim = DRA[handle].ndim; dims = DRA[handle].dims; strcpy(name, DRA[handle].name); strcpy(filename, DRA[handle].fname); return(ELIO_OK); } void FATR dra_print_internals_(Integer *d_a) { Integer i; Integer *dims, *chunks; Integer handle = *d_a + DRA_OFFSET; Integer ndim = DRA[handle].ndim; Integer me = ga_nodeid_(); dims = DRA[handle].dims; chunks = DRA[handle].chunk; if (me == 0) { printf("Internal Data for DRA: %s\n",DRA[handle].name); printf(" DRA Metafile Name: %s\n",DRA[handle].fname); switch(DRA[handle].type){ case C_DBL: printf(" DRA data type is DOUBLE PRECISION\n"); break; case C_FLOAT: printf(" DRA data type is SINGLE PRECISION\n"); break; case C_INT: printf(" DRA data type is INTEGER\n"); break; case C_DCPL: printf(" DRA data type is DOUBLE COMPLEX\n"); break; case C_LONG: printf(" DRA data type is LONG INTEGER\n"); break; default: printf(" DRA data type is UNKNOWN\n"); break; } switch(DRA[handle].mode) { case DRA_RW: printf(" DRA access permisions are READ/WRITE\n"); break; case DRA_W: printf(" DRA access permisions are WRITE ONLY\n"); break; case DRA_R: printf(" DRA access permisions are READ ONLY\n"); break; default: printf(" DRA access permisions are UNKNOWN\n"); break; } printf(" Dimension of DRA: %d\n",(int)ndim); printf(" Dimensions of DRA:\n"); for (i=0; i<ndim; i++) { printf(" Dimension in direction [%d]: %d\n",(int)(i+1), (int)dims[i]); } printf(" Chunk dimensions of DRA:\n"); for (i=0; i<ndim; i++) { printf(" Chunk dimension in direction [%d]: %d\n",(int)(i+1), (int)chunks[i]); } if (DRA[handle].actv) { printf(" DRA is currently active\n"); } else { printf(" DRA is not currently active\n"); } if (DRA[handle].indep) { printf(" DRA is using independent files\n"); } else { printf(" DRA is using shared files\n"); } } } void FATR dra_set_debug_(logical *flag) { if (*flag) { dra_debug_flag = TRUE; } else { dra_debug_flag = FALSE; } }
#ifndef TILEDB_READER_H #define TILEDB_READER_H #include <forward_list> #include <future> #include <list> #include <map> #include <memory> #include "tiledb/sm/array_schema/tile_domain.h" #include "tiledb/sm/misc/status.h" #include "tiledb/sm/misc/types.h" #include "tiledb/sm/misc/uri.h" #include "tiledb/sm/query/result_cell_slab.h" #include "tiledb/sm/query/result_coords.h" #include "tiledb/sm/query/result_space_tile.h" #include "tiledb/sm/query/write_cell_slab_iter.h" #include "tiledb/sm/subarray/subarray_partitioner.h" namespace tiledb { namespace sm { class Array; class ArraySchema; class FragmentMetadata; class StorageManager; class Tile; class Reader { public: struct ReadState { bool overflowed_ = false; SubarrayPartitioner partitioner_; bool unsplittable_ = false; bool initialized_ = false; bool done() const { return partitioner_.done(); } Status next() { return partitioner_.next(&unsplittable_); } Status split_current() { return partitioner_.split_current(&unsplittable_); } }; Reader(); ~Reader(); const Array* array() const; Status add_range(unsigned dim_idx, const Range& range); Status get_range_num(unsigned dim_idx, uint64_t* range_num) const; Status get_range( unsigned dim_idx, uint64_t range_idx, const void** start, const void** end, const void** stride) const; Status get_range_var_size( unsigned dim_idx, uint64_t range_idx, uint64_t* start_size, uint64_t* end_size) const; Status get_est_result_size(const char* name, uint64_t* size); Status get_est_result_size( const char* name, uint64_t* size_off, uint64_t* size_val); std::unordered_map<std::string, Subarray::ResultSize> get_est_result_size_map(); std::unordered_map<std::string, Subarray::MemorySize> get_max_mem_size_map(); Status set_est_result_size( std::unordered_map<std::string, Subarray::ResultSize>& est_result_size, std::unordered_map<std::string, Subarray::MemorySize>& max_mem_size); bool est_result_size_computed(); const ArraySchema* array_schema() const; std::vector<std::string> buffer_names() const; QueryBuffer buffer(const std::string& name) const; bool incomplete() const; Status get_buffer( const std::string& name, void** buffer, uint64_t** buffer_size) const; Status get_buffer( const std::string& name, uint64_t** buffer_off, uint64_t** buffer_off_size, void** buffer_val, uint64_t** buffer_val_size) const; URI first_fragment_uri() const; URI last_fragment_uri() const; Status init(const Layout& layout); Layout layout() const; bool no_results() const; const ReadState* read_state() const; ReadState* read_state(); Status read(); void set_array(const Array* array); void set_array_schema(const ArraySchema* array_schema); Status set_buffer( const std::string& name, void* buffer, uint64_t* buffer_size, bool check_null_buffers = true); Status set_buffer( const std::string& name, uint64_t* buffer_off, uint64_t* buffer_off_size, void* buffer_val, uint64_t* buffer_val_size, bool check_null_buffers = true); void set_fragment_metadata( const std::vector<FragmentMetadata*>& fragment_metadata); Status set_layout(Layout layout); Status set_sparse_mode(bool sparse_mode); void set_storage_manager(StorageManager* storage_manager); Status set_subarray(const Subarray& subarray); const Subarray* subarray() const; template <class T> static void compute_result_space_tiles( const Domain* domain, const std::vector<std::vector<uint8_t>>& tile_coords, const TileDomain<T>& array_tile_domain, const std::vector<TileDomain<T>>& frag_tile_domains, std::map<const T*, ResultSpaceTile<T>>* result_space_tiles); template <class T> Status compute_result_cell_slabs( const Subarray& subarray, std::map<const T*, ResultSpaceTile<T>>* result_space_tiles, std::vector<ResultCoords>* result_coords, std::vector<ResultTile*>* result_tiles, std::vector<ResultCellSlab>* result_cell_slabs) const; template <class T> Status compute_result_cell_slabs_row_col( const Subarray& subarray, std::map<const T*, ResultSpaceTile<T>>* result_space_tiles, std::vector<ResultCoords>* result_coords, uint64_t* result_coords_pos, std::vector<ResultTile*>* result_tiles, std::set<std::pair<unsigned, uint64_t>>* frag_tile_set, std::vector<ResultCellSlab>* result_cell_slabs) const; template <class T> Status compute_result_cell_slabs_global( const Subarray& subarray, std::map<const T*, ResultSpaceTile<T>>* result_space_tiles, std::vector<ResultCoords>* result_coords, std::vector<ResultTile*>* result_tiles, std::vector<ResultCellSlab>* result_cell_slabs) const; private: const Array* array_; const ArraySchema* array_schema_; std::unordered_map<std::string, QueryBuffer> buffers_; std::vector<FragmentMetadata*> fragment_metadata_; Layout layout_; ReadState read_state_; bool sparse_mode_; StorageManager* storage_manager_; Subarray subarray_; uint64_t memory_budget_; uint64_t memory_budget_var_; Status check_subarray() const; void clear_tiles( const std::string& name, const std::vector<ResultTile*>& result_tiles) const; Status compute_result_cell_slabs( const std::vector<ResultCoords>& result_coords, std::vector<ResultCellSlab>* result_cell_slabs) const; Status compute_range_result_coords( unsigned frag_idx, ResultTile* tile, uint64_t range_idx, std::vector<ResultCoords>* result_coords); Status compute_range_result_coords( const std::vector<bool>& single_fragment, const std::map<std::pair<unsigned, uint64_t>, size_t>& result_tile_map, std::vector<ResultTile>* result_tiles, std::vector<std::vector<ResultCoords>>* range_result_coords); Status compute_range_result_coords( uint64_t range_idx, const std::map<std::pair<unsigned, uint64_t>, size_t>& result_tile_map, std::vector<ResultTile>* result_tiles, std::vector<ResultCoords>* range_result_coords); Status compute_range_result_coords( uint64_t range_idx, uint32_t fragment_idx, const std::map<std::pair<unsigned, uint64_t>, size_t>& result_tile_map, std::vector<ResultTile>* result_tiles, std::vector<ResultCoords>* range_result_coords); Status compute_subarray_coords( std::vector<std::vector<ResultCoords>>* range_result_coords, std::vector<ResultCoords>* result_coords); Status compute_sparse_result_tiles( std::vector<ResultTile>* result_tiles, std::map<std::pair<unsigned, uint64_t>, size_t>* result_tile_map, std::vector<bool>* single_fragment); Status copy_cells( const std::string& attribute, uint64_t stride, const std::vector<ResultCellSlab>& result_cell_slabs); Status copy_fixed_cells( const std::string& name, uint64_t stride, const std::vector<ResultCellSlab>& result_cell_slabs); Status copy_var_cells( const std::string& name, uint64_t stride, const std::vector<ResultCellSlab>& result_cell_slabs); Status compute_var_cell_destinations( const std::string& name, uint64_t stride, const std::vector<ResultCellSlab>& result_cell_slabs, std::vector<std::vector<uint64_t>>* offset_offsets_per_cs, std::vector<std::vector<uint64_t>>* var_offsets_per_cs, uint64_t* total_offset_size, uint64_t* total_var_size) const; template <class T> void compute_result_space_tiles( const Subarray& subarray, std::map<const T*, ResultSpaceTile<T>>* result_space_tiles) const; Status compute_result_coords( std::vector<ResultTile>* result_tiles, std::vector<ResultCoords>* result_coords); Status dedup_result_coords(std::vector<ResultCoords>* result_coords) const; Status dense_read(); template <class T> Status dense_read(); template <class T> Status fill_dense_coords(const Subarray& subarray); template <class T> Status fill_dense_coords_global( const Subarray& subarray, const std::vector<unsigned>& dim_idx, const std::vector<QueryBuffer*>& buffers, std::vector<uint64_t>* offsets); template <class T> Status fill_dense_coords_row_col( const Subarray& subarray, const std::vector<unsigned>& dim_idx, const std::vector<QueryBuffer*>& buffers, std::vector<uint64_t>* offsets); template <class T> void fill_dense_coords_row_slab( const T* start, uint64_t num, const std::vector<unsigned>& dim_idx, const std::vector<QueryBuffer*>& buffers, std::vector<uint64_t>* offsets) const; template <class T> void fill_dense_coords_col_slab( const T* start, uint64_t num, const std::vector<unsigned>& dim_idx, const std::vector<QueryBuffer*>& buffers, std::vector<uint64_t>* offsets) const; Status unfilter_tiles( const std::string& name, const std::vector<ResultTile*>& result_tiles, const std::vector<ResultCellSlab>* result_cell_slabs = nullptr) const; Status unfilter_tile( const std::string& name, Tile* tile, const std::forward_list<std::pair<uint64_t, uint64_t>>* result_cell_slab_ranges) const; Status unfilter_tile( const std::string& name, Tile* tile, Tile* tile_var, const std::forward_list<std::pair<uint64_t, uint64_t>>* result_cell_slab_ranges) const; Status get_all_result_coords( ResultTile* tile, std::vector<ResultCoords>* result_coords) const; bool has_coords() const; bool has_separate_coords() const; Status init_read_state(); Status init_tile( uint32_t format_version, const std::string& name, Tile* tile) const; Status init_tile( uint32_t format_version, const std::string& name, Tile* tile, Tile* tile_var) const; Status read_tiles( const std::string& name, const std::vector<ResultTile*>& result_tiles) const; Status read_tiles( const std::string& name, const std::vector<ResultTile*>& result_tiles, std::vector<std::future<Status>>* tasks) const; void reset_buffer_sizes(); Status sort_result_coords( std::vector<ResultCoords>* result_coords, Layout layout) const; Status sparse_read(); Status copy_coordinates( const std::vector<ResultTile*>& result_tiles, const std::vector<ResultCellSlab>& result_cell_slabs); Status copy_attribute_values( uint64_t stride, const std::vector<ResultTile*>& result_tiles, const std::vector<ResultCellSlab>& result_cell_slabs); void zero_out_buffer_sizes(); bool sparse_tile_overwritten(unsigned frag_idx, uint64_t tile_idx) const; void erase_coord_tiles(std::vector<ResultTile>* result_tiles) const; void get_dim_attr_stats() const; void get_result_cell_stats( const std::vector<ResultCellSlab>& result_cell_slabs) const; void get_result_tile_stats( const std::vector<ResultTile*>& result_tiles) const; }; } } #endif
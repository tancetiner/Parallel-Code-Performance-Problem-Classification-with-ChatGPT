#ifndef TILEDB_FILTER_PIPELINE_H #define TILEDB_FILTER_PIPELINE_H #include <forward_list> #include <memory> #include <utility> #include <vector> #include "tiledb/sm/filter/filter.h" #include "tiledb/sm/filter/filter_buffer.h" #include "tiledb/sm/misc/status.h" #include "tiledb/sm/tile/chunked_buffer.h" namespace tiledb { namespace sm { class Buffer; class EncryptionKey; class Tile; class FilterPipeline { public: FilterPipeline(); ~FilterPipeline() = default; FilterPipeline(const FilterPipeline& other); FilterPipeline(FilterPipeline&& other); FilterPipeline& operator=(const FilterPipeline& other); FilterPipeline& operator=(FilterPipeline&& other); Status add_filter(const Filter& filter); void clear(); const Tile* current_tile() const; Status deserialize(ConstBuffer* buff); void dump(FILE* out) const; template <typename T> T* get_filter() const { static_assert( std::is_base_of<Filter, T>::value, "Template type must derive from Filter."); for (auto& filter : filters_) { auto* ptr = dynamic_cast<T*>(filter.get()); if (ptr != nullptr) return ptr; } return nullptr; } Filter* get_filter(unsigned index) const; uint32_t max_chunk_size() const; Status run_forward(Tile* tile) const; Status run_reverse( Tile* tile, const Config& config, const std::forward_list<std::pair<uint64_t, uint64_t>>* result_cell_slab_ranges = nullptr) const; Status run_reverse( Tile* tile, Tile* tile_var, const Config& config, const std::forward_list<std::pair<uint64_t, uint64_t>>* result_cell_slab_ranges = nullptr) const; Status run_reverse_internal( Tile* tile, const Config& config, std::function<Status(uint64_t, bool*)>* skip_fn) const; Status serialize(Buffer* buff) const; void set_max_chunk_size(uint32_t max_chunk_size); unsigned size() const; bool empty() const; void swap(FilterPipeline& other); static Status append_encryption_filter( FilterPipeline* pipeline, const EncryptionKey& encryption_key); private: typedef std::pair<FilterBuffer, FilterBuffer> FilterBufferPair; std::vector<std::unique_ptr<Filter>> filters_; mutable const Tile* current_tile_; uint32_t max_chunk_size_; Status filter_chunks_forward( const ChunkedBuffer& input, Buffer* output) const; Status filter_chunks_reverse( const std::vector<std::tuple<void*, uint32_t, uint32_t, uint32_t, bool>>& input, ChunkedBuffer* output, bool unfiltering_all, const Config& config) const; Status skip_chunk_reversal_fixed( uint64_t chunk_length, uint64_t* cells_processed, uint64_t cell_size, std::forward_list<std::pair<uint64_t, uint64_t>>::const_iterator* cs_it, const std::forward_list<std::pair<uint64_t, uint64_t>>::const_iterator& cs_end, bool* skip) const; Status skip_chunk_reversal_var( uint64_t chunk_length, const uint64_t* d_off, uint64_t d_off_size, uint64_t* cells_processed, uint64_t* cells_size_processed, std::forward_list<std::pair<uint64_t, uint64_t>>::const_iterator* cs_it, const std::forward_list<std::pair<uint64_t, uint64_t>>::const_iterator& cs_end, bool* skip) const; Status skip_chunk_reversal_common( uint64_t chunk_cell_start, uint64_t chunk_cell_end, std::forward_list<std::pair<uint64_t, uint64_t>>::const_iterator* cs_it, const std::forward_list<std::pair<uint64_t, uint64_t>>::const_iterator& cs_end, bool* skip) const; }; } } #endif
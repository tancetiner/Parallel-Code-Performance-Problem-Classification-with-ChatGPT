#ifdef HAVE_CONFIG_H #include <config.h> #endif #include "sysstuff.h" #include "typedefs.h" #include "macros.h" #include "smalloc.h" #include "nsgrid.h" #include "gmx_fatal.h" #include "vec.h" #include "network.h" #include "domdec.h" #include "partdec.h" #include "pbc.h" #include <stdio.h> #include "futil.h" #include "pdbio.h" static void init_range_check() { sprintf(warn_buf,"Explanation: During neighborsearching, we assign each particle to a grid\n" "based on its coordinates. If your system contains collisions or parameter\n" "errors that give particles very high velocities you might end up with some\n" "coordinates being +-Infinity or NaN (not-a-number). Obviously, we cannot\n" "put these on a grid, so this is usually where we detect those errors.\n" "Make sure your system is properly energy-minimized and that the potential\n" "energy seems reasonable before trying again.\n"); } static void calc_x_av_stddev(int n,rvec *x,rvec av,rvec stddev) { dvec s1,s2; int i,d; clear_dvec(s1); clear_dvec(s2); for(i=0; i<n; i++) { for(d=0; d<DIM; d++) { s1[d] += x[i][d]; s2[d] += x[i][d]*x[i][d]; } } dsvmul(1.0/n,s1,s1); dsvmul(1.0/n,s2,s2); for(d=0; d<DIM; d++) { av[d] = s1[d]; stddev[d] = sqrt(s2[d] - s1[d]*s1[d]); } } void get_nsgrid_boundaries_vac(real av,real stddev, real *bound0,real *bound1, real *bdens0,real *bdens1) { *bound0 = av - NSGRID_STDDEV_FAC*stddev; *bound1 = av + NSGRID_STDDEV_FAC*stddev; *bdens0 = av - GRID_STDDEV_FAC*stddev; *bdens1 = av + GRID_STDDEV_FAC*stddev; } static void dd_box_bounds_to_ns_bounds(real box0,real box_size, real *gr0,real *gr1) { real av,stddev; av = box0 + 0.5*box_size; stddev = 0.5*box_size/GRID_STDDEV_FAC; *gr0 = av - NSGRID_STDDEV_FAC*stddev; *gr1 = av + NSGRID_STDDEV_FAC*stddev; } void get_nsgrid_boundaries(t_grid *grid, gmx_domdec_t *dd, matrix box,gmx_ddbox_t *ddbox,rvec *gr0,rvec *gr1, int ncg,rvec *cgcm, rvec grid_x0,rvec grid_x1, real *grid_density) { rvec av,stddev; real vol,bdens0,bdens1; int d; if (grid->nboundeddim < DIM) { calc_x_av_stddev(ncg,cgcm,av,stddev); } vol = 1; for(d=0; d<DIM; d++) { if (d < grid->nboundeddim || dd != NULL) { grid_x0[d] = (gr0 != NULL ? (*gr0)[d] : 0); grid_x1[d] = (gr1 != NULL ? (*gr1)[d] : box[d][d]); vol *= (grid_x1[d] - grid_x0[d]); } else { if (ddbox == NULL) { get_nsgrid_boundaries_vac(av[d],stddev[d], &grid_x0[d],&grid_x1[d], &bdens0,&bdens1); } else { dd_box_bounds_to_ns_bounds(ddbox->box0[d],ddbox->box_size[d], &grid_x0[d],&grid_x1[d]); bdens0 = grid_x0[d]; bdens1 = grid_x1[d]; } if (dd != NULL && gr0 != NULL && dd->ci[d] > 0) { grid_x0[d] = (*gr0)[d]; bdens0 = (*gr0)[d]; } if (dd != NULL && gr1 != NULL && dd->ci[d] < dd->nc[d]-1) { grid_x1[d] = (*gr1)[d]; bdens1 = (*gr1)[d]; } vol *= (bdens1 - bdens0); } } *grid_density = ncg/vol; } static void set_grid_sizes(matrix box,rvec izones_x0,rvec izones_x1,real rlist, const gmx_domdec_t *dd,const gmx_ddbox_t *ddbox, t_grid *grid, real grid_density) { int i,j; bool bDD,bDDRect; rvec av,stddev; rvec izones_size; real inv_r_ideal,size,add_tric; for(i=0; (i<DIM); i++) { if (debug) { fprintf(debug, "set_grid_sizes, i-zone bounds for dim %d: %6.3f %6.3f\n", i,izones_x0[i],izones_x1[i]); } izones_size[i] = izones_x1[i] - izones_x0[i]; } inv_r_ideal = pow(grid_density/grid->ncg_ideal,1.0/3.0); if (inv_r_ideal*rlist < 1) { inv_r_ideal = 1/rlist; } if (debug) { fprintf(debug,"CG density %f ideal ns cell size %f\n", grid_density,1/inv_r_ideal); } clear_rvec(grid->cell_offset); for(i=0; (i<DIM); i++) { grid->cell_offset[i] = izones_x0[i]; size = izones_size[i]; bDD = dd && (dd->nc[i] > 1); if (!bDD) { bDDRect = FALSE; } else { bDDRect = !(ddbox->tric_dir[i] || (dd->bGridJump && i != dd->dim[0])); if (bDDRect) { size += rlist; } else { size += rlist/ddbox->skew_fac[i]; } for(j=i+1; j<grid->npbcdim; j++) { if (box[j][i] != 0) { grid->cell_offset[i] += izones_x0[j]*box[j][i]/box[j][j]; add_tric = izones_size[j]*box[j][i]/box[j][j]; if (dd && dd->ndim == 1 && j == ZZ) { add_tric += -box[YY][XX]*box[ZZ][YY]/box[YY][YY]; } if (box[j][i] < 0) { grid->cell_offset[i] += add_tric; size -= add_tric; } else { size += add_tric; } } } } if (!bDDRect) { grid->n[i] = (int)(size*inv_r_ideal + 0.5); if (grid->n[i] < 2) { grid->n[i] = 2; } grid->cell_size[i] = size/grid->n[i]; grid->ncpddc[i] = 0; } else { grid->ncpddc[i] = (int)(izones_size[i]*inv_r_ideal + 0.5); if (grid->ncpddc[i] < 2) { grid->ncpddc[i] = 2; } grid->cell_size[i] = izones_size[i]/grid->ncpddc[i]; grid->n[i] = grid->ncpddc[i] + (int)(rlist/grid->cell_size[i]) + 1; } if (debug) { fprintf(debug,"grid dim %d size %d x %f: %f - %f\n", i,grid->n[i],grid->cell_size[i], grid->cell_offset[i], grid->cell_offset[i]+grid->n[i]*grid->cell_size[i]); } } if (debug) { fprintf(debug,"CG ncg ideal %d, actual density %.1f\n", grid->ncg_ideal,grid_density*grid->cell_size[XX]*grid->cell_size[YY]*grid->cell_size[ZZ]); } } t_grid *init_grid(FILE *fplog,t_forcerec *fr) { int d,m; char *ptr; t_grid *grid; snew(grid,1); grid->npbcdim = ePBC2npbcdim(fr->ePBC); if (fr->ePBC == epbcXY && fr->nwall == 2) { grid->nboundeddim = 3; } else { grid->nboundeddim = grid->npbcdim; } if (debug) { fprintf(debug,"The coordinates are bounded in %d dimensions\n", grid->nboundeddim); } grid->ncg_ideal = 10; ptr = getenv("GMX_NSCELL_NCG"); if (ptr) { sscanf(ptr,"%d",&grid->ncg_ideal); if (fplog) { fprintf(fplog,"Set ncg_ideal to %d\n",grid->ncg_ideal); } if (grid->ncg_ideal <= 0) { gmx_fatal(FARGS,"The number of cg's per cell should be > 0"); } } if (debug) { fprintf(debug,"Set ncg_ideal to %d\n",grid->ncg_ideal); } return grid; } void done_grid(t_grid *grid) { grid->nr = 0; clear_ivec(grid->n); grid->ncells = 0; sfree(grid->cell_index); sfree(grid->a); sfree(grid->index); sfree(grid->nra); grid->cells_nalloc = 0; sfree(grid->dcx2); sfree(grid->dcy2); sfree(grid->dcz2); grid->dc_nalloc = 0; if (debug) fprintf(debug,"Succesfully freed memory for grid pointers."); } int xyz2ci_(int nry,int nrz,int x,int y,int z) { return (nry*nrz*x+nrz*y+z); } void ci2xyz(t_grid *grid, int i, int *x, int *y, int *z) { int ci; range_check(i,0,grid->nr); ci = grid->cell_index[i]; *x = ci / (grid->n[YY]*grid->n[ZZ]); ci -= (*x)*grid->n[YY]*grid->n[ZZ]; *y = ci / grid->n[ZZ]; ci -= (*y)*grid->n[ZZ]; *z = ci; } static int ci_not_used(ivec n) { return xyz2ci(n[YY],n[ZZ],3*n[XX],3*n[YY],3*n[ZZ]); } static void set_grid_ncg(t_grid *grid,int ncg) { int nr_old,i; grid->nr = ncg; if (grid->nr+1 > grid->nr_alloc) { nr_old = grid->nr_alloc; grid->nr_alloc = over_alloc_dd(grid->nr) + 1; srenew(grid->cell_index,grid->nr_alloc); for(i=nr_old; i<grid->nr_alloc; i++) grid->cell_index[i] = 0; srenew(grid->a,grid->nr_alloc); } } void grid_first(FILE *fplog,t_grid *grid, gmx_domdec_t *dd,const gmx_ddbox_t *ddbox, int ePBC,matrix box,rvec izones_x0,rvec izones_x1, real rlistlong,real grid_density) { int i,m; ivec cx; init_range_check(); set_grid_sizes(box,izones_x0,izones_x1,rlistlong,dd,ddbox,grid,grid_density); grid->ncells = grid->n[XX]*grid->n[YY]*grid->n[ZZ]; if (grid->ncells+1 > grid->cells_nalloc) { grid->cells_nalloc = 2*grid->ncells; srenew(grid->nra, grid->cells_nalloc+1); srenew(grid->index,grid->cells_nalloc+1); if (fplog) fprintf(fplog,"Grid: %d x %d x %d cells\n", grid->n[XX],grid->n[YY],grid->n[ZZ]); } m = max(grid->n[XX],max(grid->n[YY],grid->n[ZZ])); if (m > grid->dc_nalloc) { grid->dc_nalloc = 2*m; srenew(grid->dcx2,grid->dc_nalloc); srenew(grid->dcy2,grid->dc_nalloc); srenew(grid->dcz2,grid->dc_nalloc); } grid->nr = 0; for(i=0; (i<grid->ncells); i++) { grid->nra[i] = 0; } } static void calc_bor(int cg0,int cg1,int ncg,int CG0[2],int CG1[2]) { if (cg1 > ncg) { CG0[0]=cg0; CG1[0]=ncg; CG0[1]=0; CG1[1]=cg1-ncg; } else { CG0[0]=cg0; CG1[0]=cg1; CG0[1]=0; CG1[1]=0; } if (debug) { int m; fprintf(debug,"calc_bor: cg0=%d, cg1=%d, ncg=%d\n",cg0,cg1,ncg); for(m=0; (m<2); m++) fprintf(debug,"CG0[%d]=%d, CG1[%d]=%d\n",m,CG0[m],m,CG1[m]); } } void calc_elemnr(FILE *fplog,t_grid *grid,int cg0,int cg1,int ncg) { int CG0[2],CG1[2]; int *cell_index=grid->cell_index; int *nra=grid->nra; int i,m,ncells; int ci,not_used; ncells=grid->ncells; if(ncells<=0) gmx_fatal(FARGS,"Number of grid cells is zero. Probably the system and box collapsed.\n"); not_used = ci_not_used(grid->n); calc_bor(cg0,cg1,ncg,CG0,CG1); for(m=0; (m<2); m++) for(i=CG0[m]; (i<CG1[m]); i++) { ci = cell_index[i]; if (ci != not_used) { range_check(ci,0,ncells); nra[ci]++; } } } void calc_ptrs(t_grid *grid) { int *index = grid->index; int *nra = grid->nra; int ix,iy,iz,ci,nr; int nnra,ncells; ncells=grid->ncells; if(ncells<=0) gmx_fatal(FARGS,"Number of grid cells is zero. Probably the system and box collapsed.\n"); ci=nr=0; for(ix=0; (ix < grid->n[XX]); ix++) for(iy=0; (iy < grid->n[YY]); iy++) for(iz=0; (iz < grid->n[ZZ]); iz++,ci++) { range_check(ci,0,ncells); index[ci] = nr; nnra = nra[ci]; nr += nnra; nra[ci] = 0; } } void grid_last(FILE *log,t_grid *grid,int cg0,int cg1,int ncg) { int CG0[2],CG1[2]; int i,m; int ci,not_used,ind,ncells; int *cell_index = grid->cell_index; int *nra = grid->nra; int *index = grid->index; int *a = grid->a; ncells=grid->ncells; if (ncells <= 0) gmx_fatal(FARGS,"Number of grid cells is zero. Probably the system and box collapsed.\n"); not_used = ci_not_used(grid->n); calc_bor(cg0,cg1,ncg,CG0,CG1); for(m=0; (m<2); m++) for(i=CG0[m]; (i<CG1[m]); i++) { ci = cell_index[i]; if (ci != not_used) { range_check(ci,0,ncells); ind = index[ci]+nra[ci]++; range_check(ind,0,grid->nr); a[ind] = i; } } } static void dump_nsgrid_pdb(char *fn,int n,rvec x[],t_grid *grid) { char format[STRLEN]; FILE *out; int i,cx,cy,cz; real *c; snew(c,grid->ncells); for(i=0; i<grid->ncells; i++) c[i] = 10*random()/(double)RAND_MAX; sprintf(format,"%s%s\n",pdbformat,"%6.2f%6.2f"); out = ffopen(fn,"w"); for(i=0; i<n; i++) { ci2xyz(grid,i,&cx,&cy,&cz); fprintf(out,format,"ATOM",1+i,"CA","GLY",' ',1+i, 10*x[i][XX] + 20*grid->cell_size[XX]*cx, 10*x[i][YY] + 20*grid->cell_size[YY]*cy, 10*x[i][ZZ] + 20*grid->cell_size[ZZ]*cz, 1.0,c[grid->cell_index[i]]); } fclose(out); sfree(c); } void fill_grid(FILE *log, gmx_domdec_zones_t *dd_zones, t_grid *grid,int ncg_tot, int cg0,int cg1,rvec cg_cm[]) { int *cell_index; int nrx,nry,nrz; rvec n_box,offset; int zone,ccg0,ccg1,cg,d,not_used; ivec shift0,b0,b1,ind; bool bUse; if (cg0 == -1) { cg0 = grid->nr; } set_grid_ncg(grid,ncg_tot); cell_index = grid->cell_index; nrx = grid->n[XX]; nry = grid->n[YY]; nrz = grid->n[ZZ]; for(d=0; d<DIM; d++) { if (grid->cell_size[d] > 0) { n_box[d] = 1/grid->cell_size[d]; } else { n_box[d] = 0; } } copy_rvec(grid->cell_offset,offset); if (debug) { fprintf(debug,"Filling grid from %d to %d\n",cg0,cg1); } debug_gmx(); if (dd_zones == NULL) { for (cg=cg0; cg<cg1; cg++) { for(d=0; d<DIM; d++) { ind[d] = (cg_cm[cg][d] - offset[d])*n_box[d]; if (ind[d] < 0) { ind[d] = 0; } else if (ind[d] >= grid->n[d]) { ind[d] = grid->n[d] - 1; } } cell_index[cg] = xyz2ci(nry,nrz,ind[XX],ind[YY],ind[ZZ]); } } else { for(zone=0; zone<dd_zones->n; zone++) { ccg0 = dd_zones->cg_range[zone]; ccg1 = dd_zones->cg_range[zone+1]; if (ccg1 <= cg0 || ccg0 >= cg1) { continue; } for(d=0; d<DIM; d++) { shift0[d] = dd_zones->shift[zone][d]; if (grid->ncpddc[d] == 0) { b0[d] = 0; b1[d] = grid->n[d]; } else { if (shift0[d] == 0) { b0[d] = 0; b1[d] = grid->ncpddc[d]; } else { b0[d] = grid->ncpddc[d]; b1[d] = grid->n[d]; } } } not_used = ci_not_used(grid->n); for(cg=ccg0; cg<ccg1; cg++) { if (cell_index[cg] == -1) { cell_index[cg] = 4*grid->ncells; continue; } bUse = TRUE; for(d=0; d<DIM; d++) { ind[d] = (cg_cm[cg][d] - offset[d])*n_box[d]; if (ind[d] < b0[d]) { ind[d] = b0[d]; } else if (ind[d] >= b1[d]) { if (shift0[d] == 0) { ind[d] = b1[d] - 1; } else { bUse = FALSE; } } } if (cg > grid->nr_alloc) { fprintf(stderr,"WARNING: nra_alloc %d cg0 %d cg1 %d cg %d\n", grid->nr_alloc,cg0,cg1,cg); } if (bUse) { cell_index[cg] = xyz2ci(nry,nrz,ind[XX],ind[YY],ind[ZZ]); } else { cell_index[cg] = not_used; } } } } debug_gmx(); } void check_grid(FILE *log,t_grid *grid) { int ix,iy,iz,ci,cci,nra; if(grid->ncells<=0) gmx_fatal(FARGS,"Number of grid cells is zero. Probably the system and box collapsed.\n"); ci=0; cci=0; for(ix=0; (ix<grid->n[XX]); ix++) for(iy=0; (iy<grid->n[YY]); iy++) for(iz=0; (iz<grid->n[ZZ]); iz++,ci++) { if (ci > 0) { nra=grid->index[ci]-grid->index[cci]; if (nra != grid->nra[cci]) gmx_fatal(FARGS,"nra=%d, grid->nra=%d, cci=%d", nra,grid->nra[cci],cci); } cci=xyz2ci(grid->n[YY],grid->n[ZZ],ix,iy,iz); range_check(cci,0,grid->ncells); if (cci != ci) gmx_fatal(FARGS,"ci = %d, cci = %d",ci,cci); } } void print_grid(FILE *log,t_grid *grid) { int i,nra,index; int ix,iy,iz,ci; fprintf(log,"nr: %d\n",grid->nr); fprintf(log,"nrx: %d\n",grid->n[XX]); fprintf(log,"nry: %d\n",grid->n[YY]); fprintf(log,"nrz: %d\n",grid->n[ZZ]); fprintf(log,"ncg_ideal: %d\n",grid->ncg_ideal); fprintf(log," i cell_index\n"); for(i=0; (i<grid->nr); i++) fprintf(log,"%5d %5d\n",i,grid->cell_index[i]); fprintf(log,"cells\n"); fprintf(log," ix iy iz nr index cgs...\n"); ci=0; for(ix=0; (ix<grid->n[XX]); ix++) for(iy=0; (iy<grid->n[YY]); iy++) for(iz=0; (iz<grid->n[ZZ]); iz++,ci++) { index=grid->index[ci]; nra=grid->nra[ci]; fprintf(log,"%3d%3d%3d%5d%5d",ix,iy,iz,nra,index); for(i=0; (i<nra); i++) fprintf(log,"%5d",grid->a[index+i]); fprintf(log,"\n"); } fflush(log); } void mv_grid(t_commrec *cr,t_grid *grid) { int i,start,nr; int cur=cr->nodeid; int *ci,*cgindex; #define next ((cur+1) % (cr->nnodes-cr->npmenodes)) ci = grid->cell_index; cgindex = pd_cgindex(cr); for(i=0; (i<cr->nnodes-1); i++) { start = cgindex[cur]; nr = cgindex[cur+1] - start; gmx_tx(cr,GMX_LEFT,&(ci[start]),nr*sizeof(*ci)); start = cgindex[next]; nr = cgindex[next+1] - start; gmx_rx(cr,GMX_RIGHT,&(ci[start]),nr*sizeof(*ci)); gmx_tx_wait(GMX_LEFT); gmx_rx_wait(GMX_RIGHT); cur=next; } }
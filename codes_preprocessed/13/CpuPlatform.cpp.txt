#include "CpuPlatform.h" #include "CpuKernelFactory.h" #include "CpuKernels.h" #include "openmm/internal/hardware.h" using namespace OpenMM; using namespace std; extern "C" OPENMM_EXPORT_CPU void registerPlatforms() { if (CpuPlatform::isProcessorSupported()) Platform::registerPlatform(new CpuPlatform()); } map<ContextImpl*, CpuPlatform::PlatformData*> CpuPlatform::contextData; CpuPlatform::CpuPlatform() { CpuKernelFactory* factory = new CpuKernelFactory(); registerKernelFactory(CalcForcesAndEnergyKernel::Name(), factory); registerKernelFactory(CalcNonbondedForceKernel::Name(), factory); registerKernelFactory(CalcGBSAOBCForceKernel::Name(), factory); } double CpuPlatform::getSpeed() const { return 10; } bool CpuPlatform::supportsDoublePrecision() const { return false; } bool CpuPlatform::isProcessorSupported() { int cpuInfo[4]; cpuid(cpuInfo, 0); if (cpuInfo[0] >= 1) { cpuid(cpuInfo, 1); return ((cpuInfo[2] & ((int) 1 << 19)) != 0); } return false; } void CpuPlatform::contextCreated(ContextImpl& context, const map<string, string>& properties) const { ReferencePlatform::contextCreated(context, properties); PlatformData* data = new PlatformData(context.getSystem().getNumParticles()); contextData[&context] = data; } void CpuPlatform::contextDestroyed(ContextImpl& context) const { PlatformData* data = contextData[&context]; delete data; contextData.erase(&context); } CpuPlatform::PlatformData& CpuPlatform::getPlatformData(ContextImpl& context) { return *contextData[&context]; } CpuPlatform::PlatformData::PlatformData(int numParticles) { posq.resize(4*numParticles); int numThreads = threads.getNumThreads(); threadForce.resize(numThreads); for (int i = 0; i < numThreads; i++) threadForce[i].resize(4*numParticles); isPeriodic = false; }
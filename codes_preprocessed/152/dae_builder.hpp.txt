#ifndef CASADI_DAE_BUILDER_HPP #define CASADI_DAE_BUILDER_HPP #include <unordered_map> #include "function.hpp" namespace casadi { class XmlNode; class DaeBuilder; #ifndef SWIG template<typename T> struct enum_traits {}; template<typename T> T to_enum(const std::string& s) { for (size_t i = 0; i < enum_traits<T>::n_enum; ++i) { if (s == to_string(static_cast<T>(i))) return static_cast<T>(i); } std::stringstream ss; ss << "No such enum: '" << s << "'. Permitted values: "; for (size_t i = 0; i < enum_traits<T>::n_enum; ++i) { if (i > 0) ss << ", "; ss << "'" << to_string(static_cast<T>(i)) << "'"; } casadi_error(ss.str()); return enum_traits<T>::n_enum; } struct CASADI_EXPORT Variable : public Printable<Variable> { enum Type {REAL, INTEGER, BOOLEAN, STRING, ENUM, N_TYPE}; enum Causality {PARAMETER, CALCULATED_PARAMETER, INPUT, OUTPUT, LOCAL, INDEPENDENT, N_CAUSALITY}; enum Variability {CONSTANT, FIXED, TUNABLE, DISCRETE, CONTINUOUS, N_VARIABILITY}; enum Initial {EXACT, APPROX, CALCULATED, INITIAL_NA, N_INITIAL}; Variable(const std::string& name = ""); std::string name; casadi_int value_reference; std::string description; Type type; Causality causality; Variability variability; Initial initial; std::string unit; std::string display_unit; double min; double max; double nominal; double start; casadi_int derivative; casadi_int antiderivative; bool dependency; MX v; std::string type_name() const {return "Variable";} void disp(std::ostream& stream, bool more=false) const; std::string get_str(bool more=false) const { std::stringstream ss; disp(ss, more); return ss.str(); } static Initial default_initial(Causality causality, Variability variability); }; template<> struct enum_traits<Variable::Type> { static const Variable::Type n_enum = Variable::N_TYPE; }; template<> struct enum_traits<Variable::Causality> { static const Variable::Causality n_enum = Variable::N_CAUSALITY; }; template<> struct enum_traits<Variable::Variability> { static const Variable::Variability n_enum = Variable::N_VARIABILITY; }; template<> struct enum_traits<Variable::Initial> { static const Variable::Initial n_enum = Variable::N_INITIAL; }; CASADI_EXPORT std::string to_string(Variable::Type v); CASADI_EXPORT std::string to_string(Variable::Causality v); CASADI_EXPORT std::string to_string(Variable::Variability v); CASADI_EXPORT std::string to_string(Variable::Initial v); #endif class CASADI_EXPORT DaeBuilder : public SWIG_IF_ELSE(PrintableCommon, Printable<DaeBuilder>) { public: DaeBuilder(); MX t; std::vector<MX> x, ode, lam_ode; std::vector<MX> z, alg, lam_alg; std::vector<MX> q, quad, lam_quad; std::vector<MX> y, ydef, lam_ydef; std::vector<MX> u; std::vector<MX> p; std::vector<MX> c, cdef; std::vector<MX> v, vdef, lam_vdef; std::vector<MX> aux; std::vector<MX> init; MX add_p(const std::string& name=std::string(), casadi_int n=1); MX add_u(const std::string& name=std::string(), casadi_int n=1); MX add_x(const std::string& name=std::string(), casadi_int n=1); MX add_z(const std::string& name=std::string(), casadi_int n=1); MX add_q(const std::string& name=std::string(), casadi_int n=1); MX add_v(const std::string& name, const MX& new_vdef); MX add_y(const std::string& name, const MX& new_ydef); void add_ode(const std::string& name, const MX& new_ode); void add_alg(const std::string& name, const MX& new_alg); void add_quad(const std::string& name, const MX& new_quad); MX add_aux(const std::string& name=std::string(), casadi_int n=1); void sanity_check() const; void register_x(const MX& new_x); void register_z(const MX& new_z); void register_v(const MX& new_v, const MX& new_vdef); void register_y(const MX& new_y, const MX& new_ydef); void lift(bool lift_shared = true, bool lift_calls = true); void eliminate_quad(); Function add_fun(const std::string& name, const std::vector<std::string>& arg, const std::vector<std::string>& res, const Dict& opts=Dict()); Function add_fun(const Function& f); Function add_fun(const std::string& name, const Importer& compiler, const Dict& opts=Dict()); bool has_fun(const std::string& name) const; Function fun(const std::string& name) const; void parse_fmi(const std::string& filename); #ifndef SWIG enum DaeBuilderIn { DAE_BUILDER_T, DAE_BUILDER_C, DAE_BUILDER_P, DAE_BUILDER_V, DAE_BUILDER_U, DAE_BUILDER_X, DAE_BUILDER_Z, DAE_BUILDER_Q, DAE_BUILDER_Y, DAE_BUILDER_NUM_IN }; enum DaeBuilderOut { DAE_BUILDER_VDEF, DAE_BUILDER_ODE, DAE_BUILDER_ALG, DAE_BUILDER_QUAD, DAE_BUILDER_YDEF, DAE_BUILDER_NUM_OUT }; static std::string name_in(DaeBuilderIn ind); static std::string name_in(); static DaeBuilderIn enum_in(const std::string& id); static std::vector<DaeBuilderIn> enum_in(const std::vector<std::string>& id); static std::string name_out(DaeBuilderOut ind); static std::string name_out(); static DaeBuilderOut enum_out(const std::string& id); static std::vector<DaeBuilderOut> enum_out(const std::vector<std::string>& id); std::vector<MX> input(DaeBuilderIn ind) const; std::vector<MX> output(DaeBuilderOut ind) const; std::vector<MX> input(const std::vector<DaeBuilderIn>& ind) const; std::vector<MX> output(const std::vector<DaeBuilderOut>& ind) const; #endif void add_lc(const std::string& name, const std::vector<std::string>& f_out); Function create(const std::string& fname, const std::vector<std::string>& s_in, const std::vector<std::string>& s_out, bool sx = false, bool lifted_calls = false) const; MX var(const std::string& name) const; MX operator()(const std::string& name) const {return var(name);} MX der(const std::string& name) const; MX der(const MX& var) const; std::string description(const std::string& name) const; void set_description(const std::string& name, const std::string& val); std::string type(const std::string& name) const; void set_type(const std::string& name, const std::string& val); std::string causality(const std::string& name) const; void set_causality(const std::string& name, const std::string& val); std::string variability(const std::string& name) const; void set_variability(const std::string& name, const std::string& val); std::string initial(const std::string& name) const; void set_initial(const std::string& name, const std::string& val); std::string unit(const std::string& name) const; std::string unit(const MX& var) const; void set_unit(const std::string& name, const std::string& val); std::string display_unit(const std::string& name) const; void set_display_unit(const std::string& name, const std::string& val); double min(const std::string& name) const; std::vector<double> min(const MX& var) const; void set_min(const std::string& name, double val); void set_min(const MX& var, const std::vector<double>& val); double max(const std::string& name) const; std::vector<double> max(const MX& var) const; void set_max(const std::string& name, double val); void set_max(const MX& var, const std::vector<double>& val); double nominal(const std::string& name) const; std::vector<double> nominal(const MX& var) const; void set_nominal(const std::string& name, double val); void set_nominal(const MX& var, const std::vector<double>& val); double start(const std::string& name) const; std::vector<double> start(const MX& var) const; void set_start(const std::string& name, double val); void set_start(const MX& var, const std::vector<double>& val); std::string type_name() const {return "DaeBuilder";} void disp(std::ostream& stream, bool more=false) const; std::string get_str(bool more=false) const { std::stringstream ss; disp(ss, more); return ss.str(); } void add_variable(const std::string& name, const Variable& var); MX add_variable(const std::string& name, casadi_int n=1); MX add_variable(const std::string& name, const Sparsity& sp); void add_variable(const MX& new_v); bool has_variable(const std::string& name) const; Variable& variable(const std::string& name); const Variable& variable(const std::string& name) const; const Function& oracle(bool sx = false, bool elim_v = false, bool lifted_calls = false) const; #ifndef SWIG protected: static std::string qualified_name(const XmlNode& nn); std::vector<Variable> variables_; std::unordered_map<std::string, size_t> varind_; Function::AuxOut lc_; std::vector<Function> fun_; mutable Function oracle_[2][2][2]; MX read_expr(const XmlNode& node); Variable& read_variable(const XmlNode& node); typedef double (DaeBuilder::*getAtt)(const std::string& name) const; std::vector<double> attribute(getAtt f, const MX& var) const; typedef MX (DaeBuilder::*getAttS)(const std::string& name) const; MX attribute(getAttS f, const MX& var) const; typedef void (DaeBuilder::*setAtt)(const std::string& name, double val); void set_attribute(setAtt f, const MX& var, const std::vector<double>& val); typedef void (DaeBuilder::*setAttS)(const std::string& name, const MX& val); void set_attribute(setAttS f, const MX& var, const MX& val); void clear_cache(); struct CallIO { Function f, adj1_f, J, H; std::vector<size_t> v, vdef; std::vector<MX> arg; std::vector<MX> res; std::vector<MX> jac_res; std::vector<MX> adj1_arg; std::vector<MX> adj1_res; std::vector<MX> hess_res; void calc_jac(); void calc_grad(); void calc_hess(); const MX& jac(casadi_int oind, casadi_int iind) const; const MX& hess(casadi_int iind1, casadi_int iind2) const; }; MX jac_vdef_v_from_calls(std::map<MXNode*, CallIO>& call_nodes, const std::vector<casadi_int>& h_offsets) const; MX hess_v_v_from_calls(std::map<MXNode*, CallIO>& call_nodes, const std::vector<casadi_int>& h_offsets) const; #endif }; } #endif
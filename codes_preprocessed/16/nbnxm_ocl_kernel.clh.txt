#include "nbnxm_ocl_kernel_utils.clh" #if defined EL_EWALD_ANA || defined EL_EWALD_TAB # define EL_EWALD_ANY #endif #if defined EL_EWALD_ANY || defined EL_RF || defined LJ_EWALD \ || (defined EL_CUTOFF && defined CALC_ENERGIES) # define EXCLUSION_FORCES #endif #if defined LJ_EWALD_COMB_GEOM || defined LJ_EWALD_COMB_LB # define LJ_EWALD #endif #if defined LJ_COMB_GEOM || defined LJ_COMB_LB # define LJ_COMB #endif __attribute__((reqd_work_group_size(CL_SIZE, CL_SIZE, 1))) #ifdef cl_intel_required_subgroup_size __attribute__((intel_reqd_sub_group_size(SUBGROUP_SIZE))) #endif #ifdef PRUNE_NBL # ifdef CALC_ENERGIES __kernel void NB_KERNEL_FUNC_NAME(nbnxn_kernel, _VF_prune_opencl) # else __kernel void NB_KERNEL_FUNC_NAME(nbnxn_kernel, _F_prune_opencl) # endif #else # ifdef CALC_ENERGIES __kernel void NB_KERNEL_FUNC_NAME(nbnxn_kernel, _VF_opencl) # else __kernel void NB_KERNEL_FUNC_NAME(nbnxn_kernel, _F_opencl) # endif #endif ( #ifndef LJ_COMB int ntypes, #endif cl_nbparam_params_t nbparam_params, const __global float4* restrict xq, __global float* restrict f, __global float* restrict gmx_unused e_lj, __global float* restrict gmx_unused e_el, __global float* restrict fshift, #ifdef LJ_COMB const __global float2* restrict lj_comb, #else const __global int* restrict atom_types, #endif const __global float* restrict shift_vec, __constant const float* gmx_unused nbfp_climg2d, __constant const float* gmx_unused nbfp_comb_climg2d, __constant const float* gmx_unused coulomb_tab_climg2d, const __global nbnxn_sci_t* pl_sci, #ifndef PRUNE_NBL const #endif __global nbnxn_cj4_t* pl_cj4, const __global nbnxn_excl_t* excl, int bCalcFshift, __local float4* xqib ) { const cl_nbparam_params_t* const nbparam = &nbparam_params; const float rcoulomb_sq = nbparam->rcoulomb_sq; #ifdef VDW_CUTOFF_CHECK const float rvdw_sq = nbparam_params.rvdw_sq; #endif #ifdef EL_RF const float two_k_rf = nbparam->two_k_rf; #endif #ifdef EL_EWALD_TAB const float coulomb_tab_scale = nbparam->coulomb_tab_scale; #endif #ifdef EL_EWALD_ANA const float beta2 = nbparam->ewald_beta * nbparam->ewald_beta; const float beta3 = nbparam->ewald_beta * nbparam->ewald_beta * nbparam->ewald_beta; #endif #ifdef PRUNE_NBL const float rlist_sq = nbparam->rlistOuter_sq; #endif #ifdef CALC_ENERGIES # ifdef EL_EWALD_ANY const float beta = nbparam->ewald_beta; const float ewald_shift = nbparam->sh_ewald; # else const float gmx_unused c_rf = nbparam->c_rf; # endif #endif const int tidxi = get_local_id(0); const int tidxj = get_local_id(1); const int tidx = (int)(get_local_id(1) * get_local_size(0) + get_local_id(0)); const int bidx = get_group_id(0); const int widx = tidx / WARP_SIZE; const unsigned superClInteractionMask = ((1U << c_nbnxnGpuNumClusterPerSupercluster) - 1U); #define LOCAL_OFFSET (xqib + c_nbnxnGpuNumClusterPerSupercluster * CL_SIZE) CjType cjs = 0; #if USE_CJ_PREFETCH cjs = (__local int*)(LOCAL_OFFSET); # undef LOCAL_OFFSET # define LOCAL_OFFSET (cjs + 2 * c_nbnxnGpuJgroupSize) #endif #ifdef IATYPE_SHMEM # ifndef LJ_COMB __local int* atib = (__local int*)(LOCAL_OFFSET); # undef LOCAL_OFFSET # define LOCAL_OFFSET (atib + c_nbnxnGpuNumClusterPerSupercluster * CL_SIZE) # else __local float2* ljcpib = (__local float2*)(LOCAL_OFFSET); # undef LOCAL_OFFSET # define LOCAL_OFFSET (ljcpib + c_nbnxnGpuNumClusterPerSupercluster * CL_SIZE) # endif #endif #if !REDUCE_SHUFFLE __local float* f_buf = (__local float*)(LOCAL_OFFSET); # undef LOCAL_OFFSET # define LOCAL_OFFSET (f_buf + CL_SIZE * CL_SIZE * 3) #else __local float* f_buf = 0; #endif #if !USE_SUBGROUP_ANY volatile __local int* warp_any = (__local int*)(LOCAL_OFFSET); #else __local int gmx_unused* warp_any = 0; #endif #undef LOCAL_OFFSET const nbnxn_sci_t nb_sci = pl_sci[bidx]; const int sci = nb_sci.sci; const int cij4_start = nb_sci.cj4_ind_start; const int cij4_end = nb_sci.cj4_ind_end; for (int i = 0; i < c_nbnxnGpuNumClusterPerSupercluster; i += CL_SIZE) { const int ci = sci * c_nbnxnGpuNumClusterPerSupercluster + tidxj + i; const int ai = ci * CL_SIZE + tidxi; float4 xqbuf = xq[ai] + (float4)(shift_vec[3 * nb_sci.shift], shift_vec[3 * nb_sci.shift + 1], shift_vec[3 * nb_sci.shift + 2], 0.0F); xqbuf.w *= nbparam->epsfac; xqib[(tidxj + i) * CL_SIZE + tidxi] = xqbuf; #ifdef IATYPE_SHMEM # ifndef LJ_COMB atib[(tidxj + i) * CL_SIZE + tidxi] = atom_types[ai]; # else ljcpib[(tidxj + i) * CL_SIZE + tidxi] = lj_comb[ai]; # endif #endif } #if !USE_SUBGROUP_ANY if (tidx == 0 || tidx == WARP_SIZE) { warp_any[widx] = 0; } #endif barrier(CLK_LOCAL_MEM_FENCE); float3 fci_buf[c_nbnxnGpuNumClusterPerSupercluster]; for (int ci_offset = 0; ci_offset < c_nbnxnGpuNumClusterPerSupercluster; ci_offset++) { fci_buf[ci_offset] = (float3)(0.0F); } #ifdef LJ_EWALD const float lje_coeff2 = nbparam->ewaldcoeff_lj * nbparam->ewaldcoeff_lj; const float lje_coeff6_6 = lje_coeff2 * lje_coeff2 * lje_coeff2 * ONE_SIXTH_F; #endif #ifdef CALC_ENERGIES float E_lj = 0.0F; float E_el = 0.0F; # if defined EXCLUSION_FORCES if (nb_sci.shift == CENTRAL && pl_cj4[cij4_start].cj[0] == sci * c_nbnxnGpuNumClusterPerSupercluster) { for (int i = 0; i < c_nbnxnGpuNumClusterPerSupercluster; i++) { # if defined EL_EWALD_ANY || defined EL_RF || defined EL_CUTOFF const float qi = xqib[i * CL_SIZE + tidxi].w; E_el += qi * qi; # endif # if defined LJ_EWALD E_lj += nbfp_climg2d[atom_types[(sci * c_nbnxnGpuNumClusterPerSupercluster + i) * CL_SIZE + tidxi] * (ntypes + 1) * 2]; # endif } # ifdef LJ_EWALD E_lj /= CL_SIZE; E_lj *= HALF_F * ONE_SIXTH_F * lje_coeff6_6; # endif # if defined EL_EWALD_ANY || defined EL_RF || defined EL_CUTOFF E_el /= nbparam->epsfac * CL_SIZE; # if defined EL_RF || defined EL_CUTOFF E_el *= -HALF_F * c_rf; # else E_el *= -beta * M_FLOAT_1_SQRTPI; # endif # endif } # endif #endif #ifdef EXCLUSION_FORCES const int nonSelfInteraction = !(nb_sci.shift == CENTRAL & tidxj <= tidxi); #endif for (int j4 = cij4_start; j4 < cij4_end; j4++) { const int wexcl_idx = pl_cj4[j4].imei[widx].excl_ind; unsigned int imask = pl_cj4[j4].imei[widx].imask; const unsigned int wexcl = excl[wexcl_idx].pair[(tidx) & (WARP_SIZE - 1)]; preloadCj4(&cjs, pl_cj4[j4].cj, tidxi, tidxj, imask != 0U); #ifndef PRUNE_NBL if (imask) #endif { #if !defined PRUNE_NBL && !defined _NVIDIA_SOURCE_ # pragma unroll 4 #endif for (int jm = 0; jm < c_nbnxnGpuJgroupSize; jm++) { if (imask & (superClInteractionMask << (jm * c_nbnxnGpuNumClusterPerSupercluster))) { unsigned int mask_ji = (1U << (jm * c_nbnxnGpuNumClusterPerSupercluster)); const int cj = loadCj(cjs, pl_cj4[j4].cj, jm, tidxi, tidxj); const int aj = cj * CL_SIZE + tidxj; const float4 xjqbuf = xq[aj]; const float3 xj = (float3)(xjqbuf.xyz); const float qj_f = xjqbuf.w; #ifndef LJ_COMB const int typej = atom_types[aj]; #else const float2 ljcp_j = lj_comb[aj]; #endif float3 fcj_buf = (float3)(0.0F); #if !defined PRUNE_NBL # pragma unroll 8 #endif for (int i = 0; i < c_nbnxnGpuNumClusterPerSupercluster; i++) { if (imask & mask_ji) { const int gmx_unused ci = sci * c_nbnxnGpuNumClusterPerSupercluster + i; const float4 xiqbuf = xqib[i * CL_SIZE + tidxi]; const float3 xi = (float3)(xiqbuf.xyz); const float3 rv = xi - xj; float r2 = norm2(rv); #ifdef PRUNE_NBL if (!gmx_sub_group_any(warp_any, widx, r2 < rlist_sq)) { imask &= ~mask_ji; } #endif const float int_bit = (wexcl & mask_ji) ? 1.0F : 0.0F; #ifdef EXCLUSION_FORCES if ((r2 < rcoulomb_sq) * (nonSelfInteraction | (ci != cj))) #else if ((float)(r2 < rcoulomb_sq) * int_bit != 0.0F) #endif { const float qi = xiqbuf.w; #ifdef IATYPE_SHMEM # ifndef LJ_COMB const int typei = atib[i * CL_SIZE + tidxi]; # else const float2 ljcp_i = ljcpib[i * CL_SIZE + tidxi]; # endif #else const int ai = ci * CL_SIZE + tidxi; # ifndef LJ_COMB const int typei = atom_types[ai]; # else const float2 ljcp_i = lj_comb[ai]; # endif #endif #ifndef LJ_COMB const float c6 = nbfp_climg2d[2 * (ntypes * typei + typej)]; const float c12 = nbfp_climg2d[2 * (ntypes * typei + typej) + 1]; #else # ifdef LJ_COMB_GEOM const float c6 = ljcp_i.x * ljcp_j.x; const float c12 = ljcp_i.y * ljcp_j.y; # else const float sigma = ljcp_i.x + ljcp_j.x; const float epsilon = ljcp_i.y * ljcp_j.y; # if defined CALC_ENERGIES || defined LJ_FORCE_SWITCH || defined LJ_POT_SWITCH const float2 c6c12 = convert_sigma_epsilon_to_c6_c12(sigma, epsilon); const float c6 = c6c12.x; const float c12 = c6c12.y; # endif # endif #endif r2 = max(r2, c_nbnxnMinDistanceSquared); const float inv_r = rsqrt(r2); const float inv_r2 = inv_r * inv_r; #if !defined LJ_COMB_LB || defined CALC_ENERGIES float inv_r6 = inv_r2 * inv_r2 * inv_r2; # if defined EXCLUSION_FORCES inv_r6 *= int_bit; # endif float F_invr = inv_r6 * (c12 * inv_r6 - c6) * inv_r2; # if defined CALC_ENERGIES || defined LJ_POT_SWITCH float E_lj_p = int_bit * (c12 * (inv_r6 * inv_r6 + nbparam->repulsion_shift.cpot) * ONE_TWELVETH_F - c6 * (inv_r6 + nbparam->dispersion_shift.cpot) * ONE_SIXTH_F); # endif #else const float sig_r = sigma * inv_r; const float sig_r2 = sig_r * sig_r; float sig_r6 = sig_r2 * sig_r2 * sig_r2; # if defined EXCLUSION_FORCES sig_r6 *= int_bit; # endif float F_invr = epsilon * sig_r6 * (sig_r6 - 1.0F) * inv_r2; #endif #ifdef LJ_FORCE_SWITCH # ifdef CALC_ENERGIES calculate_force_switch_F_E(nbparam, c6, c12, inv_r, r2, &F_invr, &E_lj_p); # else calculate_force_switch_F(nbparam, c6, c12, inv_r, r2, &F_invr); # endif #endif #ifdef LJ_EWALD # ifdef LJ_EWALD_COMB_GEOM # ifdef CALC_ENERGIES calculate_lj_ewald_comb_geom_F_E( nbfp_comb_climg2d, nbparam, typei, typej, r2, inv_r2, lje_coeff2, lje_coeff6_6, int_bit, &F_invr, &E_lj_p); # else calculate_lj_ewald_comb_geom_F(nbfp_comb_climg2d, typei, typej, r2, inv_r2, lje_coeff2, lje_coeff6_6, &F_invr); # endif # elif defined LJ_EWALD_COMB_LB calculate_lj_ewald_comb_LB_F_E(nbfp_comb_climg2d, nbparam, typei, typej, r2, inv_r2, lje_coeff2, lje_coeff6_6, # ifdef CALC_ENERGIES int_bit, true, &F_invr, &E_lj_p # else 0, false, &F_invr, 0 # endif ); # endif #endif #ifdef LJ_POT_SWITCH # ifdef CALC_ENERGIES calculate_potential_switch_F_E(nbparam, inv_r, r2, &F_invr, &E_lj_p); # else calculate_potential_switch_F(nbparam, inv_r, r2, &F_invr, &E_lj_p); # endif #endif #ifdef VDW_CUTOFF_CHECK const float vdw_in_range = (r2 < rvdw_sq) ? 1.0F : 0.0F; F_invr *= vdw_in_range; # ifdef CALC_ENERGIES E_lj_p *= vdw_in_range; # endif #endif #ifdef CALC_ENERGIES E_lj += E_lj_p; #endif #ifdef EL_CUTOFF # ifdef EXCLUSION_FORCES F_invr += qi * qj_f * int_bit * inv_r2 * inv_r; # else F_invr += qi * qj_f * inv_r2 * inv_r; # endif #endif #ifdef EL_RF F_invr += qi * qj_f * (int_bit * inv_r2 * inv_r - two_k_rf); #endif #if defined EL_EWALD_ANA F_invr += qi * qj_f * (int_bit * inv_r2 * inv_r + pmecorrF(beta2 * r2) * beta3); #elif defined EL_EWALD_TAB F_invr += qi * qj_f * (int_bit * inv_r2 - interpolate_coulomb_force_r(coulomb_tab_climg2d, r2 * inv_r, coulomb_tab_scale)) * inv_r; #endif #ifdef CALC_ENERGIES # ifdef EL_CUTOFF E_el += qi * qj_f * (int_bit * inv_r - c_rf); # endif # ifdef EL_RF E_el += qi * qj_f * (int_bit * inv_r + HALF_F * two_k_rf * r2 - c_rf); # endif # ifdef EL_EWALD_ANY E_el += qi * qj_f * (inv_r * (int_bit - erf(r2 * inv_r * beta)) - int_bit * ewald_shift); # endif #endif const float3 f_ij = rv * F_invr; fcj_buf -= f_ij; fci_buf[i] += f_ij; } } mask_ji += mask_ji; } reduce_force_j(f_buf, fcj_buf, f, tidxi, tidxj, aj); } } #ifdef PRUNE_NBL pl_cj4[j4].imei[widx].imask = imask; #endif } } if (nb_sci.shift == CENTRAL) { bCalcFshift = 0; } reduce_force_i_and_shift(f_buf, fci_buf, f, bCalcFshift != 0, tidxi, tidxj, sci, nb_sci.shift, fshift); #ifdef CALC_ENERGIES reduce_energy(f_buf, E_lj, E_el, e_lj, e_el, tidx); #endif } #undef EL_EWALD_ANY #undef EXCLUSION_FORCES #undef LJ_EWALD #undef LJ_COMB #undef USE_CJ_PREFETCH
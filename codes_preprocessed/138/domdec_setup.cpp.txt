#include "gmxpre.h" #include <assert.h> #include <stdio.h> #include <cmath> #include "gromacs/legacyheaders/domdec.h" #include "gromacs/legacyheaders/names.h" #include "gromacs/legacyheaders/network.h" #include "gromacs/legacyheaders/perf_est.h" #include "gromacs/legacyheaders/typedefs.h" #include "gromacs/legacyheaders/types/commrec.h" #include "gromacs/math/vec.h" #include "gromacs/utility/smalloc.h" #define DD_GRID_MARGIN_PRES_SCALE 1.05 static int factorize(int n, int **fac, int **mfac) { int d, ndiv; if (n <= 0) { gmx_fatal(FARGS, "Can only factorize positive integers."); } snew(*fac, n/2); snew(*mfac, n/2); d = 2; ndiv = 0; while (n > 1) { while (n % d == 0) { if (ndiv == 0 || (*fac)[ndiv-1] != d) { ndiv++; (*fac)[ndiv-1] = d; } (*mfac)[ndiv-1]++; n /= d; } d++; } return ndiv; } static gmx_bool largest_divisor(int n) { int ndiv, *div, *mdiv, ldiv; ndiv = factorize(n, &div, &mdiv); ldiv = div[ndiv-1]; sfree(div); sfree(mdiv); return ldiv; } static int lcd(int n1, int n2) { int d, i; d = 1; for (i = 2; (i <= n1 && i <= n2); i++) { if (n1 % i == 0 && n2 % i == 0) { d = i; } } return d; } static gmx_bool fits_pme_ratio(int nnodes, int npme, float ratio) { return ((double)npme/(double)nnodes > 0.95*ratio); } static gmx_bool fits_pp_pme_perf(int nnodes, int npme, float ratio) { int ndiv, *div, *mdiv, ldiv; int npp_root3, npme_root2; ndiv = factorize(nnodes-npme, &div, &mdiv); ldiv = div[ndiv-1]; sfree(div); sfree(mdiv); npp_root3 = static_cast<int>(std::pow(nnodes-npme, 1.0/3.0) + 0.5); npme_root2 = static_cast<int>(std::sqrt(static_cast<double>(npme)) + 0.5); if (ldiv > 3 + npp_root3) { return FALSE; } if (lcd(nnodes-npme, npme)*2 < npme_root2) { return FALSE; } return fits_pme_ratio(nnodes, npme, ratio); } static int guess_npme(FILE *fplog, gmx_mtop_t *mtop, t_inputrec *ir, matrix box, int nnodes) { float ratio; int npme; ratio = pme_load_estimate(mtop, ir, box); if (fplog) { fprintf(fplog, "Guess for relative PME load: %.2f\n", ratio); } if (!fits_pme_ratio(nnodes, nnodes/2, ratio)) { return 0; } npme = (nnodes + 15)/16; while (npme <= nnodes/3) { if (nnodes % npme == 0) { if (fits_pp_pme_perf(nnodes, npme, ratio)) { break; } } npme++; } if (npme > nnodes/3) { npme = 1; while (npme <= nnodes/2) { if (fits_pp_pme_perf(nnodes, npme, ratio)) { break; } npme++; } } if (npme > nnodes/2) { gmx_fatal(FARGS, "Could not find an appropriate number of separate PME ranks. i.e. >= %5f*#ranks (%d) and <= #ranks/2 (%d) and reasonable performance wise (grid_x=%d, grid_y=%d).\n" "Use the -npme option of mdrun or change the number of ranks or the PME grid dimensions, see the manual for details.", ratio, (int)(0.95*ratio*nnodes+0.5), nnodes/2, ir->nkx, ir->nky); npme = 0; } else { if (fplog) { fprintf(fplog, "Will use %d particle-particle and %d PME only ranks\n" "This is a guess, check the performance at the end of the log file\n", nnodes-npme, npme); } fprintf(stderr, "\n" "Will use %d particle-particle and %d PME only ranks\n" "This is a guess, check the performance at the end of the log file\n", nnodes-npme, npme); } return npme; } static int div_up(int n, int f) { return (n + f - 1)/f; } real comm_box_frac(ivec dd_nc, real cutoff, gmx_ddbox_t *ddbox) { int i, j, k; rvec bt, nw; real comm_vol; for (i = 0; i < DIM; i++) { bt[i] = ddbox->box_size[i]*ddbox->skew_fac[i]; nw[i] = dd_nc[i]*cutoff/bt[i]; } comm_vol = 0; for (i = 0; i < DIM; i++) { if (dd_nc[i] > 1) { comm_vol += nw[i]; for (j = i+1; j < DIM; j++) { if (dd_nc[j] > 1) { comm_vol += nw[i]*nw[j]*M_PI/4; for (k = j+1; k < DIM; k++) { if (dd_nc[k] > 1) { comm_vol += nw[i]*nw[j]*nw[k]*M_PI/6; } } } } } } return comm_vol; } static gmx_bool inhomogeneous_z(const t_inputrec *ir) { return ((EEL_PME(ir->coulombtype) || ir->coulombtype == eelEWALD) && ir->ePBC == epbcXYZ && ir->ewald_geometry == eewg3DC); } static float comm_pme_cost_vol(int npme, int a, int b, int c) { float comm_vol; comm_vol = npme - 1; comm_vol *= npme; comm_vol *= div_up(a, npme); comm_vol *= div_up(b, npme); comm_vol *= c; return comm_vol; } static float comm_cost_est(real limit, real cutoff, matrix box, gmx_ddbox_t *ddbox, int natoms, t_inputrec *ir, float pbcdxr, int npme_tot, ivec nc) { ivec npme = {1, 1, 1}; int i, j, nk, overlap; rvec bt; float comm_vol, comm_vol_xf, comm_pme, cost_pbcdx; float pbcdx_rect_fac = 0.1; float pbcdx_tric_fac = 0.2; float temp; if ((ir->ePBC == epbcXY && ir->nwall < 2 && nc[ZZ] > 1) || (ir->ePBC == epbcSCREW && (nc[XX] == 1 || nc[YY] > 1 || nc[ZZ] > 1))) { return -1; } if (inhomogeneous_z(ir) && nc[ZZ] > 1) { return -1; } assert(ddbox->npbcdim <= DIM); for (i = 0; i < DIM; i++) { for (j = i+1; j < ddbox->npbcdim; j++) { if (box[j][i] != 0 || ir->deform[j][i] != 0 || (ir->epc != epcNO && ir->compress[j][i] != 0)) { if (nc[j] > 1 && nc[i] == 1) { return -1; } } } } for (i = 0; i < DIM; i++) { bt[i] = ddbox->box_size[i]*ddbox->skew_fac[i]; if (!(i >= ddbox->npbcdim && nc[i] <= 2) && bt[i] < nc[i]*limit) { return -1; } if (i < ddbox->npbcdim && nc[i] > 1 && (nc[i] - 1)*bt[i] < nc[i]*cutoff) { return -1; } } if (npme_tot > 1) { if (nc[XX] == 1 && nc[YY] > 1) { npme[XX] = 1; npme[YY] = npme_tot; } else if (nc[YY] == 1) { npme[XX] = npme_tot; npme[YY] = 1; } else { npme[XX] = (npme_tot % nc[XX] == 0) ? nc[XX] : npme_tot; npme[YY] = npme_tot/npme[XX]; } } for (i = 0; i < DIM; i++) { for (j = i+1; j < DIM; j++) { if (fabs(bt[j] - bt[i]) < 0.01*bt[i] && nc[j] > nc[i]) { if (npme_tot <= 1 || !((i == XX && j == YY && nc[YY] != npme[YY]) || (i == YY && j == ZZ && npme[YY] > 1))) { return -1; } } } } comm_vol = comm_box_frac(nc, cutoff, ddbox); comm_pme = 0; for (i = 0; i < 2; i++) { if (nc[i] % npme[i] != 0) { if (nc[i] > npme[i]) { comm_vol_xf = (npme[i] == 2 ? 1.0/3.0 : 0.5); } else { comm_vol_xf = 1.0 - lcd(nc[i], npme[i])/(double)npme[i]; } comm_pme += 3*natoms*comm_vol_xf; } if (npme[i] > 1) { nk = (i == 0 ? ir->nkx : ir->nky); overlap = (nk % npme[i] == 0 ? ir->pme_order-1 : ir->pme_order); temp = npme[i]; temp *= overlap; temp *= ir->nkx; temp *= ir->nky; temp *= ir->nkz; temp /= nk; comm_pme += temp; } } comm_pme += comm_pme_cost_vol(npme[YY], ir->nky, ir->nkz, ir->nkx); comm_pme += comm_pme_cost_vol(npme[XX], ir->nkx, ir->nky, ir->nkz); cost_pbcdx = 0; if ((nc[XX] == 1 || nc[YY] == 1) || (nc[ZZ] == 1 && ir->ePBC != epbcXY)) { if ((ddbox->tric_dir[XX] && nc[XX] == 1) || (ddbox->tric_dir[YY] && nc[YY] == 1)) { cost_pbcdx = pbcdxr*pbcdx_tric_fac; } else { cost_pbcdx = pbcdxr*pbcdx_rect_fac; } } if (debug) { fprintf(debug, "nc %2d %2d %2d %2d %2d vol pp %6.4f pbcdx %6.4f pme %9.3e tot %9.3e\n", nc[XX], nc[YY], nc[ZZ], npme[XX], npme[YY], comm_vol, cost_pbcdx, comm_pme, 3*natoms*(comm_vol + cost_pbcdx) + comm_pme); } return 3*natoms*(comm_vol + cost_pbcdx) + comm_pme; } static void assign_factors(gmx_domdec_t *dd, real limit, real cutoff, matrix box, gmx_ddbox_t *ddbox, int natoms, t_inputrec *ir, float pbcdxr, int npme, int ndiv, int *div, int *mdiv, ivec ir_try, ivec opt) { int x, y, i; float ce; if (ndiv == 0) { ce = comm_cost_est(limit, cutoff, box, ddbox, natoms, ir, pbcdxr, npme, ir_try); if (ce >= 0 && (opt[XX] == 0 || ce < comm_cost_est(limit, cutoff, box, ddbox, natoms, ir, pbcdxr, npme, opt))) { copy_ivec(ir_try, opt); } return; } for (x = mdiv[0]; x >= 0; x--) { for (i = 0; i < x; i++) { ir_try[XX] *= div[0]; } for (y = mdiv[0]-x; y >= 0; y--) { for (i = 0; i < y; i++) { ir_try[YY] *= div[0]; } for (i = 0; i < mdiv[0]-x-y; i++) { ir_try[ZZ] *= div[0]; } assign_factors(dd, limit, cutoff, box, ddbox, natoms, ir, pbcdxr, npme, ndiv-1, div+1, mdiv+1, ir_try, opt); for (i = 0; i < mdiv[0]-x-y; i++) { ir_try[ZZ] /= div[0]; } for (i = 0; i < y; i++) { ir_try[YY] /= div[0]; } } for (i = 0; i < x; i++) { ir_try[XX] /= div[0]; } } } static real optimize_ncells(FILE *fplog, int nnodes_tot, int npme_only, gmx_bool bDynLoadBal, real dlb_scale, gmx_mtop_t *mtop, matrix box, gmx_ddbox_t *ddbox, t_inputrec *ir, gmx_domdec_t *dd, real cellsize_limit, real cutoff, gmx_bool bInterCGBondeds, ivec nc) { int npp, npme, ndiv, *div, *mdiv, d, nmax; gmx_bool bExcl_pbcdx; float pbcdxr; real limit; ivec itry; limit = cellsize_limit; dd->nc[XX] = 1; dd->nc[YY] = 1; dd->nc[ZZ] = 1; npp = nnodes_tot - npme_only; if (EEL_PME(ir->coulombtype)) { npme = (npme_only > 0 ? npme_only : npp); } else { npme = 0; } if (bInterCGBondeds) { bExcl_pbcdx = (IR_EXCL_FORCES(*ir) && !EEL_FULL(ir->coulombtype)); pbcdxr = (double)n_bonded_dx(mtop, bExcl_pbcdx)/(double)mtop->natoms; } else { pbcdxr = 0; } if (bDynLoadBal) { if (dlb_scale >= 1.0) { gmx_fatal(FARGS, "The value for option -dds should be smaller than 1"); } if (fplog) { fprintf(fplog, "Scaling the initial minimum size with 1/%g (option -dds) = %g\n", dlb_scale, 1/dlb_scale); } limit /= dlb_scale; } else if (ir->epc != epcNO) { if (fplog) { fprintf(fplog, "To account for pressure scaling, scaling the initial minimum size with %g\n", DD_GRID_MARGIN_PRES_SCALE); limit *= DD_GRID_MARGIN_PRES_SCALE; } } if (fplog) { fprintf(fplog, "Optimizing the DD grid for %d cells with a minimum initial size of %.3f nm\n", npp, limit); if (inhomogeneous_z(ir)) { fprintf(fplog, "Ewald_geometry=%s: assuming inhomogeneous particle distribution in z, will not decompose in z.\n", eewg_names[ir->ewald_geometry]); } if (limit > 0) { fprintf(fplog, "The maximum allowed number of cells is:"); for (d = 0; d < DIM; d++) { nmax = (int)(ddbox->box_size[d]*ddbox->skew_fac[d]/limit); if (d >= ddbox->npbcdim && nmax < 2) { nmax = 2; } if (d == ZZ && inhomogeneous_z(ir)) { nmax = 1; } fprintf(fplog, " %c %d", 'X' + d, nmax); } fprintf(fplog, "\n"); } } if (debug) { fprintf(debug, "Average nr of pbc_dx calls per atom %.2f\n", pbcdxr); } ndiv = factorize(npp, &div, &mdiv); itry[XX] = 1; itry[YY] = 1; itry[ZZ] = 1; clear_ivec(nc); assign_factors(dd, limit, cutoff, box, ddbox, mtop->natoms, ir, pbcdxr, npme, ndiv, div, mdiv, itry, nc); sfree(div); sfree(mdiv); return limit; } real dd_choose_grid(FILE *fplog, t_commrec *cr, gmx_domdec_t *dd, t_inputrec *ir, gmx_mtop_t *mtop, matrix box, gmx_ddbox_t *ddbox, gmx_bool bDynLoadBal, real dlb_scale, real cellsize_limit, real cutoff_dd, gmx_bool bInterCGBondeds) { gmx_int64_t nnodes_div, ldiv; real limit; if (MASTER(cr)) { nnodes_div = cr->nnodes; if (EEL_PME(ir->coulombtype)) { if (cr->npmenodes > 0) { if (cr->nnodes <= 2) { gmx_fatal(FARGS, "Cannot have separate PME ranks with 2 or fewer ranks"); } if (cr->npmenodes >= cr->nnodes) { gmx_fatal(FARGS, "Cannot have %d separate PME ranks with just %d total ranks", cr->npmenodes, cr->nnodes); } nnodes_div -= cr->npmenodes; } } else { cr->npmenodes = 0; } if (nnodes_div > 12) { ldiv = largest_divisor(nnodes_div); if (ldiv*ldiv*ldiv > nnodes_div*nnodes_div) { gmx_fatal(FARGS, "The number of ranks you selected (%d) contains a large prime factor %d. In most cases this will lead to bad performance. Choose a number with smaller prime factors or set the decomposition (option -dd) manually.", nnodes_div, ldiv); } } if (EEL_PME(ir->coulombtype)) { if (cr->npmenodes < 0) { if (cr->nnodes <= 18) { cr->npmenodes = 0; if (fplog) { fprintf(fplog, "Using %d separate PME ranks, as there are too few total\n ranks for efficient splitting\n", cr->npmenodes); } } else { cr->npmenodes = guess_npme(fplog, mtop, ir, box, cr->nnodes); if (fplog) { fprintf(fplog, "Using %d separate PME ranks, as guessed by mdrun\n", cr->npmenodes); } } } else { if (fplog) { fprintf(fplog, "Using %d separate PME ranks, per user request\n", cr->npmenodes); } } } limit = optimize_ncells(fplog, cr->nnodes, cr->npmenodes, bDynLoadBal, dlb_scale, mtop, box, ddbox, ir, dd, cellsize_limit, cutoff_dd, bInterCGBondeds, dd->nc); } else { limit = 0; } gmx_bcast(sizeof(dd->nc), dd->nc, cr); if (EEL_PME(ir->coulombtype)) { gmx_bcast(sizeof(ir->nkx), &ir->nkx, cr); gmx_bcast(sizeof(ir->nky), &ir->nky, cr); gmx_bcast(sizeof(cr->npmenodes), &cr->npmenodes, cr); } else { cr->npmenodes = 0; } return limit; }
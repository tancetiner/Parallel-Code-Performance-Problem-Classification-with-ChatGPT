#ifndef AMOEBA_OPENMM_CUDAKERNELS_H_ #define AMOEBA_OPENMM_CUDAKERNELS_H_ #include "openmm/amoebaKernels.h" #include "openmm/kernels.h" #include "openmm/System.h" #include "CudaArray.h" #include "CudaContext.h" #include "CudaNonbondedUtilities.h" #include "CudaSort.h" #include <cufft.h> namespace OpenMM { class CudaCalcAmoebaGeneralizedKirkwoodForceKernel; class CudaCalcAmoebaBondForceKernel : public CalcAmoebaBondForceKernel { public: CudaCalcAmoebaBondForceKernel(std::string name, const Platform& platform, CudaContext& cu, const System& system); void initialize(const System& system, const AmoebaBondForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); void copyParametersToContext(ContextImpl& context, const AmoebaBondForce& force); private: class ForceInfo; int numBonds; CudaContext& cu; const System& system; CudaArray params; }; class CudaCalcAmoebaAngleForceKernel : public CalcAmoebaAngleForceKernel { public: CudaCalcAmoebaAngleForceKernel(std::string name, const Platform& platform, CudaContext& cu, const System& system); void initialize(const System& system, const AmoebaAngleForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); void copyParametersToContext(ContextImpl& context, const AmoebaAngleForce& force); private: class ForceInfo; int numAngles; CudaContext& cu; const System& system; CudaArray params; }; class CudaCalcAmoebaInPlaneAngleForceKernel : public CalcAmoebaInPlaneAngleForceKernel { public: CudaCalcAmoebaInPlaneAngleForceKernel(std::string name, const Platform& platform, CudaContext& cu, const System& system); void initialize(const System& system, const AmoebaInPlaneAngleForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); void copyParametersToContext(ContextImpl& context, const AmoebaInPlaneAngleForce& force); private: class ForceInfo; int numAngles; CudaContext& cu; const System& system; CudaArray params; }; class CudaCalcAmoebaPiTorsionForceKernel : public CalcAmoebaPiTorsionForceKernel { public: CudaCalcAmoebaPiTorsionForceKernel(std::string name, const Platform& platform, CudaContext& cu, const System& system); void initialize(const System& system, const AmoebaPiTorsionForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); void copyParametersToContext(ContextImpl& context, const AmoebaPiTorsionForce& force); private: class ForceInfo; int numPiTorsions; CudaContext& cu; const System& system; CudaArray params; }; class CudaCalcAmoebaStretchBendForceKernel : public CalcAmoebaStretchBendForceKernel { public: CudaCalcAmoebaStretchBendForceKernel(std::string name, const Platform& platform, CudaContext& cu, const System& system); void initialize(const System& system, const AmoebaStretchBendForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); void copyParametersToContext(ContextImpl& context, const AmoebaStretchBendForce& force); private: class ForceInfo; int numStretchBends; CudaContext& cu; const System& system; CudaArray params1; CudaArray params2; }; class CudaCalcAmoebaOutOfPlaneBendForceKernel : public CalcAmoebaOutOfPlaneBendForceKernel { public: CudaCalcAmoebaOutOfPlaneBendForceKernel(std::string name, const Platform& platform, CudaContext& cu, const System& system); void initialize(const System& system, const AmoebaOutOfPlaneBendForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); void copyParametersToContext(ContextImpl& context, const AmoebaOutOfPlaneBendForce& force); private: class ForceInfo; int numOutOfPlaneBends; CudaContext& cu; const System& system; CudaArray params; }; class CudaCalcAmoebaTorsionTorsionForceKernel : public CalcAmoebaTorsionTorsionForceKernel { public: CudaCalcAmoebaTorsionTorsionForceKernel(std::string name, const Platform& platform, CudaContext& cu, const System& system); void initialize(const System& system, const AmoebaTorsionTorsionForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: class ForceInfo; int numTorsionTorsions; int numTorsionTorsionGrids; CudaContext& cu; const System& system; CudaArray gridValues; CudaArray gridParams; CudaArray torsionParams; }; class CudaCalcAmoebaMultipoleForceKernel : public CalcAmoebaMultipoleForceKernel { public: CudaCalcAmoebaMultipoleForceKernel(std::string name, const Platform& platform, CudaContext& cu, const System& system); ~CudaCalcAmoebaMultipoleForceKernel(); void initialize(const System& system, const AmoebaMultipoleForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); void getLabFramePermanentDipoles(ContextImpl& context, std::vector<Vec3>& dipoles); void getInducedDipoles(ContextImpl& context, std::vector<Vec3>& dipoles); void getTotalDipoles(ContextImpl& context, std::vector<Vec3>& dipoles); void getElectrostaticPotential(ContextImpl& context, const std::vector< Vec3 >& inputGrid, std::vector< double >& outputElectrostaticPotential); void getSystemMultipoleMoments(ContextImpl& context, std::vector<double>& outputMultipoleMoments); void copyParametersToContext(ContextImpl& context, const AmoebaMultipoleForce& force); void getPMEParameters(double& alpha, int& nx, int& ny, int& nz) const; private: class ForceInfo; void initializeScaleFactors(); void computeInducedField(void** recipBoxVectorPointer); bool iterateDipolesByDIIS(int iteration); void computeExtrapolatedDipoles(void** recipBoxVectorPointer); void ensureMultipolesValid(ContextImpl& context); template <class T, class T4, class M4> void computeSystemMultipoleMoments(ContextImpl& context, std::vector<double>& outputMultipoleMoments); int numMultipoles, maxInducedIterations, maxExtrapolationOrder; int fixedFieldThreads, inducedFieldThreads, electrostaticsThreads; int gridSizeX, gridSizeY, gridSizeZ; double alpha, inducedEpsilon; bool usePME, hasQuadrupoles, hasInitializedScaleFactors, hasInitializedFFT, multipolesAreValid, hasCreatedEvent; AmoebaMultipoleForce::PolarizationType polarizationType; CudaContext& cu; const System& system; std::vector<int3> covalentFlagValues; std::vector<int2> polarizationFlagValues; CudaArray multipoleParticles; CudaArray molecularDipoles; CudaArray molecularQuadrupoles; CudaArray labFrameDipoles; CudaArray labFrameQuadrupoles; CudaArray sphericalDipoles; CudaArray sphericalQuadrupoles; CudaArray fracDipoles; CudaArray fracQuadrupoles; CudaArray field; CudaArray fieldPolar; CudaArray inducedField; CudaArray inducedFieldPolar; CudaArray torque; CudaArray dampingAndThole; CudaArray inducedDipole; CudaArray inducedDipolePolar; CudaArray inducedDipoleErrors; CudaArray prevDipoles; CudaArray prevDipolesPolar; CudaArray prevDipolesGk; CudaArray prevDipolesGkPolar; CudaArray prevErrors; CudaArray diisMatrix; CudaArray diisCoefficients; CudaArray extrapolatedDipole; CudaArray extrapolatedDipolePolar; CudaArray extrapolatedDipoleGk; CudaArray extrapolatedDipoleGkPolar; CudaArray inducedDipoleFieldGradient; CudaArray inducedDipoleFieldGradientPolar; CudaArray inducedDipoleFieldGradientGk; CudaArray inducedDipoleFieldGradientGkPolar; CudaArray extrapolatedDipoleFieldGradient; CudaArray extrapolatedDipoleFieldGradientPolar; CudaArray extrapolatedDipoleFieldGradientGk; CudaArray extrapolatedDipoleFieldGradientGkPolar; CudaArray polarizability; CudaArray covalentFlags; CudaArray polarizationGroupFlags; CudaArray pmeGrid; CudaArray pmeBsplineModuliX; CudaArray pmeBsplineModuliY; CudaArray pmeBsplineModuliZ; CudaArray pmePhi; CudaArray pmePhid; CudaArray pmePhip; CudaArray pmePhidp; CudaArray pmeCphi; CudaArray lastPositions; cufftHandle fft; CUfunction computeMomentsKernel, recordInducedDipolesKernel, computeFixedFieldKernel, computeInducedFieldKernel, updateInducedFieldKernel, electrostaticsKernel, mapTorqueKernel; CUfunction pmeSpreadFixedMultipolesKernel, pmeSpreadInducedDipolesKernel, pmeFinishSpreadChargeKernel, pmeConvolutionKernel; CUfunction pmeFixedPotentialKernel, pmeInducedPotentialKernel, pmeFixedForceKernel, pmeInducedForceKernel, pmeRecordInducedFieldDipolesKernel, computePotentialKernel; CUfunction recordDIISDipolesKernel, buildMatrixKernel, solveMatrixKernel; CUfunction initExtrapolatedKernel, iterateExtrapolatedKernel, computeExtrapolatedKernel, addExtrapolatedGradientKernel; CUfunction pmeTransformMultipolesKernel, pmeTransformPotentialKernel; CUevent syncEvent; CudaCalcAmoebaGeneralizedKirkwoodForceKernel* gkKernel; static const int PmeOrder = 5; static const int MaxPrevDIISDipoles = 20; }; class CudaCalcAmoebaGeneralizedKirkwoodForceKernel : public CalcAmoebaGeneralizedKirkwoodForceKernel { public: CudaCalcAmoebaGeneralizedKirkwoodForceKernel(std::string name, const Platform& platform, CudaContext& cu, const System& system); void initialize(const System& system, const AmoebaGeneralizedKirkwoodForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); void computeBornRadii(); void finishComputation(CudaArray& torque, CudaArray& labFrameDipoles, CudaArray& labFrameQuadrupoles, CudaArray& inducedDipole, CudaArray& inducedDipolePolar, CudaArray& dampingAndThole, CudaArray& covalentFlags, CudaArray& polarizationGroupFlags); CudaArray& getBornRadii() { return bornRadii; } CudaArray& getField() { return field; } CudaArray& getInducedField() { return inducedField; } CudaArray& getInducedFieldPolar() { return inducedFieldPolar; } CudaArray& getInducedDipoles() { return inducedDipoleS; } CudaArray& getInducedDipolesPolar() { return inducedDipolePolarS; } void copyParametersToContext(ContextImpl& context, const AmoebaGeneralizedKirkwoodForce& force); private: class ForceInfo; CudaContext& cu; const System& system; bool includeSurfaceArea, hasInitializedKernels; int computeBornSumThreads, gkForceThreads, chainRuleThreads, ediffThreads; AmoebaMultipoleForce::PolarizationType polarizationType; std::map<std::string, std::string> defines; CudaArray params; CudaArray bornSum; CudaArray bornRadii; CudaArray bornForce; CudaArray field; CudaArray inducedField; CudaArray inducedFieldPolar; CudaArray inducedDipoleS; CudaArray inducedDipolePolarS; CUfunction computeBornSumKernel, reduceBornSumKernel, surfaceAreaKernel, gkForceKernel, chainRuleKernel, ediffKernel; }; class CudaCalcAmoebaVdwForceKernel : public CalcAmoebaVdwForceKernel { public: CudaCalcAmoebaVdwForceKernel(std::string name, const Platform& platform, CudaContext& cu, const System& system); ~CudaCalcAmoebaVdwForceKernel(); void initialize(const System& system, const AmoebaVdwForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); void copyParametersToContext(ContextImpl& context, const AmoebaVdwForce& force); private: class ForceInfo; CudaContext& cu; const System& system; bool hasInitializedNonbonded; double dispersionCoefficient; CudaArray sigmaEpsilon; CudaArray bondReductionAtoms; CudaArray bondReductionFactors; CudaArray isAlchemical; CudaArray vdwLambda; CudaArray tempPosq; CudaArray tempForces; CudaNonbondedUtilities* nonbonded; CUfunction prepareKernel, spreadKernel; }; class CudaCalcAmoebaWcaDispersionForceKernel : public CalcAmoebaWcaDispersionForceKernel { public: CudaCalcAmoebaWcaDispersionForceKernel(std::string name, const Platform& platform, CudaContext& cu, const System& system); void initialize(const System& system, const AmoebaWcaDispersionForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); void copyParametersToContext(ContextImpl& context, const AmoebaWcaDispersionForce& force); private: class ForceInfo; CudaContext& cu; const System& system; double totalMaximumDispersionEnergy; CudaArray radiusEpsilon; CUfunction forceKernel; }; class CudaCalcHippoNonbondedForceKernel : public CalcHippoNonbondedForceKernel { public: CudaCalcHippoNonbondedForceKernel(std::string name, const Platform& platform, CudaContext& cu, const System& system); ~CudaCalcHippoNonbondedForceKernel(); void initialize(const System& system, const HippoNonbondedForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); void getInducedDipoles(ContextImpl& context, std::vector<Vec3>& dipoles); void getLabFramePermanentDipoles(ContextImpl& context, std::vector<Vec3>& dipoles); void getElectrostaticPotential(ContextImpl& context, const std::vector< Vec3 >& inputGrid, std::vector< double >& outputElectrostaticPotential); void copyParametersToContext(ContextImpl& context, const HippoNonbondedForce& force); void getPMEParameters(double& alpha, int& nx, int& ny, int& nz) const; void getDPMEParameters(double& alpha, int& nx, int& ny, int& nz) const; private: class ForceInfo; class TorquePostComputation; class SortTrait : public CudaSort::SortTrait { int getDataSize() const {return 8;} int getKeySize() const {return 4;} const char* getDataType() const {return "int2";} const char* getKeyType() const {return "int";} const char* getMinKey() const {return "(-2147483647-1)";} const char* getMaxKey() const {return "2147483647";} const char* getMaxValue() const {return "make_int2(2147483647, 2147483647)";} const char* getSortKey() const {return "value.y";} }; void computeInducedField(void** recipBoxVectorPointer, int optOrder); void computeExtrapolatedDipoles(void** recipBoxVectorPointer); void ensureMultipolesValid(ContextImpl& context); void addTorquesToForces(); void createFieldKernel(const std::string& interactionSrc, std::vector<CudaArray*> params, CudaArray& fieldBuffer, CUfunction& kernel, std::vector<void*>& args, CUfunction& exceptionKernel, std::vector<void*>& exceptionArgs, CudaArray& exceptionScale); int numParticles, maxExtrapolationOrder, maxTiles; int gridSizeX, gridSizeY, gridSizeZ; int dispersionGridSizeX, dispersionGridSizeY, dispersionGridSizeZ; double pmeAlpha, dpmeAlpha, cutoff; bool usePME, hasInitializedKernels, hasInitializedFFT, multipolesAreValid; std::vector<double> extrapolationCoefficients; CudaContext& cu; const System& system; CudaArray multipoleParticles; CudaArray coreCharge, valenceCharge, alpha, epsilon, damping, c6, pauliK, pauliQ, pauliAlpha, polarizability; CudaArray localDipoles, labDipoles, fracDipoles; CudaArray localQuadrupoles, labQuadrupoles[5], fracQuadrupoles; CudaArray field; CudaArray inducedField; CudaArray torque; CudaArray inducedDipole; CudaArray extrapolatedDipole, extrapolatedPhi; CudaArray pmeGrid1, pmeGrid2; CudaArray pmeAtomGridIndex; CudaArray pmeBsplineModuliX, pmeBsplineModuliY, pmeBsplineModuliZ; CudaArray dpmeBsplineModuliX, dpmeBsplineModuliY, dpmeBsplineModuliZ; CudaArray pmePhi, pmePhidp, pmeCphi; CudaArray lastPositions; CudaArray exceptionScales[6]; CudaArray exceptionAtoms; CudaSort* sort; cufftHandle fftForward, fftBackward, dfftForward, dfftBackward; CUfunction computeMomentsKernel, fixedFieldKernel, fixedFieldExceptionKernel, mutualFieldKernel, mutualFieldExceptionKernel, computeExceptionsKernel; CUfunction recordInducedDipolesKernel, mapTorqueKernel; CUfunction pmeSpreadFixedMultipolesKernel, pmeSpreadInducedDipolesKernel, pmeFinishSpreadChargeKernel, pmeConvolutionKernel; CUfunction pmeFixedPotentialKernel, pmeInducedPotentialKernel, pmeFixedForceKernel, pmeInducedForceKernel, pmeRecordInducedFieldDipolesKernel; CUfunction pmeSelfEnergyKernel; CUfunction dpmeGridIndexKernel, dpmeSpreadChargeKernel, dpmeFinishSpreadChargeKernel, dpmeEvalEnergyKernel, dpmeConvolutionKernel, dpmeInterpolateForceKernel; CUfunction initExtrapolatedKernel, iterateExtrapolatedKernel, computeExtrapolatedKernel, polarizationEnergyKernel; CUfunction pmeTransformMultipolesKernel, pmeTransformPotentialKernel; std::vector<void*> fixedFieldArgs, fixedFieldExceptionArgs, mutualFieldArgs, mutualFieldExceptionArgs, computeExceptionsArgs; static const int PmeOrder = 5; }; } #endif
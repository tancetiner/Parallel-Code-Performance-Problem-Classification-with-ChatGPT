#ifndef OPENMM_OPENCLKERNELS_H_ #define OPENMM_OPENCLKERNELS_H_ #include "OpenCLPlatform.h" #include "OpenCLArray.h" #include "OpenCLContext.h" #include "OpenCLFFT3D.h" #include "OpenCLParameterSet.h" #include "OpenCLSort.h" #include "openmm/kernels.h" #include "openmm/System.h" namespace OpenMM { class OpenCLCalcForcesAndEnergyKernel : public CalcForcesAndEnergyKernel { public: OpenCLCalcForcesAndEnergyKernel(std::string name, const Platform& platform, OpenCLContext& cl) : CalcForcesAndEnergyKernel(name, platform), cl(cl) { } void initialize(const System& system); void beginComputation(ContextImpl& context, bool includeForce, bool includeEnergy); double finishComputation(ContextImpl& context, bool includeForce, bool includeEnergy); private: OpenCLContext& cl; }; class OpenCLUpdateStateDataKernel : public UpdateStateDataKernel { public: OpenCLUpdateStateDataKernel(std::string name, const Platform& platform, OpenCLContext& cl) : UpdateStateDataKernel(name, platform), cl(cl) { } void initialize(const System& system); double getTime(const ContextImpl& context) const; void setTime(ContextImpl& context, double time); void getPositions(ContextImpl& context, std::vector<Vec3>& positions); void setPositions(ContextImpl& context, const std::vector<Vec3>& positions); void getVelocities(ContextImpl& context, std::vector<Vec3>& velocities); void setVelocities(ContextImpl& context, const std::vector<Vec3>& velocities); void getForces(ContextImpl& context, std::vector<Vec3>& forces); void getPeriodicBoxVectors(ContextImpl& context, Vec3& a, Vec3& b, Vec3& c) const; void setPeriodicBoxVectors(ContextImpl& context, const Vec3& a, const Vec3& b, const Vec3& c) const; private: OpenCLContext& cl; }; class OpenCLApplyConstraintsKernel : public ApplyConstraintsKernel { public: OpenCLApplyConstraintsKernel(std::string name, const Platform& platform, OpenCLContext& cl) : ApplyConstraintsKernel(name, platform), cl(cl) { } void initialize(const System& system); void apply(ContextImpl& context, double tol); private: OpenCLContext& cl; }; class OpenCLCalcHarmonicBondForceKernel : public CalcHarmonicBondForceKernel { public: OpenCLCalcHarmonicBondForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcHarmonicBondForceKernel(name, platform), hasInitializedKernel(false), cl(cl), system(system), params(NULL), indices(NULL) { } ~OpenCLCalcHarmonicBondForceKernel(); void initialize(const System& system, const HarmonicBondForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: int numBonds; bool hasInitializedKernel; OpenCLContext& cl; System& system; OpenCLArray<mm_float2>* params; OpenCLArray<mm_int4>* indices; cl::Kernel kernel; }; class OpenCLCalcCustomBondForceKernel : public CalcCustomBondForceKernel { public: OpenCLCalcCustomBondForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcCustomBondForceKernel(name, platform), hasInitializedKernel(false), cl(cl), system(system), params(NULL), indices(NULL), globals(NULL) { } ~OpenCLCalcCustomBondForceKernel(); void initialize(const System& system, const CustomBondForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: int numBonds; bool hasInitializedKernel; OpenCLContext& cl; System& system; OpenCLParameterSet* params; OpenCLArray<mm_int4>* indices; OpenCLArray<cl_float>* globals; std::vector<std::string> globalParamNames; std::vector<cl_float> globalParamValues; cl::Kernel kernel; }; class OpenCLCalcHarmonicAngleForceKernel : public CalcHarmonicAngleForceKernel { public: OpenCLCalcHarmonicAngleForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcHarmonicAngleForceKernel(name, platform), hasInitializedKernel(false), cl(cl), system(system), params(NULL), indices(NULL) { } ~OpenCLCalcHarmonicAngleForceKernel(); void initialize(const System& system, const HarmonicAngleForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: int numAngles; bool hasInitializedKernel; OpenCLContext& cl; System& system; OpenCLArray<mm_float2>* params; OpenCLArray<mm_int8>* indices; cl::Kernel kernel; }; class OpenCLCalcCustomAngleForceKernel : public CalcCustomAngleForceKernel { public: OpenCLCalcCustomAngleForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcCustomAngleForceKernel(name, platform), hasInitializedKernel(false), cl(cl), system(system), params(NULL), indices(NULL), globals(NULL) { } ~OpenCLCalcCustomAngleForceKernel(); void initialize(const System& system, const CustomAngleForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: int numAngles; bool hasInitializedKernel; OpenCLContext& cl; System& system; OpenCLParameterSet* params; OpenCLArray<mm_int8>* indices; OpenCLArray<cl_float>* globals; std::vector<std::string> globalParamNames; std::vector<cl_float> globalParamValues; cl::Kernel kernel; }; class OpenCLCalcPeriodicTorsionForceKernel : public CalcPeriodicTorsionForceKernel { public: OpenCLCalcPeriodicTorsionForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcPeriodicTorsionForceKernel(name, platform), hasInitializedKernel(false), cl(cl), system(system), params(NULL), indices(NULL) { } ~OpenCLCalcPeriodicTorsionForceKernel(); void initialize(const System& system, const PeriodicTorsionForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: int numTorsions; bool hasInitializedKernel; OpenCLContext& cl; System& system; OpenCLArray<mm_float4>* params; OpenCLArray<mm_int8>* indices; cl::Kernel kernel; }; class OpenCLCalcRBTorsionForceKernel : public CalcRBTorsionForceKernel { public: OpenCLCalcRBTorsionForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcRBTorsionForceKernel(name, platform), hasInitializedKernel(false), cl(cl), system(system), params(NULL), indices(NULL) { } ~OpenCLCalcRBTorsionForceKernel(); void initialize(const System& system, const RBTorsionForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: int numTorsions; bool hasInitializedKernel; OpenCLContext& cl; System& system; OpenCLArray<mm_float8>* params; OpenCLArray<mm_int8>* indices; cl::Kernel kernel; }; class OpenCLCalcCMAPTorsionForceKernel : public CalcCMAPTorsionForceKernel { public: OpenCLCalcCMAPTorsionForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcCMAPTorsionForceKernel(name, platform), hasInitializedKernel(false), cl(cl), system(system), coefficients(NULL), mapPositions(NULL), torsionIndices(NULL), torsionMaps(NULL) { } ~OpenCLCalcCMAPTorsionForceKernel(); void initialize(const System& system, const CMAPTorsionForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: int numTorsions; bool hasInitializedKernel; OpenCLContext& cl; System& system; OpenCLArray<mm_float4>* coefficients; OpenCLArray<mm_int2>* mapPositions; OpenCLArray<mm_int16>* torsionIndices; OpenCLArray<cl_int>* torsionMaps; cl::Kernel kernel; }; class OpenCLCalcCustomTorsionForceKernel : public CalcCustomTorsionForceKernel { public: OpenCLCalcCustomTorsionForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcCustomTorsionForceKernel(name, platform), hasInitializedKernel(false), cl(cl), system(system), params(NULL), indices(NULL), globals(NULL) { } ~OpenCLCalcCustomTorsionForceKernel(); void initialize(const System& system, const CustomTorsionForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: int numTorsions; bool hasInitializedKernel; OpenCLContext& cl; System& system; OpenCLParameterSet* params; OpenCLArray<mm_int8>* indices; OpenCLArray<cl_float>* globals; std::vector<std::string> globalParamNames; std::vector<cl_float> globalParamValues; cl::Kernel kernel; }; class OpenCLCalcNonbondedForceKernel : public CalcNonbondedForceKernel { public: OpenCLCalcNonbondedForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcNonbondedForceKernel(name, platform), hasInitializedKernel(false), cl(cl), sigmaEpsilon(NULL), exceptionParams(NULL), exceptionIndices(NULL), cosSinSums(NULL), pmeGrid(NULL), pmeBsplineModuliX(NULL), pmeBsplineModuliY(NULL), pmeBsplineModuliZ(NULL), pmeBsplineTheta(NULL), pmeBsplineDtheta(NULL), pmeAtomRange(NULL), pmeAtomGridIndex(NULL), erfcTable(NULL), sort(NULL), fft(NULL) { } ~OpenCLCalcNonbondedForceKernel(); void initialize(const System& system, const NonbondedForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: OpenCLContext& cl; bool hasInitializedKernel; OpenCLArray<mm_float2>* sigmaEpsilon; OpenCLArray<mm_float4>* exceptionParams; OpenCLArray<mm_int4>* exceptionIndices; OpenCLArray<mm_float2>* cosSinSums; OpenCLArray<mm_float2>* pmeGrid; OpenCLArray<cl_float>* pmeBsplineModuliX; OpenCLArray<cl_float>* pmeBsplineModuliY; OpenCLArray<cl_float>* pmeBsplineModuliZ; OpenCLArray<mm_float4>* pmeBsplineTheta; OpenCLArray<mm_float4>* pmeBsplineDtheta; OpenCLArray<cl_int>* pmeAtomRange; OpenCLArray<mm_int2>* pmeAtomGridIndex; OpenCLArray<cl_float>* erfcTable; OpenCLSort<mm_int2>* sort; OpenCLFFT3D* fft; cl::Kernel exceptionsKernel; cl::Kernel ewaldSumsKernel; cl::Kernel ewaldForcesKernel; cl::Kernel pmeGridIndexKernel; cl::Kernel pmeAtomRangeKernel; cl::Kernel pmeUpdateBsplinesKernel; cl::Kernel pmeSpreadChargeKernel; cl::Kernel pmeFinishSpreadChargeKernel; cl::Kernel pmeConvolutionKernel; cl::Kernel pmeInterpolateForceKernel; std::map<std::string, std::string> pmeDefines; double ewaldSelfEnergy, dispersionCoefficient; static const int PmeOrder = 5; }; class OpenCLCalcCustomNonbondedForceKernel : public CalcCustomNonbondedForceKernel { public: OpenCLCalcCustomNonbondedForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcCustomNonbondedForceKernel(name, platform), hasInitializedKernel(false), cl(cl), params(NULL), globals(NULL), tabulatedFunctionParams(NULL), system(system) { } ~OpenCLCalcCustomNonbondedForceKernel(); void initialize(const System& system, const CustomNonbondedForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: bool hasInitializedKernel; OpenCLContext& cl; OpenCLParameterSet* params; OpenCLArray<cl_float>* globals; OpenCLArray<mm_float4>* tabulatedFunctionParams; std::vector<std::string> globalParamNames; std::vector<cl_float> globalParamValues; std::vector<OpenCLArray<mm_float4>*> tabulatedFunctions; System& system; }; class OpenCLCalcGBSAOBCForceKernel : public CalcGBSAOBCForceKernel { public: OpenCLCalcGBSAOBCForceKernel(std::string name, const Platform& platform, OpenCLContext& cl) : CalcGBSAOBCForceKernel(name, platform), cl(cl), hasCreatedKernels(false), params(NULL), bornSum(NULL), longBornSum(NULL), bornRadii(NULL), bornForce(NULL), longBornForce(NULL), obcChain(NULL) { } ~OpenCLCalcGBSAOBCForceKernel(); void initialize(const System& system, const GBSAOBCForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: double prefactor; bool hasCreatedKernels; int maxTiles; OpenCLContext& cl; OpenCLArray<mm_float2>* params; OpenCLArray<cl_float>* bornSum; OpenCLArray<cl_long>* longBornSum; OpenCLArray<cl_float>* bornRadii; OpenCLArray<cl_float>* bornForce; OpenCLArray<cl_long>* longBornForce; OpenCLArray<cl_float>* obcChain; cl::Kernel computeBornSumKernel; cl::Kernel reduceBornSumKernel; cl::Kernel force1Kernel; cl::Kernel reduceBornForceKernel; }; class OpenCLCalcCustomGBForceKernel : public CalcCustomGBForceKernel { public: OpenCLCalcCustomGBForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcCustomGBForceKernel(name, platform), hasInitializedKernels(false), cl(cl), params(NULL), computedValues(NULL), energyDerivs(NULL), longEnergyDerivs(NULL), globals(NULL), valueBuffers(NULL), longValueBuffers(NULL), tabulatedFunctionParams(NULL), system(system) { } ~OpenCLCalcCustomGBForceKernel(); void initialize(const System& system, const CustomGBForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: bool hasInitializedKernels, needParameterGradient; int maxTiles, numComputedValues; OpenCLContext& cl; OpenCLParameterSet* params; OpenCLParameterSet* computedValues; OpenCLParameterSet* energyDerivs; OpenCLArray<cl_long>* longEnergyDerivs; OpenCLArray<cl_float>* globals; OpenCLArray<cl_float>* valueBuffers; OpenCLArray<cl_long>* longValueBuffers; OpenCLArray<mm_float4>* tabulatedFunctionParams; std::vector<std::string> globalParamNames; std::vector<cl_float> globalParamValues; std::vector<OpenCLArray<mm_float4>*> tabulatedFunctions; System& system; cl::Kernel pairValueKernel, perParticleValueKernel, pairEnergyKernel, perParticleEnergyKernel, gradientChainRuleKernel; }; class OpenCLCalcCustomExternalForceKernel : public CalcCustomExternalForceKernel { public: OpenCLCalcCustomExternalForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcCustomExternalForceKernel(name, platform), hasInitializedKernel(false), cl(cl), system(system), params(NULL), indices(NULL), globals(NULL) { } ~OpenCLCalcCustomExternalForceKernel(); void initialize(const System& system, const CustomExternalForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: int numParticles; bool hasInitializedKernel; OpenCLContext& cl; System& system; OpenCLParameterSet* params; OpenCLArray<cl_int>* indices; OpenCLArray<cl_float>* globals; std::vector<std::string> globalParamNames; std::vector<cl_float> globalParamValues; cl::Kernel kernel; }; class OpenCLCalcCustomHbondForceKernel : public CalcCustomHbondForceKernel { public: OpenCLCalcCustomHbondForceKernel(std::string name, const Platform& platform, OpenCLContext& cl, System& system) : CalcCustomHbondForceKernel(name, platform), hasInitializedKernel(false), cl(cl), donorParams(NULL), acceptorParams(NULL), donors(NULL), acceptors(NULL), donorBufferIndices(NULL), acceptorBufferIndices(NULL), globals(NULL), donorExclusions(NULL), acceptorExclusions(NULL), tabulatedFunctionParams(NULL), system(system) { } ~OpenCLCalcCustomHbondForceKernel(); void initialize(const System& system, const CustomHbondForce& force); double execute(ContextImpl& context, bool includeForces, bool includeEnergy); private: int numDonors, numAcceptors; bool hasInitializedKernel; OpenCLContext& cl; OpenCLParameterSet* donorParams; OpenCLParameterSet* acceptorParams; OpenCLArray<cl_float>* globals; OpenCLArray<mm_int4>* donors; OpenCLArray<mm_int4>* acceptors; OpenCLArray<mm_int4>* donorBufferIndices; OpenCLArray<mm_int4>* acceptorBufferIndices; OpenCLArray<mm_int4>* donorExclusions; OpenCLArray<mm_int4>* acceptorExclusions; OpenCLArray<mm_float4>* tabulatedFunctionParams; std::vector<std::string> globalParamNames; std::vector<cl_float> globalParamValues; std::vector<OpenCLArray<mm_float4>*> tabulatedFunctions; System& system; cl::Kernel donorKernel, acceptorKernel; }; class OpenCLIntegrateVerletStepKernel : public IntegrateVerletStepKernel { public: OpenCLIntegrateVerletStepKernel(std::string name, const Platform& platform, OpenCLContext& cl) : IntegrateVerletStepKernel(name, platform), cl(cl), hasInitializedKernels(false) { } ~OpenCLIntegrateVerletStepKernel(); void initialize(const System& system, const VerletIntegrator& integrator); void execute(ContextImpl& context, const VerletIntegrator& integrator); private: OpenCLContext& cl; double prevStepSize; bool hasInitializedKernels; cl::Kernel kernel1, kernel2; }; class OpenCLIntegrateLangevinStepKernel : public IntegrateLangevinStepKernel { public: OpenCLIntegrateLangevinStepKernel(std::string name, const Platform& platform, OpenCLContext& cl) : IntegrateLangevinStepKernel(name, platform), cl(cl), hasInitializedKernels(false), params(NULL) { } ~OpenCLIntegrateLangevinStepKernel(); void initialize(const System& system, const LangevinIntegrator& integrator); void execute(ContextImpl& context, const LangevinIntegrator& integrator); private: OpenCLContext& cl; double prevTemp, prevFriction, prevStepSize; bool hasInitializedKernels; OpenCLArray<cl_float>* params; cl::Kernel kernel1, kernel2; }; class OpenCLIntegrateBrownianStepKernel : public IntegrateBrownianStepKernel { public: OpenCLIntegrateBrownianStepKernel(std::string name, const Platform& platform, OpenCLContext& cl) : IntegrateBrownianStepKernel(name, platform), cl(cl), hasInitializedKernels(false), prevTemp(-1), prevFriction(-1), prevStepSize(-1) { } ~OpenCLIntegrateBrownianStepKernel(); void initialize(const System& system, const BrownianIntegrator& integrator); void execute(ContextImpl& context, const BrownianIntegrator& integrator); private: OpenCLContext& cl; double prevTemp, prevFriction, prevStepSize; bool hasInitializedKernels; cl::Kernel kernel1, kernel2; }; class OpenCLIntegrateVariableVerletStepKernel : public IntegrateVariableVerletStepKernel { public: OpenCLIntegrateVariableVerletStepKernel(std::string name, const Platform& platform, OpenCLContext& cl) : IntegrateVariableVerletStepKernel(name, platform), cl(cl), hasInitializedKernels(false) { } ~OpenCLIntegrateVariableVerletStepKernel(); void initialize(const System& system, const VariableVerletIntegrator& integrator); void execute(ContextImpl& context, const VariableVerletIntegrator& integrator, double maxTime); private: OpenCLContext& cl; bool hasInitializedKernels; int blockSize; cl::Kernel kernel1, kernel2, selectSizeKernel; }; class OpenCLIntegrateVariableLangevinStepKernel : public IntegrateVariableLangevinStepKernel { public: OpenCLIntegrateVariableLangevinStepKernel(std::string name, const Platform& platform, OpenCLContext& cl) : IntegrateVariableLangevinStepKernel(name, platform), cl(cl), hasInitializedKernels(false), params(NULL) { } ~OpenCLIntegrateVariableLangevinStepKernel(); void initialize(const System& system, const VariableLangevinIntegrator& integrator); void execute(ContextImpl& context, const VariableLangevinIntegrator& integrator, double maxTime); private: OpenCLContext& cl; bool hasInitializedKernels; int blockSize; OpenCLArray<cl_float>* params; cl::Kernel kernel1, kernel2, selectSizeKernel; double prevTemp, prevFriction, prevErrorTol; }; class OpenCLApplyAndersenThermostatKernel : public ApplyAndersenThermostatKernel { public: OpenCLApplyAndersenThermostatKernel(std::string name, const Platform& platform, OpenCLContext& cl) : ApplyAndersenThermostatKernel(name, platform), cl(cl), hasInitializedKernels(false), atomGroups(NULL) { } ~OpenCLApplyAndersenThermostatKernel(); void initialize(const System& system, const AndersenThermostat& thermostat); void execute(ContextImpl& context); private: OpenCLContext& cl; bool hasInitializedKernels; int randomSeed; OpenCLArray<cl_int>* atomGroups; cl::Kernel kernel; }; class OpenCLApplyMonteCarloBarostatKernel : public ApplyMonteCarloBarostatKernel { public: OpenCLApplyMonteCarloBarostatKernel(std::string name, const Platform& platform, OpenCLContext& cl) : ApplyMonteCarloBarostatKernel(name, platform), cl(cl), hasInitializedKernels(false), savedPositions(NULL), moleculeAtoms(NULL), moleculeStartIndex(NULL) { } ~OpenCLApplyMonteCarloBarostatKernel(); void initialize(const System& system, const MonteCarloBarostat& barostat); void scaleCoordinates(ContextImpl& context, double scale); void restoreCoordinates(ContextImpl& context); private: OpenCLContext& cl; bool hasInitializedKernels; int numMolecules; OpenCLArray<mm_float4>* savedPositions; OpenCLArray<cl_int>* moleculeAtoms; OpenCLArray<cl_int>* moleculeStartIndex; cl::Kernel kernel; }; class OpenCLCalcKineticEnergyKernel : public CalcKineticEnergyKernel { public: OpenCLCalcKineticEnergyKernel(std::string name, const Platform& platform, OpenCLContext& cl) : CalcKineticEnergyKernel(name, platform), cl(cl) { } void initialize(const System& system); double execute(ContextImpl& context); private: OpenCLContext& cl; std::vector<double> masses; }; class OpenCLRemoveCMMotionKernel : public RemoveCMMotionKernel { public: OpenCLRemoveCMMotionKernel(std::string name, const Platform& platform, OpenCLContext& cl) : RemoveCMMotionKernel(name, platform), cl(cl), cmMomentum(NULL) { } ~OpenCLRemoveCMMotionKernel(); void initialize(const System& system, const CMMotionRemover& force); void execute(ContextImpl& context); private: OpenCLContext& cl; int frequency; OpenCLArray<mm_float4>* cmMomentum; cl::Kernel kernel1, kernel2; }; } #endif
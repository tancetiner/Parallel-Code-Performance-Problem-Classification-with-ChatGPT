#pragma once #include <color_spinor_field.h> #include <tune_quda.h> #include <dslash_quda.h> #include <dslash_helper.cuh> #include <jitify_helper.cuh> namespace quda { template <typename Float> class Dslash : public TunableVectorYZ { protected: DslashArg<Float> &arg; const ColorSpinorField &out; const ColorSpinorField &in; const int nDimComms; char aux_base[TuneKey::aux_n]; char aux[8][TuneKey::aux_n]; #ifdef JITIFY jitify::Program *program_; #endif inline void fillAuxBase() { char comm[5]; comm[0] = (arg.commDim[0] ? '1' : '0'); comm[1] = (arg.commDim[1] ? '1' : '0'); comm[2] = (arg.commDim[2] ? '1' : '0'); comm[3] = (arg.commDim[3] ? '1' : '0'); comm[4] = '\0'; strcpy(aux_base,",commDim="); strcat(aux_base,comm); if (arg.xpay) strcat(aux_base,",xpay"); if (arg.dagger) strcat(aux_base,",dagger"); } inline void fillAux(KernelType kernel_type, const char *kernel_str) { strcpy(aux[kernel_type],kernel_str); if (kernel_type == INTERIOR_KERNEL) strcat(aux[kernel_type],comm_dim_partitioned_string()); strcat(aux[kernel_type],aux_base); } bool tuneGridDim() const { return false; } unsigned int minThreads() const { return arg.threads; } template <typename Arg> inline void setParam(Arg &arg) { arg.t_proj_scale = getKernelPackT() ? 1.0 : 2.0; static void *ghost[8]; for (int dim=0; dim<4; dim++) { for (int dir=0; dir<2; dir++) { if (!comm_peer2peer_enabled(dir, dim) || arg.kernel_type == INTERIOR_KERNEL) { ghost[2*dim+dir] = (Float*)((char*)in.Ghost2() + in.GhostOffset(dim,dir)*in.GhostPrecision()); } } } arg.in.resetGhost(in, ghost); } virtual int tuningIter() const { return 10; } public: template <typename T, typename Arg> inline void launch(T *f, const TuneParam &tp, Arg &arg, const cudaStream_t &stream) { if (deviceProp.major >= 7) { this->setMaxDynamicSharedBytesPerBlock(f); } void *args[] = { &arg }; qudaLaunchKernel((const void *)f, tp.grid, tp.block, args, tp.shared_bytes, stream); } template < template <typename,int,int,int,bool,bool,KernelType,typename> class Launch, int nDim, int nColor, int nParity, bool dagger, bool xpay, typename Arg> inline void instantiate(TuneParam &tp, Arg &arg, const cudaStream_t &stream) { if (in.Location() == QUDA_CPU_FIELD_LOCATION) { errorQuda("Not implemented"); } else { switch(arg.kernel_type) { case INTERIOR_KERNEL: Launch<Float,nDim,nColor,nParity,dagger,xpay,INTERIOR_KERNEL,Arg>::launch(*this, tp, arg, stream); break; #ifdef MULTI_GPU case EXTERIOR_KERNEL_X: Launch<Float,nDim,nColor,nParity,dagger,xpay,EXTERIOR_KERNEL_X,Arg>::launch(*this, tp, arg, stream); break; case EXTERIOR_KERNEL_Y: Launch<Float,nDim,nColor,nParity,dagger,xpay,EXTERIOR_KERNEL_Y,Arg>::launch(*this, tp, arg, stream); break; case EXTERIOR_KERNEL_Z: Launch<Float,nDim,nColor,nParity,dagger,xpay,EXTERIOR_KERNEL_Z,Arg>::launch(*this, tp, arg, stream); break; case EXTERIOR_KERNEL_T: Launch<Float,nDim,nColor,nParity,dagger,xpay,EXTERIOR_KERNEL_T,Arg>::launch(*this, tp, arg, stream); break; case EXTERIOR_KERNEL_ALL: Launch<Float,nDim,nColor,nParity,dagger,xpay,EXTERIOR_KERNEL_ALL,Arg>::launch(*this, tp, arg, stream); break; default: errorQuda("Unexpected kernel type %d", arg.kernel_type); #else default: errorQuda("Unexpected kernel type %d for single-GPU build", arg.kernel_type); #endif } } } template < template <typename,int,int,int,bool,bool,KernelType,typename> class Launch, int nDim, int nColor, int nParity, bool xpay, typename Arg> inline void instantiate(TuneParam &tp, Arg &arg, const cudaStream_t &stream) { #ifdef JITIFY using namespace jitify::reflection; const auto kernel = Launch<void,0,0,0,false,false,INTERIOR_KERNEL,Arg>::kernel; Tunable::jitify_error = program_->kernel(kernel) .instantiate(Type<Float>(),nDim,nColor,nParity,arg.dagger,xpay,arg.kernel_type,Type<Arg>()) .configure(tp.grid,tp.block,tp.shared_bytes,stream) .launch(arg); #else if (arg.dagger) instantiate<Launch,nDim,nColor,nParity, true,xpay>(tp, arg, stream); else instantiate<Launch,nDim,nColor,nParity,false,xpay>(tp, arg, stream); #endif } template < template <typename,int,int,int,bool,bool,KernelType,typename> class Launch, int nDim, int nColor, bool xpay, typename Arg> inline void instantiate(TuneParam &tp, Arg &arg, const cudaStream_t &stream) { #ifdef JITIFY using namespace jitify::reflection; const auto kernel = Launch<void,0,0,0,false,false,INTERIOR_KERNEL,Arg>::kernel; Tunable::jitify_error = program_->kernel(kernel) .instantiate(Type<Float>(),nDim,nColor,arg.nParity,arg.dagger,xpay,arg.kernel_type,Type<Arg>()) .configure(tp.grid,tp.block,tp.shared_bytes,stream) .launch(arg); #else switch (arg.nParity) { case 1: instantiate<Launch,nDim,nColor,1,xpay>(tp, arg, stream); break; case 2: instantiate<Launch,nDim,nColor,2,xpay>(tp, arg, stream); break; default: errorQuda("nParity = %d undefined\n", arg.nParity); } #endif } template < template <typename,int,int,int,bool,bool,KernelType,typename> class Launch, int nDim, int nColor, typename Arg> inline void instantiate(TuneParam &tp, Arg &arg, const cudaStream_t &stream) { #ifdef JITIFY using namespace jitify::reflection; const auto kernel = Launch<void,0,0,0,false,false,INTERIOR_KERNEL,Arg>::kernel; Tunable::jitify_error = program_->kernel(kernel) .instantiate(Type<Float>(),nDim,nColor,arg.nParity,arg.dagger,arg.xpay,arg.kernel_type,Type<Arg>()) .configure(tp.grid,tp.block,tp.shared_bytes,stream) .launch(arg); #else if (arg.xpay) instantiate<Launch,nDim,nColor, true>(tp, arg, stream); else instantiate<Launch,nDim,nColor,false>(tp, arg, stream); #endif } DslashArg<Float> &dslashParam; Dslash(DslashArg<Float> &arg, const ColorSpinorField &out, const ColorSpinorField &in, const char *src) : TunableVectorYZ(1,arg.nParity), arg(arg), out(out), in(in), nDimComms(4), dslashParam(arg) { setPackComms(arg.commDim); fillAuxBase(); #ifdef MULTI_GPU fillAux(INTERIOR_KERNEL, "policy_kernel=interior"); fillAux(EXTERIOR_KERNEL_ALL, "policy_kernel=exterior_all"); fillAux(EXTERIOR_KERNEL_X, "policy_kernel=exterior_x"); fillAux(EXTERIOR_KERNEL_Y, "policy_kernel=exterior_y"); fillAux(EXTERIOR_KERNEL_Z, "policy_kernel=exterior_z"); fillAux(EXTERIOR_KERNEL_T, "policy_kernel=exterior_t"); #else fillAux(INTERIOR_KERNEL, "policy_kernel=single-GPU"); #endif fillAux(KERNEL_POLICY, "policy"); #ifdef JITIFY create_jitify_program(src); program_ = program; #endif } int Nface() const { return 2*arg.nFace; } int Dagger() const { return arg.dagger; } const char* getAux(KernelType type) const { return aux[type]; } void setAux(KernelType type, const char *aux_) { strcpy(aux[type], aux_); } void augmentAux(KernelType type, const char *extra) { strcat(aux[type], extra); } virtual void preTune() { if (arg.kernel_type != INTERIOR_KERNEL && arg.kernel_type != KERNEL_POLICY) out.backup(); } virtual void postTune() { if (arg.kernel_type != INTERIOR_KERNEL && arg.kernel_type != KERNEL_POLICY) out.restore(); } virtual long long flops() const { int mv_flops = (8 * in.Ncolor() - 2) * in.Ncolor(); int num_mv_multiply = in.Nspin() == 4 ? 2 : 1; int ghost_flops = (num_mv_multiply * mv_flops + 2*in.Ncolor()*in.Nspin()); int xpay_flops = 2 * 2 * in.Ncolor() * in.Nspin(); int num_dir = 2 * 4; long long flops_ = 0; switch(arg.kernel_type) { case EXTERIOR_KERNEL_X: case EXTERIOR_KERNEL_Y: case EXTERIOR_KERNEL_Z: case EXTERIOR_KERNEL_T: flops_ = (ghost_flops + (arg.xpay ? xpay_flops : xpay_flops/2)) * 2 * in.GhostFace()[arg.kernel_type]; break; case EXTERIOR_KERNEL_ALL: { long long ghost_sites = 2 * (in.GhostFace()[0]+in.GhostFace()[1]+in.GhostFace()[2]+in.GhostFace()[3]); flops_ = (ghost_flops + (arg.xpay ? xpay_flops : xpay_flops/2)) * ghost_sites; break; } case INTERIOR_KERNEL: case KERNEL_POLICY: { long long sites = in.Volume(); flops_ = (num_dir*(in.Nspin()/4)*in.Ncolor()*in.Nspin() + num_dir*num_mv_multiply*mv_flops + ((num_dir-1)*2*in.Ncolor()*in.Nspin())) * sites; if (arg.xpay) flops_ += xpay_flops * sites; if (arg.kernel_type == KERNEL_POLICY) break; long long ghost_sites = 0; for (int d=0; d<4; d++) if (arg.commDim[d]) ghost_sites += 2 * in.GhostFace()[d]; flops_ -= ghost_flops * ghost_sites; break; } } return flops_; } virtual long long bytes() const { int gauge_bytes = arg.reconstruct * in.Precision(); bool isFixed = (in.Precision() == sizeof(short) || in.Precision() == sizeof(char)) ? true : false; int spinor_bytes = 2 * in.Ncolor() * in.Nspin() * in.Precision() + (isFixed ? sizeof(float) : 0); int proj_spinor_bytes = in.Nspin() == 4 ? spinor_bytes / 2 : spinor_bytes; int ghost_bytes = (proj_spinor_bytes + gauge_bytes) + 2*spinor_bytes; int num_dir = 2 * 4; long long bytes_ = 0; switch(arg.kernel_type) { case EXTERIOR_KERNEL_X: case EXTERIOR_KERNEL_Y: case EXTERIOR_KERNEL_Z: case EXTERIOR_KERNEL_T: bytes_ = ghost_bytes * 2 * in.GhostFace()[arg.kernel_type]; break; case EXTERIOR_KERNEL_ALL: { long long ghost_sites = 2 * (in.GhostFace()[0]+in.GhostFace()[1]+in.GhostFace()[2]+in.GhostFace()[3]); bytes_ = ghost_bytes * ghost_sites; break; } case INTERIOR_KERNEL: case KERNEL_POLICY: { long long sites = in.Volume(); bytes_ = (num_dir*gauge_bytes + ((num_dir-2)*spinor_bytes + 2*proj_spinor_bytes) + spinor_bytes)*sites; if (arg.xpay) bytes_ += spinor_bytes; if (arg.kernel_type == KERNEL_POLICY) break; long long ghost_sites = 0; for (int d=0; d<4; d++) if (arg.commDim[d]) ghost_sites += 2*in.GhostFace()[d]; bytes_ -= ghost_bytes * ghost_sites; break; } } return bytes_; } }; }
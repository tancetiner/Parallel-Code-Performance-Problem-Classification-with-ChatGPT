#ifdef HAVE_CONFIG_H #include <config.h> #endif #include <stdio.h> #include <time.h> #include "typedefs.h" #include "string2.h" #include "smalloc.h" #include "names.h" #include "confio.h" #include "mvdata.h" #include "txtdump.h" #include "vec.h" #include "time.h" #include "nrnb.h" #include "mshift.h" #include "mdrun.h" #include "update.h" #include "physics.h" #include "nrjac.h" #include "mtop_util.h" #include "edsam.h" #include "mpelogging.h" #include "gmxfio.h" #include "groupcoord.h" #define block_bc(cr, d) gmx_bcast( sizeof(d), &(d),(cr)) #define nblock_bc(cr,nr,d) gmx_bcast((nr)*sizeof((d)[0]), (d),(cr)) #define snew_bc(cr,d,nr) { if (!MASTER(cr)) snew((d),(nr)); } enum {eEDnone, eEDedsam, eEDflood, eEDnr}; enum {eedREF, eedAV, eedORI, eedTAR, eedNR}; typedef struct { int neig; int *ieig; real *stpsz; rvec **vec; real *xproj; real *fproj; real radius; real *refproj; real *refproj0,*refprojslope; } t_eigvec; typedef struct { t_eigvec mon; t_eigvec linfix; t_eigvec linacc; t_eigvec radfix; t_eigvec radacc; t_eigvec radcon; } t_edvecs; typedef struct { real deltaF0; gmx_bool bHarmonic; gmx_bool bConstForce; real tau; real deltaF; real Efl; real kT; real Vfl; real dt; real constEfl; real alpha2; int flood_id; rvec *forces_cartesian; t_eigvec vecs; } t_edflood; typedef struct gmx_edx { int nr; int nr_loc; int *anrs; int *anrs_loc; int nalloc_loc; int *c_ind; rvec *x; rvec *x_old; real *m; real mtot; real *sqrtm; } t_gmx_edx; typedef struct edpar { int nini; gmx_bool fitmas; gmx_bool pcamas; int presteps; int outfrq; int maxedsteps; struct gmx_edx sref; gmx_bool bRefEqAv; struct gmx_edx sav; struct gmx_edx star; struct gmx_edx sori; t_edvecs vecs; real slope; gmx_bool bNeedDoEdsam; t_edflood flood; struct t_ed_buffer *buf; struct edpar *next_edi; } t_edpar; typedef struct gmx_edsam { int eEDtype; const char *edinam; const char *edonam; FILE *edo; t_edpar *edpar; gmx_bool bFirst; gmx_bool bStartFromCpt; } t_gmx_edsam; struct t_do_edsam { matrix old_rotmat; real oldrad; rvec old_transvec,older_transvec,transvec_compact; rvec *xcoll; rvec *xc_ref; ivec *shifts_xcoll; ivec *extra_shifts_xcoll; ivec *shifts_xc_ref; ivec *extra_shifts_xc_ref; gmx_bool bUpdateShifts; }; struct t_ed_buffer { struct t_fit_to_ref * fit_to_ref; struct t_do_edfit * do_edfit; struct t_do_edsam * do_edsam; struct t_do_radcon * do_radcon; }; static void fit_to_reference(rvec *xcoll,rvec transvec,matrix rotmat,t_edpar *edi); static void translate_and_rotate(rvec *x,int nat,rvec transvec,matrix rotmat); static real projectx(t_edpar *edi, rvec *xcoll, rvec *vec) { int i; real proj=0.0; for (i=0; i<edi->sav.nr; i++) proj += edi->sav.sqrtm[i]*iprod(vec[i], xcoll[i]); return proj; } static void rad_project(t_edpar *edi, rvec *x, t_eigvec *vec, t_commrec *cr) { int i; real rad=0.0; for (i = 0; i < edi->sav.nr; i++) rvec_dec(x[i], edi->sav.x[i]); for (i = 0; i < vec->neig; i++) { vec->refproj[i] = projectx(edi,x,vec->vec[i]); rad += pow((vec->refproj[i]-vec->xproj[i]),2); } vec->radius=sqrt(rad); for (i = 0; i < edi->sav.nr; i++) rvec_inc(x[i], edi->sav.x[i]); } static void project_to_eigvectors(rvec *x, t_eigvec *vec, t_edpar *edi) { int i; if (!vec->neig) return; for (i=0; i<edi->sav.nr; i++) rvec_dec(x[i], edi->sav.x[i]); for (i=0; i<vec->neig; i++) vec->xproj[i] = projectx(edi, x, vec->vec[i]); for (i=0; i<edi->sav.nr; i++) rvec_inc(x[i], edi->sav.x[i]); } static void project(rvec *x, t_edpar *edi) { project_to_eigvectors(x, &edi->vecs.mon , edi); project_to_eigvectors(x, &edi->vecs.linfix, edi); project_to_eigvectors(x, &edi->vecs.linacc, edi); project_to_eigvectors(x, &edi->vecs.radfix, edi); project_to_eigvectors(x, &edi->vecs.radacc, edi); project_to_eigvectors(x, &edi->vecs.radcon, edi); } static real calc_radius(t_eigvec *vec) { int i; real rad=0.0; for (i=0; i<vec->neig; i++) rad += pow((vec->refproj[i]-vec->xproj[i]),2); return rad=sqrt(rad); } #ifdef DEBUGHELPERS static void dump_xcoll(t_edpar *edi, struct t_do_edsam *buf, t_commrec *cr, int step) { int i; FILE *fp; char fn[STRLEN]; rvec *xcoll; ivec *shifts, *eshifts; if (!MASTER(cr)) return; xcoll = buf->xcoll; shifts = buf->shifts_xcoll; eshifts = buf->extra_shifts_xcoll; sprintf(fn, "xcolldump_step%d.txt", step); fp = fopen(fn, "w"); for (i=0; i<edi->sav.nr; i++) fprintf(fp, "%d %9.5f %9.5f %9.5f %d %d %d %d %d %d\n", edi->sav.anrs[i]+1, xcoll[i][XX] , xcoll[i][YY] , xcoll[i][ZZ], shifts[i][XX] , shifts[i][YY] , shifts[i][ZZ], eshifts[i][XX], eshifts[i][YY], eshifts[i][ZZ]); fclose(fp); } static void dump_edi_positions(FILE *out, struct gmx_edx *s, const char name[]) { int i; fprintf(out, "#%s positions:\n%d\n", name, s->nr); if (s->nr == 0) return; fprintf(out, "#index, x, y, z"); if (s->sqrtm) fprintf(out, ", sqrt(m)"); for (i=0; i<s->nr; i++) { fprintf(out, "\n%6d %11.6f %11.6f %11.6f",s->anrs[i], s->x[i][XX], s->x[i][YY], s->x[i][ZZ]); if (s->sqrtm) fprintf(out,"%9.3f",s->sqrtm[i]); } fprintf(out, "\n"); } static void dump_edi_eigenvecs(FILE *out, t_eigvec *ev, const char name[], int length) { int i,j; fprintf(out, "#%s eigenvectors:\n%d\n", name, ev->neig); for (i=0; i<ev->neig; i++) { fprintf(out, "EV %4d\ncomponents %d\nstepsize %f\nxproj %f\nfproj %f\nrefproj %f\nradius %f\nComponents:\n", ev->ieig[i], length, ev->stpsz[i], ev->xproj[i], ev->fproj[i], ev->refproj[i], ev->radius); for (j=0; j<length; j++) fprintf(out, "%11.6f %11.6f %11.6f\n", ev->vec[i][j][XX], ev->vec[i][j][YY], ev->vec[i][j][ZZ]); } } static void dump_edi(t_edpar *edpars, t_commrec *cr, int nr_edi) { FILE *out; char fn[STRLEN]; sprintf(fn, "EDdump_node%d_edi%d", cr->nodeid, nr_edi); out = ffopen(fn, "w"); fprintf(out,"#NINI\n %d\n#FITMAS\n %d\n#ANALYSIS_MAS\n %d\n", edpars->nini,edpars->fitmas,edpars->pcamas); fprintf(out,"#OUTFRQ\n %d\n#MAXLEN\n %d\n#SLOPECRIT\n %f\n", edpars->outfrq,edpars->maxedsteps,edpars->slope); fprintf(out,"#PRESTEPS\n %d\n#DELTA_F0\n %f\n#TAU\n %f\n#EFL_NULL\n %f\n#ALPHA2\n %f\n", edpars->presteps,edpars->flood.deltaF0,edpars->flood.tau, edpars->flood.constEfl,edpars->flood.alpha2); dump_edi_positions(out, &edpars->sref, "REFERENCE"); dump_edi_positions(out, &edpars->sav , "AVERAGE" ); dump_edi_positions(out, &edpars->star, "TARGET" ); dump_edi_positions(out, &edpars->sori, "ORIGIN" ); dump_edi_eigenvecs(out, &edpars->vecs.mon , "MONITORED", edpars->sav.nr); dump_edi_eigenvecs(out, &edpars->vecs.linfix, "LINFIX" , edpars->sav.nr); dump_edi_eigenvecs(out, &edpars->vecs.linacc, "LINACC" , edpars->sav.nr); dump_edi_eigenvecs(out, &edpars->vecs.radfix, "RADFIX" , edpars->sav.nr); dump_edi_eigenvecs(out, &edpars->vecs.radacc, "RADACC" , edpars->sav.nr); dump_edi_eigenvecs(out, &edpars->vecs.radcon, "RADCON" , edpars->sav.nr); dump_edi_eigenvecs(out, &edpars->flood.vecs, "FLOODING" , edpars->sav.nr); fprintf(out, "buf->do_edfit =%p\n", (void*)edpars->buf->do_edfit ); fprintf(out, "buf->do_edsam =%p\n", (void*)edpars->buf->do_edsam ); fprintf(out, "buf->do_radcon =%p\n", (void*)edpars->buf->do_radcon ); ffclose(out); } static void dump_rotmat(FILE* out,matrix rotmat) { fprintf(out,"ROTMAT: %12.8f %12.8f %12.8f\n",rotmat[XX][XX],rotmat[XX][YY],rotmat[XX][ZZ]); fprintf(out,"ROTMAT: %12.8f %12.8f %12.8f\n",rotmat[YY][XX],rotmat[YY][YY],rotmat[YY][ZZ]); fprintf(out,"ROTMAT: %12.8f %12.8f %12.8f\n",rotmat[ZZ][XX],rotmat[ZZ][YY],rotmat[ZZ][ZZ]); } static void dump_rvec(FILE *out, int dim, rvec *x) { int i; for (i=0; i<dim; i++) fprintf(out,"%4d %f %f %f\n",i,x[i][XX],x[i][YY],x[i][ZZ]); } static void dump_mat(FILE* out, int dim, double** mat) { int i,j; fprintf(out,"MATRIX:\n"); for (i=0;i<dim;i++) { for (j=0;j<dim;j++) fprintf(out,"%f ",mat[i][j]); fprintf(out,"\n"); } } #endif struct t_do_edfit { double **omega; double **om; }; static void do_edfit(int natoms,rvec *xp,rvec *x,matrix R,t_edpar *edi) { int c,r,n,j,i,irot; double d[6],xnr,xpc; matrix vh,vk,u; int index; real max_d; struct t_do_edfit *loc; gmx_bool bFirst; if(edi->buf->do_edfit != NULL) bFirst = FALSE; else { bFirst = TRUE; snew(edi->buf->do_edfit,1); } loc = edi->buf->do_edfit; if (bFirst) { snew(loc->omega,2*DIM); snew(loc->om,2*DIM); for(i=0; i<2*DIM; i++) { snew(loc->omega[i],2*DIM); snew(loc->om[i],2*DIM); } } for(i=0;(i<6);i++) { d[i]=0; for(j=0;(j<6);j++) { loc->omega[i][j]=0; loc->om[i][j]=0; } } clear_mat(u); for(n=0;(n<natoms);n++) { for(c=0; (c<DIM); c++) { xpc=xp[n][c]; for(r=0; (r<DIM); r++) { xnr=x[n][r]; u[c][r]+=xnr*xpc; } } } for(r=0;(r<6);r++) for(c=0;(c<=r);c++) if ((r>=3) && (c<3)) { loc->omega[r][c]=u[r-3][c]; loc->omega[c][r]=u[r-3][c]; } else { loc->omega[r][c]=0; loc->omega[c][r]=0; } #ifdef DEBUG { int i; dump_mat(stderr,2*DIM,loc->omega); for (i=0; i<6; i++) fprintf(stderr,"d[%d] = %f\n",i,d[i]); } #endif jacobi(loc->omega,6,d,loc->om,&irot); if (irot==0) fprintf(stderr,"IROT=0\n"); index=0; for(j=0;(j<3);j++) { max_d=-1000; for(i=0;(i<6);i++) if (d[i]>max_d) { max_d=d[i]; index=i; } d[index]=-10000; for(i=0;(i<3);i++) { vh[j][i]=M_SQRT2*loc->om[i][index]; vk[j][i]=M_SQRT2*loc->om[i+DIM][index]; } } for(c=0;(c<3);c++) for(r=0;(r<3);r++) R[c][r]=vk[0][r]*vh[0][c]+ vk[1][r]*vh[1][c]+ vk[2][r]*vh[2][c]; if (det(R) < 0) for(c=0;(c<3);c++) for(r=0;(r<3);r++) R[c][r]=vk[0][r]*vh[0][c]+ vk[1][r]*vh[1][c]- vk[2][r]*vh[2][c]; } static void rmfit(int nat, rvec *xcoll, rvec transvec, matrix rotmat) { rvec vec; matrix tmat; transpose(rotmat,tmat); rotate_x(xcoll, nat, tmat); vec[XX]=-transvec[XX]; vec[YY]=-transvec[YY]; vec[ZZ]=-transvec[ZZ]; translate_x(xcoll, nat, vec); } static void write_edo_flood(t_edpar *edi, FILE *fp, gmx_large_int_t step) { int i; char buf[22]; gmx_bool bOutputRef=FALSE; fprintf(fp,"%d.th FL: %s %12.5e %12.5e %12.5e\n", edi->flood.flood_id, gmx_step_str(step,buf), edi->flood.Efl, edi->flood.Vfl, edi->flood.deltaF); if (edi->flood.bHarmonic) { for (i = 0; i < edi->flood.vecs.neig; i++) { if (edi->flood.vecs.refprojslope[i] != 0.0) bOutputRef=TRUE; } if (bOutputRef) { fprintf(fp, "Ref. projs.: "); for (i = 0; i < edi->flood.vecs.neig; i++) { fprintf(fp, "%12.5e ", edi->flood.vecs.refproj[i]); } fprintf(fp, "\n"); } } fprintf(fp,"FL_FORCES: "); for (i=0; i<edi->flood.vecs.neig; i++) fprintf(fp," %12.5e",edi->flood.vecs.fproj[i]); fprintf(fp,"\n"); } static real flood_energy(t_edpar *edi, gmx_large_int_t step) { real sum; real Vfl; int i; if (edi->flood.bHarmonic) { for (i=0; i<edi->flood.vecs.neig; i++) { edi->flood.vecs.refproj[i] = edi->flood.vecs.refproj0[i] + step * edi->flood.vecs.refprojslope[i]; } } sum=0.0; for (i=0; i<edi->flood.vecs.neig; i++) { sum += edi->flood.vecs.stpsz[i]*(edi->flood.vecs.xproj[i]-edi->flood.vecs.refproj[i])*(edi->flood.vecs.xproj[i]-edi->flood.vecs.refproj[i]); } if (edi->flood.bHarmonic) { Vfl = -0.5*edi->flood.Efl*sum; } else { Vfl = edi->flood.Efl!=0 ? edi->flood.Efl*exp(-edi->flood.kT/2/edi->flood.Efl/edi->flood.alpha2*sum) :0; } return Vfl; } static void flood_forces(t_edpar *edi) { int i; real energy=edi->flood.Vfl; if (edi->flood.bHarmonic) for (i=0; i<edi->flood.vecs.neig; i++) { edi->flood.vecs.fproj[i] = edi->flood.Efl* edi->flood.vecs.stpsz[i]*(edi->flood.vecs.xproj[i]-edi->flood.vecs.refproj[i]); } else for (i=0; i<edi->flood.vecs.neig; i++) { edi->flood.vecs.fproj[i] = edi->flood.Efl!=0 ? edi->flood.kT/edi->flood.Efl/edi->flood.alpha2*energy*edi->flood.vecs.stpsz[i]*(edi->flood.vecs.xproj[i]-edi->flood.vecs.refproj[i]) : 0; } } static void flood_blowup(t_edpar *edi, rvec *forces_cart) { int j,eig; rvec dum; real *forces_sub; forces_sub = edi->flood.vecs.fproj; for (j=0; j<edi->sav.nr_loc; j++) clear_rvec(forces_cart[j]); for (j=0; j<edi->sav.nr_loc; j++) { for (eig=0; eig<edi->flood.vecs.neig; eig++) { svmul(forces_sub[eig],edi->flood.vecs.vec[eig][edi->sav.c_ind[j]],dum); rvec_inc(forces_cart[j],dum); } } } static void update_adaption(t_edpar *edi) { if ((edi->flood.tau < 0 ? -edi->flood.tau : edi->flood.tau ) > 0.00000001) { edi->flood.Efl = edi->flood.Efl+edi->flood.dt/edi->flood.tau*(edi->flood.deltaF0-edi->flood.deltaF); if (edi->flood.alpha2<0 && edi->flood.Efl>-0.00000001) edi->flood.Efl = 0; edi->flood.deltaF = (1-edi->flood.dt/edi->flood.tau)*edi->flood.deltaF+edi->flood.dt/edi->flood.tau*edi->flood.Vfl; } } static void do_single_flood( FILE *edo, rvec x[], rvec force[], t_edpar *edi, gmx_large_int_t step, matrix box, t_commrec *cr) { int i; matrix rotmat; matrix tmat; rvec transvec; struct t_do_edsam *buf; buf=edi->buf->do_edsam; communicate_group_positions(cr, buf->xcoll, buf->shifts_xcoll, buf->extra_shifts_xcoll, buf->bUpdateShifts, x, edi->sav.nr, edi->sav.nr_loc, edi->sav.anrs_loc, edi->sav.c_ind, edi->sav.x_old, box); if (!edi->bRefEqAv) communicate_group_positions(cr, buf->xc_ref, buf->shifts_xc_ref, buf->extra_shifts_xc_ref, buf->bUpdateShifts, x, edi->sref.nr, edi->sref.nr_loc, edi->sref.anrs_loc, edi->sref.c_ind, edi->sref.x_old, box); buf->bUpdateShifts = FALSE; if (edi->bRefEqAv) fit_to_reference(buf->xcoll , transvec, rotmat, edi); else fit_to_reference(buf->xc_ref, transvec, rotmat, edi); translate_and_rotate(buf->xcoll, edi->sav.nr, transvec, rotmat); project_to_eigvectors(buf->xcoll,&edi->flood.vecs,edi); if (FALSE == edi->flood.bConstForce) { edi->flood.Vfl = flood_energy(edi, step); update_adaption(edi); flood_forces(edi); } flood_blowup(edi, edi->flood.forces_cartesian); transpose(rotmat,tmat); rotate_x(edi->flood.forces_cartesian, edi->sav.nr_loc, tmat); for (i=0; i<edi->sav.nr_loc; i++) rvec_inc(force[edi->sav.anrs_loc[i]],edi->flood.forces_cartesian[i]); if (do_per_step(step,edi->outfrq) && MASTER(cr)) write_edo_flood(edi,edo,step); } extern void do_flood( FILE *log, t_commrec *cr, rvec x[], rvec force[], gmx_edsam_t ed, matrix box, gmx_large_int_t step) { t_edpar *edi; if (ed->eEDtype != eEDflood) return; edi = ed->edpar; while (edi) { if (edi->flood.vecs.neig) do_single_flood(ed->edo,x,force,edi,step,box,cr); edi = edi->next_edi; } } static void init_flood(t_edpar *edi, gmx_edsam_t ed, real dt, t_commrec *cr) { int i; edi->flood.Efl = edi->flood.constEfl; edi->flood.Vfl = 0; edi->flood.dt = dt; if (edi->flood.vecs.neig) { ed->eEDtype = eEDflood; fprintf(stderr,"ED: Flooding of matrix %d is switched on.\n", edi->flood.flood_id); if (edi->flood.bConstForce) { for (i=0; i<edi->flood.vecs.neig; i++) { edi->flood.vecs.fproj[i] = edi->flood.vecs.stpsz[i]; fprintf(stderr, "ED: applying on eigenvector %d a constant force of %g\n", edi->flood.vecs.ieig[i], edi->flood.vecs.fproj[i]); } } fprintf(ed->edo,"FL_HEADER: Flooding of matrix %d is switched on! The flooding output will have the following format:\n", edi->flood.flood_id); fprintf(ed->edo,"FL_HEADER: Step Efl Vfl deltaF\n"); } } #ifdef DEBUGHELPERS static void get_flood_enx_names(t_edpar *edi, char** names, int *nnames) { t_edpar *actual; int count; char buf[STRLEN]; actual=edi; count = 1; while (actual) { srenew(names,count); sprintf(buf,"Vfl_%d",count); names[count-1]=strdup(buf); actual=actual->next_edi; count++; } *nnames=count-1; } static void get_flood_energies(t_edpar *edi, real Vfl[],int nnames) { t_edpar *actual; int count; actual=edi; count = 1; while (actual) { Vfl[count-1]=actual->flood.Vfl; actual=actual->next_edi; count++; } if (nnames!=count-1) gmx_fatal(FARGS,"Number of energies is not consistent with t_edi structure"); } #endif gmx_edsam_t ed_open(int nfile,const t_filenm fnm[],unsigned long Flags,t_commrec *cr) { gmx_edsam_t ed; snew(ed, 1); ed->eEDtype = eEDedsam; if (MASTER(cr)) { ed->edinam=ftp2fn(efEDI,nfile,fnm); fprintf(stderr,"ED sampling will be performed!\n"); ed->edonam = ftp2fn(efEDO,nfile,fnm); ed->edo = gmx_fio_fopen(ed->edonam,(Flags & MD_APPENDFILES)? "a+" : "w+"); ed->bStartFromCpt = Flags & MD_STARTFROMCPT; } return ed; } static void bc_ed_positions(t_commrec *cr, struct gmx_edx *s, int stype) { snew_bc(cr, s->anrs, s->nr ); snew_bc(cr, s->x , s->nr ); nblock_bc(cr, s->nr, s->anrs ); nblock_bc(cr, s->nr, s->x ); if (stype == eedAV || stype == eedREF) { snew(s->c_ind , s->nr ); s->nalloc_loc = 0; snew_bc(cr, s->x_old, s->nr); nblock_bc(cr, s->nr, s->x_old); } if (stype == eedREF) { snew_bc(cr, s->m, s->nr); nblock_bc(cr, s->nr, s->m); } if (stype == eedAV) { snew_bc(cr, s->sqrtm, s->nr); nblock_bc(cr, s->nr, s->sqrtm); snew_bc(cr, s->m, s->nr); nblock_bc(cr, s->nr, s->m); } } static void bc_ed_vecs(t_commrec *cr, t_eigvec *ev, int length, gmx_bool bHarmonic) { int i; snew_bc(cr, ev->ieig , ev->neig); snew_bc(cr, ev->stpsz , ev->neig); snew_bc(cr, ev->xproj , ev->neig); snew_bc(cr, ev->fproj , ev->neig); snew_bc(cr, ev->refproj, ev->neig); nblock_bc(cr, ev->neig, ev->ieig ); nblock_bc(cr, ev->neig, ev->stpsz ); nblock_bc(cr, ev->neig, ev->xproj ); nblock_bc(cr, ev->neig, ev->fproj ); nblock_bc(cr, ev->neig, ev->refproj); snew_bc(cr, ev->vec, ev->neig); for (i=0; i<ev->neig; i++) { snew_bc(cr, ev->vec[i], length); nblock_bc(cr, length, ev->vec[i]); } if (bHarmonic) { snew_bc(cr, ev->refproj0 , ev->neig); snew_bc(cr, ev->refprojslope, ev->neig); nblock_bc(cr, ev->neig, ev->refproj0 ); nblock_bc(cr, ev->neig, ev->refprojslope); } } static void broadcast_ed_data(t_commrec *cr, gmx_edsam_t ed, int numedis) { int nr; t_edpar *edi; gmx_bcast(sizeof(ed->eEDtype), &(ed->eEDtype), cr); snew_bc(cr, ed->edpar,1); edi = ed->edpar; for (nr=0; nr<numedis; nr++) { block_bc(cr, *edi); bc_ed_positions(cr, &(edi->sref), eedREF); bc_ed_positions(cr, &(edi->sav ), eedAV ); bc_ed_positions(cr, &(edi->star), eedTAR); bc_ed_positions(cr, &(edi->sori), eedORI); bc_ed_vecs(cr, &edi->vecs.mon , edi->sav.nr, FALSE); bc_ed_vecs(cr, &edi->vecs.linfix, edi->sav.nr, FALSE); bc_ed_vecs(cr, &edi->vecs.linacc, edi->sav.nr, FALSE); bc_ed_vecs(cr, &edi->vecs.radfix, edi->sav.nr, FALSE); bc_ed_vecs(cr, &edi->vecs.radacc, edi->sav.nr, FALSE); bc_ed_vecs(cr, &edi->vecs.radcon, edi->sav.nr, FALSE); bc_ed_vecs(cr, &edi->flood.vecs, edi->sav.nr, edi->flood.bHarmonic); if (edi->next_edi) { snew_bc(cr, edi->next_edi, 1); edi = edi->next_edi; } } } static void init_edi(gmx_mtop_t *mtop,t_inputrec *ir, t_commrec *cr,gmx_edsam_t ed,t_edpar *edi) { int i; real totalmass = 0.0; rvec com; t_atom *atom; edi->bNeedDoEdsam = edi->vecs.mon.neig || edi->vecs.linfix.neig || edi->vecs.linacc.neig || edi->vecs.radfix.neig || edi->vecs.radacc.neig || edi->vecs.radcon.neig; snew(edi->sref.m, edi->sref.nr); for (i = 0; i < edi->sref.nr; i++) { if (edi->fitmas) { gmx_mtop_atomnr_to_atom(mtop,edi->sref.anrs[i],&atom); edi->sref.m[i] = atom->m; } else { edi->sref.m[i] = 1.0; } if (edi->sref.m[i] <= 0.0) { gmx_fatal(FARGS, "Reference structure atom %d (sam.edi index %d) has a mass of %g.\n" "For a mass-weighted fit, all reference structure atoms need to have a mass >0.\n" "Either make the covariance analysis non-mass-weighted, or exclude massless\n" "atoms from the reference structure by creating a proper index group.\n", i, edi->sref.anrs[i]+1, edi->sref.m[i]); } totalmass += edi->sref.m[i]; } edi->sref.mtot = totalmass; snew(edi->sav.sqrtm, edi->sav.nr ); snew(edi->sav.m , edi->sav.nr ); for (i = 0; i < edi->sav.nr; i++) { gmx_mtop_atomnr_to_atom(mtop,edi->sav.anrs[i],&atom); edi->sav.m[i] = atom->m; if (edi->pcamas) { edi->sav.sqrtm[i] = sqrt(atom->m); } else { edi->sav.sqrtm[i] = 1.0; } if (edi->sav.sqrtm[i] <= 0.0) { gmx_fatal(FARGS, "Average structure atom %d (sam.edi index %d) has a mass of %g.\n" "For ED with mass-weighting, all average structure atoms need to have a mass >0.\n" "Either make the covariance analysis non-mass-weighted, or exclude massless\n" "atoms from the average structure by creating a proper index group.\n", i, edi->sav.anrs[i]+1, atom->m); } } get_center(edi->sref.x, edi->sref.m, edi->sref.nr, com); com[XX] = -com[XX]; com[YY] = -com[YY]; com[ZZ] = -com[ZZ]; translate_x(edi->sref.x, edi->sref.nr, com); snew(edi->buf, 1); } static void check(const char *line, const char *label) { if (!strstr(line,label)) gmx_fatal(FARGS,"Could not find input parameter %s at expected position in edsam input-file (.edi)\nline read instead is %s",label,line); } static int read_checked_edint(FILE *file,const char *label) { char line[STRLEN+1]; int idum; fgets2 (line,STRLEN,file); check(line,label); fgets2 (line,STRLEN,file); sscanf (line,"%d",&idum); return idum; } static int read_edint(FILE *file,gmx_bool *bEOF) { char line[STRLEN+1]; int idum; char *eof; eof=fgets2 (line,STRLEN,file); if (eof==NULL) { *bEOF = TRUE; return -1; } eof=fgets2 (line,STRLEN,file); if (eof==NULL) { *bEOF = TRUE; return -1; } sscanf (line,"%d",&idum); *bEOF = FALSE; return idum; } static real read_checked_edreal(FILE *file,const char *label) { char line[STRLEN+1]; double rdum; fgets2 (line,STRLEN,file); check(line,label); fgets2 (line,STRLEN,file); sscanf (line,"%lf",&rdum); return (real) rdum; } static void read_edx(FILE *file,int number,int *anrs,rvec *x) { int i,j; char line[STRLEN+1]; double d[3]; for(i=0; i<number; i++) { fgets2 (line,STRLEN,file); sscanf (line,"%d%lf%lf%lf",&anrs[i],&d[0],&d[1],&d[2]); anrs[i]--; for(j=0; j<3; j++) x[i][j]=d[j]; } } static void scan_edvec(FILE *in,int nr,rvec *vec) { char line[STRLEN+1]; int i; double x,y,z; for(i=0; (i < nr); i++) { fgets2 (line,STRLEN,in); sscanf (line,"%le%le%le",&x,&y,&z); vec[i][XX]=x; vec[i][YY]=y; vec[i][ZZ]=z; } } static void read_edvec(FILE *in,int nr,t_eigvec *tvec,gmx_bool bReadRefproj, gmx_bool *bHaveReference) { int i,idum,nscan; double rdum,refproj_dum=0.0,refprojslope_dum=0.0; char line[STRLEN+1]; tvec->neig=read_checked_edint(in,"NUMBER OF EIGENVECTORS"); if (tvec->neig >0) { snew(tvec->ieig ,tvec->neig); snew(tvec->stpsz ,tvec->neig); snew(tvec->vec ,tvec->neig); snew(tvec->xproj ,tvec->neig); snew(tvec->fproj ,tvec->neig); snew(tvec->refproj,tvec->neig); if (bReadRefproj) { snew(tvec->refproj0 ,tvec->neig); snew(tvec->refprojslope,tvec->neig); } for(i=0; (i < tvec->neig); i++) { fgets2 (line,STRLEN,in); if (bReadRefproj) { nscan = sscanf(line,"%d%lf%lf%lf",&idum,&rdum,&refproj_dum,&refprojslope_dum); switch(nscan) { case 4: *bHaveReference = TRUE; break; case 3: *bHaveReference = TRUE; refprojslope_dum = 0.0; break; case 2: refproj_dum = 0.0; refprojslope_dum = 0.0; break; default: gmx_fatal(FARGS,"Expected 2 - 4 (not %d) values for flooding vec: <nr> <spring const> <refproj> <refproj-slope>\n", nscan); break; } tvec->refproj[i]=refproj_dum; tvec->refproj0[i]=refproj_dum; tvec->refprojslope[i]=refprojslope_dum; } else { nscan = sscanf(line,"%d%lf",&idum,&rdum); if (nscan != 2) gmx_fatal(FARGS,"Expected 2 values for flooding vec: <nr> <stpsz>\n"); } tvec->ieig[i]=idum; tvec->stpsz[i]=rdum; } for(i=0; (i < tvec->neig); i++) { snew(tvec->vec[i],nr); scan_edvec(in,nr,tvec->vec[i]); } } } static void read_edvecs(FILE *in,int nr,t_edvecs *vecs) { gmx_bool bHaveReference = FALSE; read_edvec(in, nr, &vecs->mon , FALSE, &bHaveReference); read_edvec(in, nr, &vecs->linfix, FALSE, &bHaveReference); read_edvec(in, nr, &vecs->linacc, FALSE, &bHaveReference); read_edvec(in, nr, &vecs->radfix, FALSE, &bHaveReference); read_edvec(in, nr, &vecs->radacc, FALSE, &bHaveReference); read_edvec(in, nr, &vecs->radcon, FALSE, &bHaveReference); } static gmx_bool check_if_same(struct gmx_edx sref, struct gmx_edx sav) { int i; if (sref.nr != sav.nr) return FALSE; for (i=0; i < sav.nr; i++) { if (sref.anrs[i] != sav.anrs[i]) return FALSE; } fprintf(stderr, "ED: Note: Reference and average structure are composed of the same atom indices.\n"); return TRUE; } static int read_edi(FILE* in, gmx_edsam_t ed,t_edpar *edi,int nr_mdatoms, int edi_nr, t_commrec *cr) { int readmagic; const int magic=670; gmx_bool bEOF; gmx_bool bHaveReference = FALSE; readmagic=read_edint(in,&bEOF); if (bEOF) return 0; if (readmagic != magic) { if (readmagic==666 || readmagic==667 || readmagic==668) gmx_fatal(FARGS,"Wrong magic number: Use newest version of make_edi to produce edi file"); else if (readmagic != 669) gmx_fatal(FARGS,"Wrong magic number %d in %s",readmagic,ed->edinam); } edi->nini=read_edint(in,&bEOF); if (edi->nini != nr_mdatoms) gmx_fatal(FARGS,"Nr of atoms in %s (%d) does not match nr of md atoms (%d)", ed->edinam,edi->nini,nr_mdatoms); edi->fitmas = read_checked_edint(in,"FITMAS"); edi->pcamas = read_checked_edint(in,"ANALYSIS_MAS"); edi->outfrq = read_checked_edint(in,"OUTFRQ"); edi->maxedsteps = read_checked_edint(in,"MAXLEN"); edi->slope = read_checked_edreal(in,"SLOPECRIT"); edi->presteps = read_checked_edint(in,"PRESTEPS"); edi->flood.deltaF0 = read_checked_edreal(in,"DELTA_F0"); edi->flood.deltaF = read_checked_edreal(in,"INIT_DELTA_F"); edi->flood.tau = read_checked_edreal(in,"TAU"); edi->flood.constEfl = read_checked_edreal(in,"EFL_NULL"); edi->flood.alpha2 = read_checked_edreal(in,"ALPHA2"); edi->flood.kT = read_checked_edreal(in,"KT"); edi->flood.bHarmonic = read_checked_edint(in,"HARMONIC"); if (readmagic > 669) edi->flood.bConstForce = read_checked_edint(in,"CONST_FORCE_FLOODING"); else edi->flood.bConstForce = FALSE; edi->flood.flood_id = edi_nr; edi->sref.nr = read_checked_edint(in,"NREF"); snew(edi->sref.anrs,edi->sref.nr); snew(edi->sref.x ,edi->sref.nr); if (PAR(cr)) snew(edi->sref.x_old,edi->sref.nr); edi->sref.sqrtm =NULL; read_edx(in,edi->sref.nr,edi->sref.anrs,edi->sref.x); edi->sav.nr=read_checked_edint(in,"NAV"); snew(edi->sav.anrs,edi->sav.nr); snew(edi->sav.x ,edi->sav.nr); if (PAR(cr)) snew(edi->sav.x_old,edi->sav.nr); read_edx(in,edi->sav.nr,edi->sav.anrs,edi->sav.x); edi->bRefEqAv = check_if_same(edi->sref, edi->sav); read_edvecs(in,edi->sav.nr,&edi->vecs); read_edvec(in,edi->sav.nr,&edi->flood.vecs,edi->flood.bHarmonic, &bHaveReference); edi->star.nr=read_edint(in,&bEOF); if (edi->star.nr > 0) { snew(edi->star.anrs,edi->star.nr); snew(edi->star.x ,edi->star.nr); edi->star.sqrtm =NULL; read_edx(in,edi->star.nr,edi->star.anrs,edi->star.x); } edi->sori.nr=read_edint(in,&bEOF); if (edi->sori.nr > 0) { if (bHaveReference) { gmx_fatal(FARGS, "ED: An origin structure has been provided and a at least one (moving) reference\n" " point was manually specified in the edi file. That is ambiguous. Aborting.\n"); } snew(edi->sori.anrs,edi->sori.nr); snew(edi->sori.x ,edi->sori.nr); edi->sori.sqrtm =NULL; read_edx(in,edi->sori.nr,edi->sori.anrs,edi->sori.x); } return 1; } static void read_edi_file(gmx_edsam_t ed, t_edpar *edi, int nr_mdatoms, t_commrec *cr) { FILE *in; t_edpar *curr_edi,*last_edi; t_edpar *edi_read; int edi_nr = 0; in = gmx_fio_fopen(ed->edinam,"r"); fprintf(stderr, "ED: Reading edi file %s\n", ed->edinam); curr_edi=edi; last_edi=edi; while( read_edi(in, ed, curr_edi, nr_mdatoms, edi_nr, cr) ) { edi_nr++; if (edi->nini != nr_mdatoms) gmx_fatal(FARGS,"edi file %s (dataset #%d) was made for %d atoms, but the simulation contains %d atoms.", ed->edinam, edi_nr, edi->nini, nr_mdatoms); snew(edi_read,1); curr_edi->next_edi=edi_read; last_edi = curr_edi; curr_edi = edi_read; } if (edi_nr == 0) gmx_fatal(FARGS, "No complete ED data set found in edi file %s.", ed->edinam); last_edi->next_edi = NULL; fprintf(stderr, "ED: Found %d ED dataset%s.\n", edi_nr, edi_nr>1? "s" : ""); gmx_fio_fclose(in); } struct t_fit_to_ref { rvec *xcopy; }; static void fit_to_reference(rvec *xcoll, rvec transvec, matrix rotmat, t_edpar *edi) { rvec com; int i; struct t_fit_to_ref *loc; GMX_MPE_LOG(ev_fit_to_reference_start); if (NULL == edi->buf->fit_to_ref) { snew(edi->buf->fit_to_ref, 1); snew(edi->buf->fit_to_ref->xcopy, edi->sref.nr); } loc = edi->buf->fit_to_ref; for (i=0; i<edi->sref.nr; i++) copy_rvec(xcoll[i], loc->xcopy[i]); get_center(loc->xcopy, edi->sref.m, edi->sref.nr, com); transvec[XX] = -com[XX]; transvec[YY] = -com[YY]; transvec[ZZ] = -com[ZZ]; translate_x(loc->xcopy, edi->sref.nr, transvec); do_edfit(edi->sref.nr, edi->sref.x, loc->xcopy, rotmat, edi); GMX_MPE_LOG(ev_fit_to_reference_finish); } static void translate_and_rotate(rvec *x, int nat, rvec transvec, matrix rotmat) { translate_x(x, nat, transvec); rotate_x(x, nat, rotmat); } static real rmsd_from_structure(rvec *x, struct gmx_edx *s) { real rmsd=0.0; int i; for (i=0; i < s->nr; i++) rmsd += distance2(s->x[i], x[i]); rmsd /= (real) s->nr; rmsd = sqrt(rmsd); return rmsd; } void dd_make_local_ed_indices(gmx_domdec_t *dd, struct gmx_edsam *ed) { t_edpar *edi; if (ed->eEDtype != eEDnone) { edi=ed->edpar; while (edi) { if (!edi->bRefEqAv) dd_make_local_group_indices(dd->ga2la, edi->sref.nr, edi->sref.anrs, &edi->sref.nr_loc, &edi->sref.anrs_loc, &edi->sref.nalloc_loc, edi->sref.c_ind); dd_make_local_group_indices(dd->ga2la, edi->sav.nr, edi->sav.anrs, &edi->sav.nr_loc, &edi->sav.anrs_loc, &edi->sav.nalloc_loc, edi->sav.c_ind); edi->buf->do_edsam->bUpdateShifts = TRUE; edi=edi->next_edi; } } } static inline void ed_unshift_single_coord(matrix box, const rvec x, const ivec is, rvec xu) { int tx,ty,tz; GMX_MPE_LOG(ev_unshift_start); tx=is[XX]; ty=is[YY]; tz=is[ZZ]; if(TRICLINIC(box)) { xu[XX] = x[XX]-tx*box[XX][XX]-ty*box[YY][XX]-tz*box[ZZ][XX]; xu[YY] = x[YY]-ty*box[YY][YY]-tz*box[ZZ][YY]; xu[ZZ] = x[ZZ]-tz*box[ZZ][ZZ]; } else { xu[XX] = x[XX]-tx*box[XX][XX]; xu[YY] = x[YY]-ty*box[YY][YY]; xu[ZZ] = x[ZZ]-tz*box[ZZ][ZZ]; } GMX_MPE_LOG(ev_unshift_finish); } static void do_linfix(rvec *xcoll, t_edpar *edi, int step, t_commrec *cr) { int i, j; real proj, add; rvec vec_dum; for (i=0; i<edi->vecs.linfix.neig; i++) { proj = projectx(edi, xcoll, edi->vecs.linfix.vec[i]); add = edi->vecs.linfix.refproj[i] + step*edi->vecs.linfix.stpsz[i] - proj; add /= edi->sav.sqrtm[i]; for (j=0; j<edi->sav.nr; j++) { svmul(add, edi->vecs.linfix.vec[i][j], vec_dum); rvec_inc(xcoll[j], vec_dum); } } } static void do_linacc(rvec *xcoll, t_edpar *edi, t_commrec *cr) { int i, j; real proj, add; rvec vec_dum; for (i=0; i<edi->vecs.linacc.neig; i++) { proj=projectx(edi, xcoll, edi->vecs.linacc.vec[i]); add = 0.0; if (edi->vecs.linacc.stpsz[i] > 0.0) { if ((proj-edi->vecs.linacc.refproj[i]) < 0.0) add = edi->vecs.linacc.refproj[i] - proj; } if (edi->vecs.linacc.stpsz[i] < 0.0) { if ((proj-edi->vecs.linacc.refproj[i]) > 0.0) add = edi->vecs.linacc.refproj[i] - proj; } add /= edi->sav.sqrtm[i]; for (j=0; j<edi->sav.nr; j++) { svmul(add, edi->vecs.linacc.vec[i][j], vec_dum); rvec_inc(xcoll[j], vec_dum); } edi->vecs.linacc.refproj[i] = proj + add; } } static void do_radfix(rvec *xcoll, t_edpar *edi, int step, t_commrec *cr) { int i,j; real *proj, rad=0.0, ratio; rvec vec_dum; if (edi->vecs.radfix.neig == 0) return; snew(proj, edi->vecs.radfix.neig); for (i=0; i<edi->vecs.radfix.neig; i++) { proj[i] = projectx(edi, xcoll, edi->vecs.radfix.vec[i]); rad += pow(proj[i] - edi->vecs.radfix.refproj[i], 2); } rad = sqrt(rad); ratio = (edi->vecs.radfix.stpsz[0]+edi->vecs.radfix.radius)/rad - 1.0; edi->vecs.radfix.radius += edi->vecs.radfix.stpsz[0]; for (i=0; i<edi->vecs.radfix.neig; i++) { proj[i] -= edi->vecs.radfix.refproj[i]; proj[i] /= edi->sav.sqrtm[i]; proj[i] *= ratio; for (j=0; j<edi->sav.nr; j++) { svmul(proj[i], edi->vecs.radfix.vec[i][j], vec_dum); rvec_inc(xcoll[j], vec_dum); } } sfree(proj); } static void do_radacc(rvec *xcoll, t_edpar *edi, t_commrec *cr) { int i,j; real *proj, rad=0.0, ratio=0.0; rvec vec_dum; if (edi->vecs.radacc.neig == 0) return; snew(proj,edi->vecs.radacc.neig); for (i=0; i<edi->vecs.radacc.neig; i++) { proj[i] = projectx(edi, xcoll, edi->vecs.radacc.vec[i]); rad += pow(proj[i] - edi->vecs.radacc.refproj[i], 2); } rad = sqrt(rad); if (rad < edi->vecs.radacc.radius) { ratio = edi->vecs.radacc.radius/rad - 1.0; rad = edi->vecs.radacc.radius; } else edi->vecs.radacc.radius = rad; for (i=0; i<edi->vecs.radacc.neig; i++) { proj[i] -= edi->vecs.radacc.refproj[i]; proj[i] /= edi->sav.sqrtm[i]; proj[i] *= ratio; for (j=0; j<edi->sav.nr; j++) { svmul(proj[i], edi->vecs.radacc.vec[i][j], vec_dum); rvec_inc(xcoll[j], vec_dum); } } sfree(proj); } struct t_do_radcon { real *proj; }; static void do_radcon(rvec *xcoll, t_edpar *edi, t_commrec *cr) { int i,j; real rad=0.0, ratio=0.0; struct t_do_radcon *loc; gmx_bool bFirst; rvec vec_dum; if(edi->buf->do_radcon != NULL) { bFirst = FALSE; loc = edi->buf->do_radcon; } else { bFirst = TRUE; snew(edi->buf->do_radcon, 1); } loc = edi->buf->do_radcon; if (edi->vecs.radcon.neig == 0) return; if (bFirst) snew(loc->proj, edi->vecs.radcon.neig); for (i=0; i<edi->vecs.radcon.neig; i++) { loc->proj[i] = projectx(edi, xcoll, edi->vecs.radcon.vec[i]); rad += pow(loc->proj[i] - edi->vecs.radcon.refproj[i], 2); } rad = sqrt(rad); if (rad > edi->vecs.radcon.radius) { ratio = edi->vecs.radcon.radius/rad - 1.0; for (i=0; i<edi->vecs.radcon.neig; i++) { loc->proj[i] -= edi->vecs.radcon.refproj[i]; loc->proj[i] /= edi->sav.sqrtm[i]; loc->proj[i] *= ratio; for (j=0; j<edi->sav.nr; j++) { svmul(loc->proj[i], edi->vecs.radcon.vec[i][j], vec_dum); rvec_inc(xcoll[j], vec_dum); } } } else edi->vecs.radcon.radius = rad; if (rad != edi->vecs.radcon.radius) { rad = 0.0; for (i=0; i<edi->vecs.radcon.neig; i++) { loc->proj[i] = projectx(edi, xcoll, edi->vecs.radcon.vec[i]); rad += pow(loc->proj[i] - edi->vecs.radcon.refproj[i], 2); } rad = sqrt(rad); } } static void ed_apply_constraints(rvec *xcoll, t_edpar *edi, gmx_large_int_t step, t_commrec *cr) { int i; GMX_MPE_LOG(ev_ed_apply_cons_start); for (i=0; i<edi->sav.nr; i++) rvec_dec(xcoll[i], edi->sav.x[i]); if (step >= 0) do_linfix(xcoll, edi, step, cr); do_linacc(xcoll, edi, cr); if (step >= 0) do_radfix(xcoll, edi, step, cr); do_radacc(xcoll, edi, cr); do_radcon(xcoll, edi, cr); for (i=0; i<edi->sav.nr; i++) rvec_inc(xcoll[i], edi->sav.x[i]); GMX_MPE_LOG(ev_ed_apply_cons_finish); } static void write_edo(int nr_edi, t_edpar *edi, gmx_edsam_t ed, gmx_large_int_t step,real rmsd) { int i; char buf[22]; if (edi->bNeedDoEdsam) { if (step == -1) fprintf(ed->edo, "Initial projections:\n"); else { fprintf(ed->edo,"Step %s, ED #%d ", gmx_step_str(step, buf), nr_edi); fprintf(ed->edo," RMSD %f nm\n",rmsd); } if (edi->vecs.mon.neig) { fprintf(ed->edo," Monitor eigenvectors"); for (i=0; i<edi->vecs.mon.neig; i++) fprintf(ed->edo," %d: %12.5e ",edi->vecs.mon.ieig[i],edi->vecs.mon.xproj[i]); fprintf(ed->edo,"\n"); } if (edi->vecs.linfix.neig) { fprintf(ed->edo," Linfix eigenvectors"); for (i=0; i<edi->vecs.linfix.neig; i++) fprintf(ed->edo," %d: %12.5e ",edi->vecs.linfix.ieig[i],edi->vecs.linfix.xproj[i]); fprintf(ed->edo,"\n"); } if (edi->vecs.linacc.neig) { fprintf(ed->edo," Linacc eigenvectors"); for (i=0; i<edi->vecs.linacc.neig; i++) fprintf(ed->edo," %d: %12.5e ",edi->vecs.linacc.ieig[i],edi->vecs.linacc.xproj[i]); fprintf(ed->edo,"\n"); } if (edi->vecs.radfix.neig) { fprintf(ed->edo," Radfix eigenvectors"); for (i=0; i<edi->vecs.radfix.neig; i++) fprintf(ed->edo," %d: %12.5e ",edi->vecs.radfix.ieig[i],edi->vecs.radfix.xproj[i]); fprintf(ed->edo,"\n"); fprintf(ed->edo," fixed increment radius = %f\n", calc_radius(&edi->vecs.radfix)); } if (edi->vecs.radacc.neig) { fprintf(ed->edo," Radacc eigenvectors"); for (i=0; i<edi->vecs.radacc.neig; i++) fprintf(ed->edo," %d: %12.5e ",edi->vecs.radacc.ieig[i],edi->vecs.radacc.xproj[i]); fprintf(ed->edo,"\n"); fprintf(ed->edo," acceptance radius = %f\n", calc_radius(&edi->vecs.radacc)); } if (edi->vecs.radcon.neig) { fprintf(ed->edo," Radcon eigenvectors"); for (i=0; i<edi->vecs.radcon.neig; i++) fprintf(ed->edo," %d: %12.5e ",edi->vecs.radcon.ieig[i],edi->vecs.radcon.xproj[i]); fprintf(ed->edo,"\n"); fprintf(ed->edo," contracting radius = %f\n", calc_radius(&edi->vecs.radcon)); } } } static int ed_constraints(gmx_bool edtype, t_edpar *edi) { if (edtype == eEDedsam || edtype == eEDflood) { return (edi->vecs.linfix.neig || edi->vecs.linacc.neig || edi->vecs.radfix.neig || edi->vecs.radacc.neig || edi->vecs.radcon.neig); } return 0; } static void copyEvecReference(t_eigvec* floodvecs) { int i; for (i=0; i<floodvecs->neig; i++) { floodvecs->refproj0[i] = floodvecs->refproj[i]; } } void init_edsam(gmx_mtop_t *mtop, t_inputrec *ir, t_commrec *cr, gmx_edsam_t ed, rvec x[], matrix box) { t_edpar *edi = NULL; int numedis=0; int i,nr_edi; rvec *x_pbc = NULL; rvec *xfit = NULL; rvec *xstart = NULL; rvec fit_transvec; matrix fit_rotmat; if (!DOMAINDECOMP(cr) && PAR(cr) && MASTER(cr)) gmx_fatal(FARGS, "Please switch on domain decomposition to use essential dynamics in parallel."); GMX_MPE_LOG(ev_edsam_start); if (MASTER(cr)) fprintf(stderr, "ED: Initializing essential dynamics constraints.\n"); ed->bFirst = 1; if (MASTER(cr)) { snew(ed->edpar,1); read_edi_file(ed,ed->edpar,mtop->natoms,cr); edi=ed->edpar; while(edi != NULL) { init_edi(mtop,ir,cr,ed,edi); init_flood(edi,ed,ir->delta_t,cr); edi=edi->next_edi; numedis++; } } if (MASTER(cr)) { snew(x_pbc,mtop->natoms); m_rveccopy(mtop->natoms,x,x_pbc); do_pbc_first_mtop(NULL,ir->ePBC,box,mtop,x_pbc); edi=ed->edpar; for (nr_edi = 1; nr_edi <= numedis; nr_edi++) { srenew(xfit , edi->sref.nr ); srenew(xstart, edi->sav.nr ); for (i=0; i < edi->sref.nr; i++) { copy_rvec(x_pbc[edi->sref.anrs[i]], xfit[i]); if (PAR(cr)) copy_rvec(xfit[i], edi->sref.x_old[i]); } for (i=0; i < edi->sav.nr; i++) { copy_rvec(x_pbc[edi->sav.anrs[i]], xstart[i]); if (PAR(cr)) copy_rvec(xstart[i], edi->sav.x_old[i]); } fit_to_reference(xfit, fit_transvec, fit_rotmat, edi); translate_and_rotate(xfit, edi->sref.nr, fit_transvec, fit_rotmat); fprintf(stderr, "ED: Initial RMSD from reference after fit = %f nm (dataset #%d)\n", rmsd_from_structure(xfit, &edi->sref), nr_edi); translate_and_rotate(xstart, edi->sav.nr, fit_transvec, fit_rotmat); project(xstart, edi); if (edi->star.nr > 0) { fprintf(stderr, "ED: Fitting target structure to reference structure\n"); fit_to_reference(edi->star.x, fit_transvec, fit_rotmat, edi); translate_and_rotate(edi->star.x, edi->sav.nr, fit_transvec, fit_rotmat); rad_project(edi, edi->star.x, &edi->vecs.radcon, cr); } else rad_project(edi, xstart, &edi->vecs.radcon, cr); if ( (eEDflood == ed->eEDtype) && (FALSE == edi->flood.bConstForce) ) fprintf(stderr, "ED: Setting center of flooding potential (0 = average structure)\n"); if (edi->sori.nr > 0) { fprintf(stderr, "ED: Fitting origin structure to reference structure\n"); fit_to_reference(edi->sori.x, fit_transvec, fit_rotmat, edi); translate_and_rotate(edi->sori.x, edi->sav.nr, fit_transvec, fit_rotmat); rad_project(edi, edi->sori.x, &edi->vecs.radacc, cr); rad_project(edi, edi->sori.x, &edi->vecs.radfix, cr); if ( (eEDflood == ed->eEDtype) && (FALSE == edi->flood.bConstForce) ) { fprintf(stderr, "ED: The ORIGIN structure will define the flooding potential center.\n"); rad_project(edi, edi->sori.x, &edi->flood.vecs, cr); copyEvecReference(&edi->flood.vecs); } } else { rad_project(edi, xstart, &edi->vecs.radacc, cr); rad_project(edi, xstart, &edi->vecs.radfix, cr); if ( (eEDflood == ed->eEDtype) && (FALSE == edi->flood.bConstForce) ) { if (edi->flood.bHarmonic) { fprintf(stderr, "ED: A (possibly changing) ref. projection will define the flooding potential center.\n"); for (i=0; i<edi->flood.vecs.neig; i++) edi->flood.vecs.refproj[i] = edi->flood.vecs.refproj0[i]; } else { fprintf(stderr, "ED: The AVERAGE structure will define the flooding potential center.\n"); for (i=0; i<edi->flood.vecs.neig; i++) edi->flood.vecs.refproj[i] = 0.0; } } } if ( (eEDflood == ed->eEDtype) && (FALSE == edi->flood.bConstForce) ) { for (i=0; i<edi->flood.vecs.neig; i++) { fprintf(stdout, "ED: EV %d flooding potential center: %11.4e", i, edi->flood.vecs.refproj[i]); if (edi->flood.bHarmonic) fprintf(stdout, " (adding %11.4e/timestep)", edi->flood.vecs.refprojslope[i]); fprintf(stdout, "\n"); } } rad_project(edi, xstart, &edi->vecs.linacc, cr); rad_project(edi, xstart, &edi->vecs.linfix, cr); if (ed->edo && !(ed->bStartFromCpt)) write_edo(nr_edi, edi, ed, -1, 0); edi=edi->next_edi; } sfree(x_pbc); sfree(xfit); sfree(xstart); } if (PAR(cr)) { gmx_bcast(sizeof(numedis), &numedis, cr); broadcast_ed_data(cr, ed, numedis); } else { edi=ed->edpar; for (nr_edi = 1; nr_edi <= numedis; nr_edi++) { edi->sref.anrs_loc = edi->sref.anrs; edi->sav.anrs_loc = edi->sav.anrs; edi->star.anrs_loc = edi->star.anrs; edi->sori.anrs_loc = edi->sori.anrs; snew(edi->sav.c_ind, edi->sav.nr); for (i=0; i<edi->sav.nr; i++) edi->sav.c_ind[i] = i; if (!edi->bRefEqAv) { snew(edi->sref.c_ind, edi->sref.nr); for (i=0; i<edi->sref.nr; i++) edi->sref.c_ind[i] = i; } edi->star.c_ind = edi->sav.c_ind; edi->sori.c_ind = edi->sav.c_ind; edi->sref.nr_loc = edi->sref.nr; edi->sav.nr_loc = edi->sav.nr; edi->star.nr_loc = edi->star.nr; edi->sori.nr_loc = edi->sori.nr; edi=edi->next_edi; } } edi=ed->edpar; for (nr_edi = 1; nr_edi <= numedis; nr_edi++) { snew(edi->buf, 1); snew(edi->buf->do_edsam, 1); snew(edi->buf->do_edsam->xcoll , edi->sav.nr); snew(edi->buf->do_edsam->shifts_xcoll , edi->sav.nr); snew(edi->buf->do_edsam->extra_shifts_xcoll , edi->sav.nr); if (!edi->bRefEqAv) { snew(edi->buf->do_edsam->xc_ref , edi->sref.nr); snew(edi->buf->do_edsam->shifts_xc_ref , edi->sref.nr); snew(edi->buf->do_edsam->extra_shifts_xc_ref, edi->sref.nr); } snew(edi->flood.forces_cartesian , edi->sav.nr); #ifdef DUMPEDI dump_edi(edi, cr, nr_edi); #endif edi=edi->next_edi; } if (ed->edo) fflush(ed->edo); GMX_MPE_LOG(ev_edsam_finish); } void do_edsam(t_inputrec *ir, gmx_large_int_t step, t_mdatoms *md, t_commrec *cr, rvec xs[], rvec v[], matrix box, gmx_edsam_t ed) { int i,edinr,iupdate=500; matrix rotmat; rvec transvec; rvec dv,dx,x_unsh; real dt_1; struct t_do_edsam *buf; t_edpar *edi; real rmsdev=-1; gmx_bool bSuppress=FALSE; if ( ed->eEDtype==eEDnone ) return; if ( (ir->eI==eiSD2) && (v != NULL) ) bSuppress = TRUE; dt_1 = 1.0/ir->delta_t; edi = ed->edpar; edinr = 0; while (edi != NULL) { edinr++; if (edi->bNeedDoEdsam) { buf=edi->buf->do_edsam; if (ed->bFirst) buf->oldrad=calc_radius(&edi->vecs.radacc); communicate_group_positions(cr, buf->xcoll, buf->shifts_xcoll, buf->extra_shifts_xcoll, buf->bUpdateShifts, xs, edi->sav.nr, edi->sav.nr_loc, edi->sav.anrs_loc, edi->sav.c_ind, edi->sav.x_old, box); #ifdef DEBUG_ED dump_xcoll(edi, buf, cr, step); #endif if (!edi->bRefEqAv) communicate_group_positions(cr, buf->xc_ref, buf->shifts_xc_ref, buf->extra_shifts_xc_ref, buf->bUpdateShifts, xs, edi->sref.nr, edi->sref.nr_loc, edi->sref.anrs_loc, edi->sref.c_ind, edi->sref.x_old, box); buf->bUpdateShifts = FALSE; if (edi->bRefEqAv) fit_to_reference(buf->xcoll , transvec, rotmat, edi); else fit_to_reference(buf->xc_ref, transvec, rotmat, edi); translate_and_rotate(buf->xcoll, edi->sav.nr, transvec, rotmat); if (do_per_step(step,edi->outfrq) && MASTER(cr)) { if (edi->bRefEqAv) { rmsdev = rmsd_from_structure(buf->xcoll,&edi->sref); } else { translate_and_rotate(buf->xc_ref, edi->sref.nr, transvec, rotmat); rmsdev = rmsd_from_structure(buf->xc_ref,&edi->sref); } } if (do_per_step(step,edi->maxedsteps) && step >= edi->presteps) { project(buf->xcoll, edi); rad_project(edi, buf->xcoll, &edi->vecs.radacc, cr); rad_project(edi, buf->xcoll, &edi->vecs.radfix, cr); buf->oldrad=-1.e5; } if (do_per_step(step,iupdate) && step >= edi->presteps) { edi->vecs.radacc.radius = calc_radius(&edi->vecs.radacc); if (edi->vecs.radacc.radius - buf->oldrad < edi->slope) { project(buf->xcoll, edi); rad_project(edi, buf->xcoll, &edi->vecs.radacc, cr); buf->oldrad = 0.0; } else buf->oldrad = edi->vecs.radacc.radius; } if (step >= edi->presteps && ed_constraints(ed->eEDtype, edi)) { ed_apply_constraints(buf->xcoll, edi, step+1 - ir->init_step, cr); } if (do_per_step(step,edi->outfrq)) { project(buf->xcoll, edi); if (MASTER(cr) && !bSuppress) write_edo(edinr, edi, ed, step, rmsdev); } if (ed_constraints(ed->eEDtype, edi)) { rmfit(edi->sav.nr, buf->xcoll, transvec, rotmat); for (i=0; i<edi->sav.nr_loc; i++) { ed_unshift_single_coord(box, buf->xcoll[edi->sav.c_ind[i]], buf->shifts_xcoll[edi->sav.c_ind[i]], x_unsh); rvec_sub(x_unsh, xs[edi->sav.anrs_loc[i]], dx); if (v != NULL) { svmul(dt_1, dx, dv); rvec_inc(v[edi->sav.anrs_loc[i]], dv); } copy_rvec(x_unsh, xs[edi->sav.anrs_loc[i]]); } } } edi = edi->next_edi; } ed->bFirst = FALSE; GMX_MPE_LOG(ev_edsam_finish); }
#include "statutil.h" #include "typedefs.h" #include "smalloc.h" #include "vec.h" #include "copyrite.h" #include "tpxio.h" #include "string2.h" #include "readinp.h" #include "calcgrid.h" #include "checkpoint.h" #include "gmx_ana.h" #include "gmx_random.h" #include "physics.h" #include "mdatoms.h" #include "coulomb.h" #include "mtop_util.h" #include "network.h" #include "main.h" #define block_bc(cr, d) gmx_bcast( sizeof(d), &(d),(cr)) #define nblock_bc(cr,nr,d) gmx_bcast((nr)*sizeof((d)[0]), (d),(cr)) #define snew_bc(cr,d,nr) { if (!MASTER(cr)) snew((d),(nr)); } enum { ddnoSEL, ddnoINTERLEAVE, ddnoPP_PME, ddnoCARTESIAN, ddnoNR }; enum { eParselogOK, eParselogNotFound, eParselogNoPerfData, eParselogTerm, eParselogResetProblem, eParselogNr }; typedef struct { int nPMEnodes; int nx, ny, nz; int guessPME; float *Gcycles; float Gcycles_Av; float *ns_per_day; float ns_per_day_Av; float *PME_f_load; float PME_f_load_Av; char *mdrun_cmd_line; } t_perf; typedef struct { gmx_large_int_t orig_sim_steps; int n_entries; real volume; matrix recipbox; int natoms; real *fac; real *rcoulomb; real *rvdw; int *nkx, *nky, *nkz; real *fourier_sp; real *ewald_rtol; real *ewald_beta; real fracself; real q2all; real q2allnr; int *pme_order; char **fn_out; real *e_dir; real *e_rec; gmx_bool bTUNE; } t_inputinfo; static gmx_bool is_charge(real charge) { if (charge*charge > GMX_REAL_EPS) return TRUE; else return FALSE; } static void calc_q2all( gmx_mtop_t *mtop, real *q2all, real *q2allnr) { int imol,iatom; real q2_all=0; int nrq_mol; int nrq_all; real nrq_all_r; real qi,q2_mol; gmx_moltype_t *molecule; gmx_molblock_t *molblock; #ifdef DEBUG fprintf(stderr, "\nCharge density:\n"); #endif q2_all = 0.0; nrq_all = 0; for (imol=0; imol<mtop->nmolblock; imol++) { q2_mol=0.0; nrq_mol=0; molecule = &(mtop->moltype[imol]); molblock = &(mtop->molblock[imol]); for (iatom=0; iatom<molblock->natoms_mol; iatom++) { qi = molecule->atoms.atom[iatom].q; if (is_charge(qi)) { q2_mol += qi*qi; nrq_mol++; } } q2_all += q2_mol*molblock->nmol; nrq_all += nrq_mol*molblock->nmol; #ifdef DEBUG fprintf(stderr, "Molecule %2d (%5d atoms) q2_mol=%10.3e nr.mol.charges=%5d (%6dx) q2_all=%10.3e tot.charges=%d\n", imol,molblock->natoms_mol,q2_mol,nrq_mol,molblock->nmol,q2_all,nrq_all); #endif } nrq_all_r = nrq_all; *q2all=q2_all; *q2allnr=nrq_all; } static real estimate_direct( t_inputinfo *info ) { real e_dir=0; real beta=0; real r_coulomb=0; beta = info->ewald_beta[0]; r_coulomb = info->rcoulomb[0]; e_dir = 2.0 * info->q2all * gmx_invsqrt( info->q2allnr * r_coulomb * info->volume ); e_dir *= exp (-beta*beta*r_coulomb*r_coulomb); return ONE_4PI_EPS0*e_dir; } #define SUMORDER 6 static inline real eps_poly1( real m, real K, real n) { int i; real nom=0; real denom=0; real tmp=0; if ( m == 0.0 ) return 0.0 ; for(i=-SUMORDER ; i<0 ; i++) { tmp=m / K + i; tmp*=2.0*M_PI; nom+=pow( tmp , -n ); } for(i=SUMORDER ; i>0 ; i--) { tmp=m / K + i; tmp*=2.0*M_PI; nom+=pow( tmp , -n ); } tmp=m / K; tmp*=2.0*M_PI; denom=pow( tmp , -n )+nom; return -nom/denom; } static inline real eps_poly2( real m, real K, real n) { int i; real nom=0; real denom=0; real tmp=0; if ( m == 0.0 ) return 0.0 ; for(i=-SUMORDER ; i<0 ; i++) { tmp=m / K + i; tmp*=2.0*M_PI; nom+=pow( tmp , -2.0*n ); } for(i=SUMORDER ; i>0 ; i--) { tmp=m / K + i; tmp*=2.0*M_PI; nom+=pow( tmp , -2.0*n ); } for(i=-SUMORDER ; i<SUMORDER+1 ; i++) { tmp=m / K + i; tmp*=2.0*M_PI; denom+=pow( tmp , -n ); } tmp=eps_poly1(m,K,n); return nom / denom / denom + tmp*tmp ; } static inline real eps_poly3( real m, real K, real n) { int i; real nom=0; real denom=0; real tmp=0; if ( m == 0.0 ) return 0.0 ; for(i=-SUMORDER ; i<0 ; i++) { tmp=m / K + i; tmp*=2.0*M_PI; nom+= i * pow( tmp , -2.0*n ); } for(i=SUMORDER ; i>0 ; i--) { tmp=m / K + i; tmp*=2.0*M_PI; nom+= i * pow( tmp , -2.0*n ); } for(i=-SUMORDER ; i<SUMORDER+1 ; i++) { tmp=m / K + i; tmp*=2.0*M_PI; denom+=pow( tmp , -n ); } return 2.0 * M_PI * nom / denom / denom; } static inline real eps_poly4( real m, real K, real n) { int i; real nom=0; real denom=0; real tmp=0; if ( m == 0.0 ) return 0.0 ; for(i=-SUMORDER ; i<0 ; i++) { tmp=m / K + i; tmp*=2.0*M_PI; nom+= i * i * pow( tmp , -2.0*n ); } for(i=SUMORDER ; i>0 ; i--) { tmp=m / K + i; tmp*=2.0*M_PI; nom+= i * i * pow( tmp , -2.0*n ); } for(i=-SUMORDER ; i<SUMORDER+1 ; i++) { tmp=m / K + i; tmp*=2.0*M_PI; denom+=pow( tmp , -n ); } return 4.0 * M_PI * M_PI * nom / denom / denom; } static inline real eps_self( real m, real K, rvec rboxv, real n, rvec x) { int i; real tmp=0; real tmp1=0; real tmp2=0; real rcoord=0; real nom=0; real denom=0; if ( m == 0.0 ) return 0.0 ; rcoord=iprod(rboxv,x); for(i=-SUMORDER;i<0;i++) { tmp=-sin(2.0 * M_PI * i * K * rcoord); tmp1=2.0 * M_PI * m / K + 2.0 * M_PI * i; tmp2=pow(tmp1,-1.0*n); nom+=tmp * tmp2 * i; denom+=tmp2; } for(i=SUMORDER;i>0;i--) { tmp=-sin(2.0 * M_PI * i * K * rcoord); tmp1=2.0 * M_PI * m / K + 2.0 * M_PI * i; tmp2=pow(tmp1,-1.0*n); nom+=tmp * tmp2 * i; denom+=tmp2; } tmp=2.0 * M_PI * m / K; tmp1=pow(tmp,-1.0*n); denom+=tmp1; return 2.0 * M_PI * nom / denom * K ; } #undef SUMORDER static void calc_recipbox(matrix box,matrix recipbox) { real tmp=1.0/(box[XX][XX]*box[YY][YY]*box[ZZ][ZZ]); recipbox[XX][XX]=box[YY][YY]*box[ZZ][ZZ]*tmp; recipbox[XX][YY]=0; recipbox[XX][ZZ]=0; recipbox[YY][XX]=-box[YY][XX]*box[ZZ][ZZ]*tmp; recipbox[YY][YY]=box[XX][XX]*box[ZZ][ZZ]*tmp; recipbox[YY][ZZ]=0; recipbox[ZZ][XX]=(box[YY][XX]*box[ZZ][YY]-box[YY][YY]*box[ZZ][XX])*tmp; recipbox[ZZ][YY]=-box[ZZ][YY]*box[XX][XX]*tmp; recipbox[ZZ][ZZ]=box[XX][XX]*box[YY][YY]*tmp; } static real estimate_reciprocal( t_inputinfo *info, rvec x[], real q[], int nr, FILE *fp_out, gmx_bool bVerbose, unsigned int seed, int *nsamples, t_commrec *cr) { real e_rec=0; real e_rec1=0; real e_rec2=0; real e_rec3=0; real e_rec3x=0; real e_rec3y=0; real e_rec3z=0; int i,ci; int nx,ny,nz; real q2_all=0; rvec gridpx; rvec gridpxy; rvec gridp; rvec tmpvec; rvec tmpvec2; real coeff=0; real coeff2=0; real tmp=0; real tmp1=0; real tmp2=0; gmx_bool bFraction; gmx_rng_t rng=NULL; int *numbers=NULL; int startglobal,stopglobal; int startlocal, stoplocal; int x_per_core; int xtot; #ifdef TAKETIME double t0=0.0; double t1=0.0; #endif rng=gmx_rng_init(seed); clear_rvec(gridpx); clear_rvec(gridpxy); clear_rvec(gridp); clear_rvec(tmpvec); clear_rvec(tmpvec2); for(i=0;i<nr;i++) { q2_all += q[i]*q[i]; } startglobal=-info->nkx[0]/2; stopglobal = info->nkx[0]/2; xtot = stopglobal*2+1; if (PAR(cr)) { x_per_core = ceil((real)xtot / (real)cr->nnodes); startlocal = startglobal + x_per_core*cr->nodeid; stoplocal = startlocal + x_per_core -1; if (stoplocal > stopglobal) stoplocal = stopglobal; } else { startlocal = startglobal; stoplocal = stopglobal; x_per_core = xtot; } #ifdef GMX_LIB_MPI #ifdef TAKETIME if (MASTER(cr)) t0 = MPI_Wtime(); #endif #endif if (MASTER(cr)){ fprintf(stderr, "Calculating reciprocal error part 1 ..."); } for(nx=startlocal; nx<=stoplocal; nx++) { svmul(nx,info->recipbox[XX],gridpx); for(ny=-info->nky[0]/2; ny<info->nky[0]/2+1; ny++) { svmul(ny,info->recipbox[YY],tmpvec); rvec_add(gridpx,tmpvec,gridpxy); for(nz=-info->nkz[0]/2; nz<info->nkz[0]/2+1; nz++) { if ( 0 == nx && 0 == ny && 0 == nz ) continue; svmul(nz,info->recipbox[ZZ],tmpvec); rvec_add(gridpxy,tmpvec,gridp); tmp=norm2(gridp); coeff=exp(-1.0 * M_PI * M_PI * tmp / info->ewald_beta[0] / info->ewald_beta[0] ) ; coeff/= 2.0 * M_PI * info->volume * tmp; coeff2=tmp ; tmp=eps_poly2(nx,info->nkx[0],info->pme_order[0]); tmp+=eps_poly2(ny,info->nkx[0],info->pme_order[0]); tmp+=eps_poly2(nz,info->nkx[0],info->pme_order[0]); tmp1=eps_poly1(nx,info->nkx[0],info->pme_order[0]); tmp2=eps_poly1(ny,info->nky[0],info->pme_order[0]); tmp+=2.0 * tmp1 * tmp2; tmp1=eps_poly1(nz,info->nkz[0],info->pme_order[0]); tmp2=eps_poly1(ny,info->nky[0],info->pme_order[0]); tmp+=2.0 * tmp1 * tmp2; tmp1=eps_poly1(nz,info->nkz[0],info->pme_order[0]); tmp2=eps_poly1(nx,info->nkx[0],info->pme_order[0]); tmp+=2.0 * tmp1 * tmp2; tmp1=eps_poly1(nx,info->nkx[0],info->pme_order[0]); tmp1+=eps_poly1(ny,info->nky[0],info->pme_order[0]); tmp1+=eps_poly1(nz,info->nkz[0],info->pme_order[0]); tmp+= tmp1 * tmp1; e_rec1+= 32.0 * M_PI * M_PI * coeff * coeff * coeff2 * tmp * q2_all * q2_all / nr ; tmp1=eps_poly3(nx,info->nkx[0],info->pme_order[0]); tmp1*=info->nkx[0]; tmp2=iprod(gridp,info->recipbox[XX]); tmp=tmp1*tmp2; tmp1=eps_poly3(ny,info->nky[0],info->pme_order[0]); tmp1*=info->nky[0]; tmp2=iprod(gridp,info->recipbox[YY]); tmp+=tmp1*tmp2; tmp1=eps_poly3(nz,info->nkz[0],info->pme_order[0]); tmp1*=info->nkz[0]; tmp2=iprod(gridp,info->recipbox[ZZ]); tmp+=tmp1*tmp2; tmp*=4.0 * M_PI; tmp1=eps_poly4(nx,info->nkx[0],info->pme_order[0]); tmp1*=norm2(info->recipbox[XX]); tmp1*=info->nkx[0] * info->nkx[0]; tmp+=tmp1; tmp1=eps_poly4(ny,info->nky[0],info->pme_order[0]); tmp1*=norm2(info->recipbox[YY]); tmp1*=info->nky[0] * info->nky[0]; tmp+=tmp1; tmp1=eps_poly4(nz,info->nkz[0],info->pme_order[0]); tmp1*=norm2(info->recipbox[ZZ]); tmp1*=info->nkz[0] * info->nkz[0]; tmp+=tmp1; e_rec2+= 4.0 * coeff * coeff * tmp * q2_all * q2_all / nr ; } } if (MASTER(cr)) fprintf(stderr, "\rCalculating reciprocal error part 1 ... %3.0f%%", 100.0*(nx-startlocal+1)/(x_per_core)); } if (MASTER(cr)) fprintf(stderr, "\n"); bFraction = (info->fracself > 0.0) && (info->fracself < 1.0); if (bFraction) { x_per_core = ceil(info->fracself * nr / (real)cr->nnodes); xtot = x_per_core * cr->nnodes; } else { xtot = nr; x_per_core = ceil( (real)xtot / (real)cr->nnodes ); } startlocal = x_per_core * cr->nodeid; stoplocal = min(startlocal + x_per_core, xtot); if (bFraction) { snew(numbers, xtot); if (MASTER(cr)) { for (i=0; i<xtot; i++) { numbers[i] = floor(gmx_rng_uniform_real(rng) * nr ); } } if (PAR(cr)) { nblock_bc(cr,xtot,numbers); } if (bVerbose && MASTER(cr)) { fprintf(stdout, "Using %d sample%s to approximate the self interaction error term", xtot, xtot==1?"":"s"); if (PAR(cr)) fprintf(stdout, " (%d sample%s per node)", x_per_core, x_per_core==1?"":"s"); fprintf(stdout, ".\n"); } } *nsamples = xtot; for(i=startlocal;i<stoplocal;i++) { e_rec3x=0; e_rec3y=0; e_rec3z=0; if (bFraction) { ci = numbers[i]; } else { ci = i; } for(nx=-info->nkx[0]/2; nx<info->nkx[0]/2+1; nx++) { svmul(nx,info->recipbox[XX],gridpx); for(ny=-info->nky[0]/2; ny<info->nky[0]/2+1; ny++) { svmul(ny,info->recipbox[YY],tmpvec); rvec_add(gridpx,tmpvec,gridpxy); for(nz=-info->nkz[0]/2; nz<info->nkz[0]/2+1; nz++) { if ( 0 == nx && 0 == ny && 0 == nz) continue; svmul(nz,info->recipbox[ZZ],tmpvec); rvec_add(gridpxy,tmpvec,gridp); tmp=norm2(gridp); coeff=exp(-1.0 * M_PI * M_PI * tmp / info->ewald_beta[0] / info->ewald_beta[0] ); coeff/= tmp ; e_rec3x+=coeff*eps_self(nx,info->nkx[0],info->recipbox[XX],info->pme_order[0],x[ci]); e_rec3y+=coeff*eps_self(ny,info->nky[0],info->recipbox[YY],info->pme_order[0],x[ci]); e_rec3z+=coeff*eps_self(nz,info->nkz[0],info->recipbox[ZZ],info->pme_order[0],x[ci]); } } } clear_rvec(tmpvec2); svmul(e_rec3x,info->recipbox[XX],tmpvec); rvec_inc(tmpvec2,tmpvec); svmul(e_rec3y,info->recipbox[YY],tmpvec); rvec_inc(tmpvec2,tmpvec); svmul(e_rec3z,info->recipbox[ZZ],tmpvec); rvec_inc(tmpvec2,tmpvec); e_rec3 += q[ci]*q[ci]*q[ci]*q[ci]*norm2(tmpvec2) / ( xtot * M_PI * info->volume * M_PI * info->volume); if (MASTER(cr)){ fprintf(stderr, "\rCalculating reciprocal error part 2 ... %3.0f%%", 100.0*(i+1)/stoplocal); } } if (MASTER(cr)) fprintf(stderr, "\n"); #ifdef GMX_LIB_MPI #ifdef TAKETIME if (MASTER(cr)) { t1= MPI_Wtime() - t0; fprintf(fp_out, "Recip. err. est. took : %lf s\n", t1); } #endif #endif #ifdef DEBUG if (PAR(cr)) { fprintf(stderr, "Node %3d: nx=[%3d...%3d] e_rec3=%e\n", cr->nodeid, startlocal, stoplocal, e_rec3); } #endif if (PAR(cr)) { gmx_sum(1,&e_rec1,cr); gmx_sum(1,&e_rec2,cr); gmx_sum(1,&e_rec3,cr); } e_rec=sqrt(e_rec1+e_rec2+e_rec3); return ONE_4PI_EPS0 * e_rec; } static void create_info(t_inputinfo *info) { snew(info->fac , info->n_entries); snew(info->rcoulomb , info->n_entries); snew(info->rvdw , info->n_entries); snew(info->nkx , info->n_entries); snew(info->nky , info->n_entries); snew(info->nkz , info->n_entries); snew(info->fourier_sp, info->n_entries); snew(info->ewald_rtol, info->n_entries); snew(info->ewald_beta, info->n_entries); snew(info->pme_order , info->n_entries); snew(info->fn_out , info->n_entries); snew(info->e_dir , info->n_entries); snew(info->e_rec , info->n_entries); } static int prepare_x_q(real *q[], rvec *x[], gmx_mtop_t *mtop, rvec x_orig[], t_commrec *cr) { int i,anr_global; int nq; t_atom *atom; if (MASTER(cr)) { snew(*q, mtop->natoms); snew(*x, mtop->natoms); nq=0; for (i=0; i<mtop->natoms; i++) { anr_global = i; gmx_mtop_atomnr_to_atom(mtop,anr_global,&atom); if (is_charge(atom->q)) { (*q)[nq] = atom->q; (*x)[nq][XX] = x_orig[i][XX]; (*x)[nq][YY] = x_orig[i][YY]; (*x)[nq][ZZ] = x_orig[i][ZZ]; nq++; } } srenew(*q, nq); srenew(*x, nq); } if (PAR(cr)) { block_bc(cr,nq); snew_bc(cr, *x, nq); snew_bc(cr, *q, nq); nblock_bc(cr,nq,*x); nblock_bc(cr,nq,*q); } return nq; } static void read_tpr_file(const char *fn_sim_tpr, t_inputinfo *info, t_state *state, gmx_mtop_t *mtop, t_inputrec *ir, real user_beta, real fracself) { read_tpx_state(fn_sim_tpr,ir,state,NULL,mtop); info->orig_sim_steps = ir->nsteps; info->pme_order[0] = ir->pme_order; info->rcoulomb[0] = ir->rcoulomb; info->rvdw[0] = ir->rvdw; info->nkx[0] = ir->nkx; info->nky[0] = ir->nky; info->nkz[0] = ir->nkz; info->ewald_rtol[0] = ir->ewald_rtol; info->fracself = fracself; if (user_beta > 0) info->ewald_beta[0] = user_beta; else info->ewald_beta[0] = calc_ewaldcoeff(info->rcoulomb[0],info->ewald_rtol[0]); if (EEL_PME(ir->coulombtype) == FALSE) gmx_fatal(FARGS, "Can only do optimizations for simulations with PME"); if (!(ir->rcoulomb == ir->rlist)) gmx_fatal(FARGS, "PME requires rcoulomb (%f) to be equal to rlist (%f).", ir->rcoulomb, ir->rlist); } static void bcast_info(t_inputinfo *info, t_commrec *cr) { nblock_bc(cr, info->n_entries, info->nkx); nblock_bc(cr, info->n_entries, info->nky); nblock_bc(cr, info->n_entries, info->nkz); nblock_bc(cr, info->n_entries, info->ewald_beta); nblock_bc(cr, info->n_entries, info->pme_order); nblock_bc(cr, info->n_entries, info->e_dir); nblock_bc(cr, info->n_entries, info->e_rec); block_bc(cr, info->volume); block_bc(cr, info->recipbox); block_bc(cr, info->natoms); block_bc(cr, info->fracself); block_bc(cr, info->bTUNE); block_bc(cr, info->q2all); block_bc(cr, info->q2allnr); } static void estimate_PME_error(t_inputinfo *info, t_state *state, gmx_mtop_t *mtop, FILE *fp_out, gmx_bool bVerbose, unsigned int seed, t_commrec *cr) { rvec *x=NULL; real *q=NULL; real edir=0.0; real erec=0.0; real derr=0.0; real derr0=0.0; real beta=0.0; real beta0=0.0; int ncharges; int nsamples; int i=0; if (MASTER(cr)) fprintf(fp_out, "\n--- PME ERROR ESTIMATE ---\n"); ncharges = prepare_x_q(&q, &x, mtop, state->x, cr); if (MASTER(cr)) { calc_q2all(mtop, &(info->q2all), &(info->q2allnr)); info->ewald_rtol[0]=gmx_erfc(info->rcoulomb[0]*info->ewald_beta[0]); fprintf(fp_out, "Box volume : %g nm^3\n", info->volume); fprintf(fp_out, "Number of charged atoms : %d (total atoms %d)\n",ncharges, info->natoms); fprintf(fp_out, "Coulomb radius : %g nm\n", info->rcoulomb[0]); fprintf(fp_out, "Ewald_rtol : %g\n", info->ewald_rtol[0]); fprintf(fp_out, "Ewald parameter beta : %g\n", info->ewald_beta[0]); fprintf(fp_out, "Interpolation order : %d\n", info->pme_order[0]); fprintf(fp_out, "Fourier grid (nx,ny,nz) : %d x %d x %d\n", info->nkx[0],info->nky[0],info->nkz[0]); fflush(fp_out); } if (PAR(cr)) bcast_info(info, cr); info->e_dir[0] = estimate_direct(info); info->e_rec[0] = estimate_reciprocal(info, x, q, ncharges, fp_out, bVerbose, seed, &nsamples, cr); if (PAR(cr)) bcast_info(info, cr); if (MASTER(cr)) { fprintf(fp_out, "Direct space error est. : %10.3e kJ/(mol*nm)\n", info->e_dir[0]); fprintf(fp_out, "Reciprocal sp. err. est.: %10.3e kJ/(mol*nm)\n", info->e_rec[0]); fprintf(fp_out, "Self-energy error term was estimated using %d samples\n", nsamples); fflush(fp_out); fprintf(stderr, "Direct space error est. : %10.3e kJ/(mol*nm)\n", info->e_dir[0]); fprintf(stderr, "Reciprocal sp. err. est.: %10.3e kJ/(mol*nm)\n", info->e_rec[0]); } i=0; if (info->bTUNE) { if(MASTER(cr)) fprintf(stderr,"Starting tuning ...\n"); edir=info->e_dir[0]; erec=info->e_rec[0]; derr0=edir-erec; beta0=info->ewald_beta[0]; if (derr>0.0) info->ewald_beta[0]+=0.1; else info->ewald_beta[0]-=0.1; info->e_dir[0] = estimate_direct(info); info->e_rec[0] = estimate_reciprocal(info, x, q, ncharges, fp_out, bVerbose, seed, &nsamples, cr); if (PAR(cr)) bcast_info(info, cr); edir=info->e_dir[0]; erec=info->e_rec[0]; derr=edir-erec; while ( fabs(derr/min(erec,edir)) > 1e-4) { beta=info->ewald_beta[0]; beta-=derr*(info->ewald_beta[0]-beta0)/(derr-derr0); beta0=info->ewald_beta[0]; info->ewald_beta[0]=beta; derr0=derr; info->e_dir[0] = estimate_direct(info); info->e_rec[0] = estimate_reciprocal(info, x, q, ncharges, fp_out, bVerbose, seed, &nsamples, cr); if (PAR(cr)) bcast_info(info, cr); edir=info->e_dir[0]; erec=info->e_rec[0]; derr=edir-erec; if (MASTER(cr)) { i++; fprintf(stderr,"difference between real and rec. space error (step %d): %g\n",i,fabs(derr)); fprintf(stderr,"old beta: %f\n",beta0); fprintf(stderr,"new beta: %f\n",beta); } } info->ewald_rtol[0]=gmx_erfc(info->rcoulomb[0]*info->ewald_beta[0]); if (MASTER(cr)) { fflush(fp_out); fprintf(fp_out, "========= After tuning ========\n"); fprintf(fp_out, "Direct space error est. : %10.3e kJ/(mol*nm)\n", info->e_dir[0]); fprintf(fp_out, "Reciprocal sp. err. est.: %10.3e kJ/(mol*nm)\n", info->e_rec[0]); fprintf(stderr, "Direct space error est. : %10.3e kJ/(mol*nm)\n", info->e_dir[0]); fprintf(stderr, "Reciprocal sp. err. est.: %10.3e kJ/(mol*nm)\n", info->e_rec[0]); fprintf(fp_out, "Ewald_rtol : %g\n", info->ewald_rtol[0]); fprintf(fp_out, "Ewald parameter beta : %g\n", info->ewald_beta[0]); fflush(fp_out); } } } int gmx_pme_error(int argc,char *argv[]) { const char *desc[] = { "[TT]g_pme_error[tt] estimates the error of the electrostatic forces", "if using the sPME algorithm. The flag [TT]-tune[tt] will determine", "the splitting parameter such that the error is equally", "distributed over the real and reciprocal space part.", "The part of the error that stems from self interaction of the particles " "is computationally demanding. However, a good a approximation is to", "just use a fraction of the particles for this term which can be", "indicated by the flag [TT]-self[tt].[PAR]", }; real fs=0.0; real user_beta=-1.0; real fracself=1.0; t_inputinfo info; t_state state; gmx_mtop_t mtop; t_inputrec *ir=NULL; FILE *fp=NULL; t_commrec *cr; unsigned long PCA_Flags; gmx_bool bTUNE=FALSE; gmx_bool bVerbose=FALSE; int seed=0; static t_filenm fnm[] = { { efTPX, "-s", NULL, ffREAD }, { efOUT, "-o", "error", ffWRITE }, { efTPX, "-so", "tuned", ffOPTWR } }; output_env_t oenv=NULL; t_pargs pa[] = { { "-beta", FALSE, etREAL, {&user_beta}, "If positive, overwrite ewald_beta from [TT].tpr[tt] file with this value" }, { "-tune", FALSE, etBOOL, {&bTUNE}, "Tune the splitting parameter such that the error is equally distributed between real and reciprocal space" }, { "-self", FALSE, etREAL, {&fracself}, "If between 0.0 and 1.0, determine self interaction error from just this fraction of the charged particles" }, { "-seed", FALSE, etINT, {&seed}, "Random number seed used for Monte Carlo algorithm when [TT]-self[tt] is set to a value between 0.0 and 1.0" }, { "-v", FALSE, etBOOL, {&bVerbose}, "Be loud and noisy" } }; #define NFILE asize(fnm) cr = init_par(&argc,&argv); #ifdef GMX_LIB_MPI MPI_Barrier(MPI_COMM_WORLD); #endif if (MASTER(cr)) CopyRight(stderr,argv[0]); PCA_Flags = PCA_NOEXIT_ON_ARGS; PCA_Flags |= (MASTER(cr) ? 0 : PCA_QUIET); parse_common_args(&argc,argv,PCA_Flags, NFILE,fnm,asize(pa),pa,asize(desc),desc, 0,NULL,&oenv); if (!bTUNE) bTUNE = opt2bSet("-so",NFILE,fnm); info.n_entries = 1; create_info(&info); info.fourier_sp[0] = fs; if (MASTER(cr)) { snew(ir,1); read_tpr_file(opt2fn("-s",NFILE,fnm), &info, &state, &mtop, ir, user_beta,fracself); fp=fopen(opt2fn("-o",NFILE,fnm),"w"); } if (fs > 0 && MASTER(cr)) { info.nkx[0] = 0; info.nky[0] = 0; info.nkz[0] = 0; calc_grid(stdout,state.box,info.fourier_sp[0],&(info.nkx[0]),&(info.nky[0]),&(info.nkz[0])); if ( (ir->nkx != info.nkx[0]) || (ir->nky != info.nky[0]) || (ir->nkz != info.nkz[0]) ) gmx_fatal(FARGS, "Wrong fourierspacing %f nm, input file grid = %d x %d x %d, computed grid = %d x %d x %d", fs,ir->nkx,ir->nky,ir->nkz,info.nkx[0],info.nky[0],info.nkz[0]); } if (MASTER(cr)) { info.volume = det(state.box); calc_recipbox(state.box,info.recipbox); info.natoms = mtop.natoms; info.bTUNE = bTUNE; } if (PAR(cr)) bcast_info(&info, cr); estimate_PME_error(&info, &state, &mtop, fp, bVerbose, seed, cr); if (MASTER(cr)) { if ( opt2bSet("-so",NFILE,fnm) || bTUNE ) { ir->ewald_rtol=info.ewald_rtol[0]; write_tpx_state(opt2fn("-so",NFILE,fnm),ir,&state,&mtop); } please_cite(fp,"Wang2010"); fclose(fp); } if (gmx_parallel_env_initialized()) { gmx_finalize(); } return 0; }
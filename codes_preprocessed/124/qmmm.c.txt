#ifdef HAVE_CONFIG_H #include <config.h> #endif #include <math.h> #include "sysstuff.h" #include "typedefs.h" #include "macros.h" #include "smalloc.h" #include "assert.h" #include "physics.h" #include "macros.h" #include "vec.h" #include "force.h" #include "invblock.h" #include "confio.h" #include "names.h" #include "network.h" #include "pbc.h" #include "ns.h" #include "nrnb.h" #include "bondf.h" #include "mshift.h" #include "txtdump.h" #include "copyrite.h" #include "qmmm.h" #include <stdio.h> #include <string.h> #include "gmx_fatal.h" #include "typedefs.h" #include <stdlib.h> #include "mtop_util.h" #ifdef GMX_QMMM_GAMESS void init_gamess(t_commrec *cr, t_QMrec *qm, t_MMrec *mm); real call_gamess(t_commrec *cr,t_forcerec *fr, t_QMrec *qm, t_MMrec *mm,rvec f[], rvec fshift[]); #elif defined GMX_QMMM_MOPAC void init_mopac(t_commrec *cr, t_QMrec *qm, t_MMrec *mm); real call_mopac(t_commrec *cr,t_forcerec *fr, t_QMrec *qm, t_MMrec *mm,rvec f[], rvec fshift[]); real call_mopac_SH(t_commrec *cr,t_forcerec *fr,t_QMrec *qm, t_MMrec *mm,rvec f[], rvec fshift[]); #elif defined GMX_QMMM_GAUSSIAN void init_gaussian(t_commrec *cr ,t_QMrec *qm, t_MMrec *mm); real call_gaussian_SH(t_commrec *cr,t_forcerec *fr,t_QMrec *qm, t_MMrec *mm,rvec f[], rvec fshift[]); real call_gaussian(t_commrec *cr,t_forcerec *fr, t_QMrec *qm, t_MMrec *mm,rvec f[], rvec fshift[]); #elif defined GMX_QMMM_ORCA void init_orca(t_commrec *cr ,t_QMrec *qm, t_MMrec *mm); real call_orca(t_commrec *cr,t_forcerec *fr, t_QMrec *qm, t_MMrec *mm,rvec f[], rvec fshift[]); #endif typedef struct { int j; int shift; } t_j_particle; static int struct_comp(const void *a, const void *b){ return (int)(((t_j_particle *)a)->j)-(int)(((t_j_particle *)b)->j); } static int int_comp(const void *a,const void *b){ return (*(int *)a) - (*(int *)b); } static int QMlayer_comp(const void *a, const void *b){ return (int)(((t_QMrec *)a)->nrQMatoms)-(int)(((t_QMrec *)b)->nrQMatoms); } void sort_QMlayers(t_QMMMrec *qr){ qsort(qr->qm,qr->nrQMlayers, (size_t)sizeof(qr->qm[0]), QMlayer_comp); } real call_QMroutine(t_commrec *cr, t_forcerec *fr, t_QMrec *qm, t_MMrec *mm, rvec f[], rvec fshift[]) { real QMener=0.0; if (qm->QMmethod<eQMmethodRHF && !(mm->nrMMatoms)) { #ifdef GMX_QMMM_MOPAC if (qm->bSH) QMener = call_mopac_SH(cr,fr,qm,mm,f,fshift); else QMener = call_mopac(cr,fr,qm,mm,f,fshift); #else gmx_fatal(FARGS,"Semi-empirical QM only supported with Mopac."); #endif } else { if (qm->bSH && qm->QMmethod==eQMmethodCASSCF) { #ifdef GMX_QMMM_GAUSSIAN QMener = call_gaussian_SH(cr,fr,qm,mm,f,fshift); #else gmx_fatal(FARGS,"Ab-initio Surface-hopping only supported with Gaussian."); #endif } else { #ifdef GMX_QMMM_GAMESS QMener = call_gamess(cr,fr,qm,mm,f,fshift); #elif defined GMX_QMMM_GAUSSIAN QMener = call_gaussian(cr,fr,qm,mm,f,fshift); #elif defined GMX_QMMM_ORCA QMener = call_orca(cr,fr,qm,mm,f,fshift); #else gmx_fatal(FARGS,"Ab-initio calculation only supported with Gamess, Gaussian or ORCA."); #endif } } return (QMener); } void init_QMroutine(t_commrec *cr, t_QMrec *qm, t_MMrec *mm) { if (qm->QMmethod<eQMmethodRHF){ #ifdef GMX_QMMM_MOPAC init_mopac(cr,qm,mm); #else gmx_fatal(FARGS,"Semi-empirical QM only supported with Mopac."); #endif } else { #ifdef GMX_QMMM_GAMESS init_gamess(cr,qm,mm); #elif defined GMX_QMMM_GAUSSIAN init_gaussian(cr,qm,mm); #elif defined GMX_QMMM_ORCA init_orca(cr,qm,mm); #else gmx_fatal(FARGS,"Ab-initio calculation only supported with Gamess, Gaussian or ORCA."); #endif } } void update_QMMM_coord(rvec x[],t_forcerec *fr, t_QMrec *qm, t_MMrec *mm) { int i; for(i=0;i<qm->nrQMatoms;i++){ rvec_sub(x[qm->indexQM[i]],fr->shift_vec[qm->shiftQM[i]],qm->xQM[i]); } for(i=0;i<mm->nrMMatoms;i++){ rvec_sub(x[mm->indexMM[i]],fr->shift_vec[mm->shiftMM[i]],mm->xMM[i]); } } static void punch_QMMM_excl(t_QMrec *qm,t_MMrec *mm,t_blocka *excls) { FILE *out=NULL; int i,j,k,nrexcl=0,*excluded=NULL,max=0; out = fopen("QMMMexcl.dat","w"); for(i=0;i<qm->nrQMatoms;i++){ nrexcl = 0; for(j=excls->index[qm->indexQM[i]]; j<excls->index[qm->indexQM[i]+1]; j++){ for(k=0;k<mm->nrMMatoms;k++){ if(mm->indexMM[k]==excls->a[j]){ if(nrexcl >= max){ max += 1000; srenew(excluded,max); } excluded[nrexcl++]=k; continue; } } } fprintf(out,"%5d %5d\n",i+1,nrexcl); for(j=0;j<nrexcl;j++){ fprintf(out,"%5d ",excluded[j]); } fprintf(out,"\n"); } free(excluded); fclose(out); } t_QMrec *mk_QMrec(void){ t_QMrec *qm; snew(qm,1); return qm; } t_MMrec *mk_MMrec(void){ t_MMrec *mm; snew(mm,1); return mm; } static void init_QMrec(int grpnr, t_QMrec *qm,int nr, int *atomarray, gmx_mtop_t *mtop, t_inputrec *ir) { int i; t_atom *atom; qm->nrQMatoms = nr; snew(qm->xQM,nr); snew(qm->indexQM,nr); snew(qm->shiftQM,nr); for(i=0;i<nr;i++){ qm->indexQM[i]=atomarray[i]; } snew(qm->atomicnumberQM,nr); for (i=0;i<qm->nrQMatoms;i++){ gmx_mtop_atomnr_to_atom(mtop,qm->indexQM[i],&atom); qm->nelectrons += mtop->atomtypes.atomnumber[atom->type]; qm->atomicnumberQM[i] = mtop->atomtypes.atomnumber[atom->type]; } qm->QMcharge = ir->opts.QMcharge[grpnr]; qm->multiplicity = ir->opts.QMmult[grpnr]; qm->nelectrons -= ir->opts.QMcharge[grpnr]; qm->QMmethod = ir->opts.QMmethod[grpnr]; qm->QMbasis = ir->opts.QMbasis[grpnr]; qm->bSH = ir->opts.bSH[grpnr]; qm->CASorbitals = ir->opts.CASorbitals[grpnr]; qm->CASelectrons = ir->opts.CASelectrons[grpnr]; qm->SAsteps = ir->opts.SAsteps[grpnr]; qm->SAon = ir->opts.SAon[grpnr]; qm->SAoff = ir->opts.SAoff[grpnr]; qm->nQMcpus = 0; fprintf(stderr,"Layer %d\nnr of QM atoms %d\n",grpnr,nr); fprintf(stderr,"QMlevel: %s/%s\n\n", eQMmethod_names[qm->QMmethod],eQMbasis_names[qm->QMbasis]); snew(qm->frontatoms,nr); snew(qm->c6,nr); snew(qm->c12,nr); qm->bTS = ir->opts.bTS[grpnr]; qm->bOPT = ir->opts.bOPT[grpnr]; } t_QMrec *copy_QMrec(t_QMrec *qm) { t_QMrec *qmcopy; int i; qmcopy = mk_QMrec(); qmcopy->nrQMatoms = qm->nrQMatoms; snew(qmcopy->xQM,qmcopy->nrQMatoms); snew(qmcopy->indexQM,qmcopy->nrQMatoms); snew(qmcopy->atomicnumberQM,qm->nrQMatoms); snew(qmcopy->shiftQM,qmcopy->nrQMatoms); for (i=0;i<qmcopy->nrQMatoms;i++){ qmcopy->shiftQM[i] = qm->shiftQM[i]; qmcopy->indexQM[i] = qm->indexQM[i]; qmcopy->atomicnumberQM[i] = qm->atomicnumberQM[i]; } qmcopy->nelectrons = qm->nelectrons; qmcopy->multiplicity = qm->multiplicity; qmcopy->QMcharge = qm->QMcharge; qmcopy->nelectrons = qm->nelectrons; qmcopy->QMmethod = qm->QMmethod; qmcopy->QMbasis = qm->QMbasis; qmcopy->bSH = qm->bSH; qmcopy->CASorbitals = qm->CASorbitals; qmcopy->CASelectrons = qm->CASelectrons; qmcopy->SAsteps = qm->SAsteps; qmcopy->SAon = qm->SAon; qmcopy->SAoff = qm->SAoff; qmcopy->bOPT = qm->bOPT; qmcopy->nQMcpus = qm->nQMcpus; for(i=0;i<DIM;i++) qmcopy->SHbasis[i] = qm->SHbasis[i]; qmcopy->QMmem = qm->QMmem; qmcopy->accuracy = qm->accuracy; qmcopy->cpmcscf = qm->cpmcscf; qmcopy->SAstep = qm->SAstep; snew(qmcopy->frontatoms,qm->nrQMatoms); snew(qmcopy->c12,qmcopy->nrQMatoms); snew(qmcopy->c6,qmcopy->nrQMatoms); if(qmcopy->bTS||qmcopy->bOPT){ for(i=1;i<qmcopy->nrQMatoms;i++){ qmcopy->frontatoms[i] = qm->frontatoms[i]; qmcopy->c12[i] = qm->c12[i]; qmcopy->c6[i] = qm->c6[i]; } } return(qmcopy); } t_QMMMrec *mk_QMMMrec(void) { t_QMMMrec *qr; snew(qr,1); return qr; } void init_QMMMrec(t_commrec *cr, matrix box, gmx_mtop_t *mtop, t_inputrec *ir, t_forcerec *fr) { gmx_groups_t *groups; atom_id *qm_arr=NULL,vsite,ai,aj; int qm_max=0,qm_nr=0,i,j,jmax,k,l,nrvsite2=0; t_QMMMrec *qr; t_MMrec *mm; t_iatom *iatoms; real c12au,c6au; gmx_mtop_atomloop_all_t aloop; t_atom *atom; gmx_mtop_ilistloop_all_t iloop; int a_offset; t_ilist *ilist_mol; c6au = (HARTREE2KJ*AVOGADRO*pow(BOHR2NM,6)); c12au = (HARTREE2KJ*AVOGADRO*pow(BOHR2NM,12)); if ( PAR(cr)) gmx_fatal(FARGS,"QM/MM does not work in parallel, use a single node instead\n"); qr = fr->qr; qr->QMMMscheme = ir->QMMMscheme; jmax = ir->opts.ngQM; if(qr->QMMMscheme==eQMMMschemeoniom) qr->nrQMlayers = jmax; else qr->nrQMlayers = 1; groups = &mtop->groups; snew(qr->qm,jmax); for(j=0;j<jmax;j++){ aloop = gmx_mtop_atomloop_all_init(mtop); while (gmx_mtop_atomloop_all_next(aloop,&i,&atom)) { if(qm_nr >= qm_max){ qm_max += 1000; srenew(qm_arr,qm_max); } if (ggrpnr(groups,egcQMMM ,i) == j) { qm_arr[qm_nr++] = i; } } if(qr->QMMMscheme==eQMMMschemeoniom){ qr->qm[j] = mk_QMrec(); iloop = gmx_mtop_ilistloop_all_init(mtop); while (gmx_mtop_ilistloop_all_next(iloop,&ilist_mol,&a_offset)) { nrvsite2 = ilist_mol[F_VSITE2].nr; iatoms = ilist_mol[F_VSITE2].iatoms; for(k=0; k<nrvsite2; k+=4) { vsite = a_offset + iatoms[k+1]; ai = a_offset + iatoms[k+2]; aj = a_offset + iatoms[k+3]; if (ggrpnr(groups, egcQMMM, vsite) == ggrpnr(groups, egcQMMM, ai) && ggrpnr(groups, egcQMMM, vsite) == ggrpnr(groups, egcQMMM, aj)) { for(i=0;i<qm_nr;i++){ if(qm_arr[i]==vsite){ for(l=i;l<qm_nr;l++){ qm_arr[l]=qm_arr[l+1]; } qm_nr--; } } } } } init_QMrec(j,qr->qm[j],qm_nr,qm_arr,mtop,ir); if(qr->qm[j]->bOPT || qr->qm[j]->bTS){ for(i=0;i<qm_nr;i++){ qr->qm[j]->c6[i] = C6(fr->nbfp,mtop->ffparams.atnr, atom->type,atom->type)/c6au; qr->qm[j]->c12[i] = C12(fr->nbfp,mtop->ffparams.atnr, atom->type,atom->type)/c12au; } } iloop = gmx_mtop_ilistloop_all_init(mtop); while (gmx_mtop_ilistloop_all_next(iloop,&ilist_mol,&a_offset)) { nrvsite2 = ilist_mol[F_VSITE2].nr; iatoms = ilist_mol[F_VSITE2].iatoms; for(k=0; k<nrvsite2; k+=4){ vsite = a_offset + iatoms[k+1]; ai = a_offset + iatoms[k+2]; aj = a_offset + iatoms[k+3]; if(ggrpnr(groups,egcQMMM,ai) < (groups->grps[egcQMMM].nr-1) && (ggrpnr(groups,egcQMMM,aj) >= (groups->grps[egcQMMM].nr-1))){ for(i=0;i<qm_nr;i++){ if( (qm_arr[i]==ai) || (qm_arr[i]==vsite) ){ qr->qm[j]->frontatoms[i]=TRUE; } } } else if(ggrpnr(groups,egcQMMM,aj) < (groups->grps[egcQMMM].nr-1) && (ggrpnr(groups,egcQMMM,ai) >= (groups->grps[egcQMMM].nr-1))){ for(i=0;i<qm_nr;i++){ if( (qm_arr[i]==aj) || (qm_arr[i]==vsite)){ qr->qm[j]->frontatoms[i]=TRUE; } } } } } } } if(qr->QMMMscheme!=eQMMMschemeoniom){ for (k=0;k<qm_nr;k++){ gmx_mtop_atomnr_to_atom(mtop,qm_arr[k],&atom); atom->q = 0.0; atom->qB = 0.0; } qr->qm[0] = mk_QMrec(); init_QMrec(0,qr->qm[0],qm_nr,qm_arr,mtop,ir); if(qr->qm[0]->bOPT || qr->qm[0]->bTS){ for(i=0;i<qm_nr;i++){ gmx_mtop_atomnr_to_atom(mtop,qm_arr[i],&atom); qr->qm[0]->c6[i] = C6(fr->nbfp,mtop->ffparams.atnr, atom->type,atom->type)/c6au; qr->qm[0]->c12[i] = C12(fr->nbfp,mtop->ffparams.atnr, atom->type,atom->type)/c12au; } } for(i=0;i<qm_nr;i++) { gmx_mtop_atomnr_to_ilist(mtop,qm_arr[i],&ilist_mol,&a_offset); nrvsite2 = ilist_mol[F_VSITE2].nr; iatoms = ilist_mol[F_VSITE2].iatoms; for(k=0;k<nrvsite2;k+=4){ vsite = a_offset + iatoms[k+1]; ai = a_offset + iatoms[k+2]; aj = a_offset + iatoms[k+3]; if(ggrpnr(groups,egcQMMM,ai) < (groups->grps[egcQMMM].nr-1) && (ggrpnr(groups,egcQMMM,aj) >= (groups->grps[egcQMMM].nr-1))){ if ( (qm_arr[i]==ai) || (qm_arr[i]==vsite) ){ qr->qm[0]->frontatoms[i]=TRUE; } } else if (ggrpnr(groups,egcQMMM,aj) < (groups->grps[egcQMMM].nr-1) && (ggrpnr(groups,egcQMMM,ai) >=(groups->grps[egcQMMM].nr-1))) { if ( (qm_arr[i]==aj) || (qm_arr[i]==vsite) ){ qr->qm[0]->frontatoms[i]=TRUE; } } } } mm = mk_MMrec(); mm->scalefactor = ir->scalefactor; mm->nrMMatoms = (mtop->natoms)-(qr->qm[0]->nrQMatoms); qr->mm = mm; } else { mm = mk_MMrec(); mm->scalefactor = ir->scalefactor; mm->nrMMatoms = 0; qr->mm = mm; } if(qr->nrQMlayers==1){ if (qr->qm[0]->QMmethod<eQMmethodRHF) { #ifdef GMX_QMMM_MOPAC init_mopac(cr,qr->qm[0],qr->mm); #else gmx_fatal(FARGS,"Semi-empirical QM only supported with Mopac."); #endif } else { #ifdef GMX_QMMM_GAMESS init_gamess(cr,qr->qm[0],qr->mm); #elif defined GMX_QMMM_GAUSSIAN init_gaussian(cr,qr->qm[0],qr->mm); #elif defined GMX_QMMM_ORCA init_orca(cr,qr->qm[0],qr->mm); #else gmx_fatal(FARGS,"Ab-initio calculation only supported with Gamess, Gaussian or ORCA."); #endif } } } void update_QMMMrec(t_commrec *cr, t_forcerec *fr, rvec x[], t_mdatoms *md, matrix box, gmx_localtop_t *top) { int mm_max=0,mm_nr=0,mm_nr_new,i,j,is,k,shift; t_j_particle *mm_j_particles=NULL,*qm_i_particles=NULL; t_QMMMrec *qr; t_nblist QMMMlist; rvec dx,crd; int *MMatoms; t_QMrec *qm; t_MMrec *mm; t_pbc pbc; int *parallelMMarray=NULL; real c12au,c6au; c6au = (HARTREE2KJ*AVOGADRO*pow(BOHR2NM,6)); c12au = (HARTREE2KJ*AVOGADRO*pow(BOHR2NM,12)); qr = fr->qr; mm = qr->mm; QMMMlist = fr->QMMMlist; set_pbc_dd(&pbc,fr->ePBC,DOMAINDECOMP(cr) ? cr->dd : NULL,FALSE,box); if(qr->QMMMscheme==eQMMMschemenormal){ qm = qr->qm[0]; snew(qm_i_particles,QMMMlist.nri); if(QMMMlist.nri){ qm_i_particles[0].shift = XYZ2IS(0,0,0); for(i=0;i<QMMMlist.nri;i++){ qm_i_particles[i].j = QMMMlist.iinr[i]; if(i){ qm_i_particles[i].shift = pbc_dx_aiuc(&pbc,x[QMMMlist.iinr[0]], x[QMMMlist.iinr[i]],dx); } crd[0] = IS2X(QMMMlist.shift[i]) + IS2X(qm_i_particles[i].shift); crd[1] = IS2Y(QMMMlist.shift[i]) + IS2Y(qm_i_particles[i].shift); crd[2] = IS2Z(QMMMlist.shift[i]) + IS2Z(qm_i_particles[i].shift); is = XYZ2IS(crd[0],crd[1],crd[2]); for(j=QMMMlist.jindex[i]; j<QMMMlist.jindex[i+1]; j++){ if(mm_nr >= mm_max){ mm_max += 1000; srenew(mm_j_particles,mm_max); } mm_j_particles[mm_nr].j = QMMMlist.jjnr[j]; mm_j_particles[mm_nr].shift = is; mm_nr++; } } qsort(qm_i_particles,QMMMlist.nri, (size_t)sizeof(qm_i_particles[0]), struct_comp); qsort(mm_j_particles,mm_nr, (size_t)sizeof(mm_j_particles[0]), struct_comp); j=0; for(i=0;i<QMMMlist.nri;i++){ if (i==0 || qm_i_particles[i].j!=qm_i_particles[i-1].j){ qm_i_particles[j++] = qm_i_particles[i]; } } mm_nr_new = 0; if(qm->bTS||qm->bOPT){ for(i=0;i<mm_nr;i++){ if((i==0 || mm_j_particles[i].j!=mm_j_particles[i-1].j) && !md->bQM[mm_j_particles[i].j]){ mm_j_particles[mm_nr_new++] = mm_j_particles[i]; } } } else{ for(i=0;i<mm_nr;i++){ if((i==0 || mm_j_particles[i].j!=mm_j_particles[i-1].j) && !md->bQM[mm_j_particles[i].j] && (md->chargeA[mm_j_particles[i].j] || (md->chargeB && md->chargeB[mm_j_particles[i].j]))) { mm_j_particles[mm_nr_new++] = mm_j_particles[i]; } } } mm_nr = mm_nr_new; k=0; shift = 0; for(i=0;i<qm->nrQMatoms;i++){ if (qm->indexQM[i] == qm_i_particles[k].j) { shift = qm_i_particles[k++].shift; } qm->shiftQM[i] = shift; } } if(PAR(cr)){ snew(parallelMMarray,2*(md->nr)); for(i=0;i<2*(md->nr);i++){ parallelMMarray[i]=0; } for(i=0;i<mm_nr;i++){ parallelMMarray[mm_j_particles[i].j]=1; parallelMMarray[mm_j_particles[i].j+(md->nr)]=mm_j_particles[i].shift; } gmx_sumi(md->nr,parallelMMarray,cr); mm_nr=0; mm_max = 0; for(i=0;i<md->nr;i++){ if(parallelMMarray[i]){ if(mm_nr >= mm_max){ mm_max += 1000; srenew(mm->indexMM,mm_max); srenew(mm->shiftMM,mm_max); } mm->indexMM[mm_nr] = i; mm->shiftMM[mm_nr++]= parallelMMarray[i+md->nr]/parallelMMarray[i]; } } mm->nrMMatoms=mm_nr; free(parallelMMarray); } else{ mm->nrMMatoms = mm_nr; srenew(mm->shiftMM,mm_nr); srenew(mm->indexMM,mm_nr); for(i=0;i<mm_nr;i++){ mm->indexMM[i]=mm_j_particles[i].j; mm->shiftMM[i]=mm_j_particles[i].shift; } } srenew(mm->xMM,mm->nrMMatoms); srenew(mm->MMcharges,mm->nrMMatoms); for(i=0;i<mm->nrMMatoms;i++){ mm->MMcharges[i]=md->chargeA[mm->indexMM[i]]*mm->scalefactor; } if(qm->bTS||qm->bOPT){ srenew(mm->c6,mm->nrMMatoms); srenew(mm->c12,mm->nrMMatoms); for (i=0;i<mm->nrMMatoms;i++){ mm->c6[i] = C6(fr->nbfp,top->idef.atnr, md->typeA[mm->indexMM[i]], md->typeA[mm->indexMM[i]])/c6au; mm->c12[i] =C12(fr->nbfp,top->idef.atnr, md->typeA[mm->indexMM[i]], md->typeA[mm->indexMM[i]])/c12au; } punch_QMMM_excl(qr->qm[0],mm,&(top->excls)); } update_QMMM_coord(x,fr,qr->qm[0],qr->mm); free(qm_i_particles); free(mm_j_particles); } else { mm->nrMMatoms=0; for (j=0;j<qr->nrQMlayers;j++){ qm = qr->qm[j]; qm->shiftQM[0]=XYZ2IS(0,0,0); for(i=1;i<qm->nrQMatoms;i++){ qm->shiftQM[i] = pbc_dx_aiuc(&pbc,x[qm->indexQM[0]],x[qm->indexQM[i]], dx); } update_QMMM_coord(x,fr,qm,mm); } } } real calculate_QMMM(t_commrec *cr, rvec x[],rvec f[], t_forcerec *fr, t_mdatoms *md) { real QMener=0.0; t_QMMMrec *qr; t_QMrec *qm,*qm2; t_MMrec *mm=NULL; rvec *forces=NULL,*fshift=NULL, *forces2=NULL, *fshift2=NULL; int i,j,k; qr = fr->qr; mm = qr->mm; if(qr->QMMMscheme==eQMMMschemenormal || qr->nrQMlayers==1){ qm = qr->qm[0]; snew(forces,(qm->nrQMatoms+mm->nrMMatoms)); snew(fshift,(qm->nrQMatoms+mm->nrMMatoms)); QMener = call_QMroutine(cr,fr,qm,mm,forces,fshift); for(i=0;i<qm->nrQMatoms;i++){ for(j=0;j<DIM;j++){ f[qm->indexQM[i]][j] -= forces[i][j]; fr->fshift[qm->shiftQM[i]][j] += fshift[i][j]; } } for(i=0;i<mm->nrMMatoms;i++){ for(j=0;j<DIM;j++){ f[mm->indexMM[i]][j] -= forces[qm->nrQMatoms+i][j]; fr->fshift[mm->shiftMM[i]][j] += fshift[qm->nrQMatoms+i][j]; } } free(forces); free(fshift); } else{ for(i=0;i<qr->nrQMlayers-1;i++){ qm = qr->qm[i]; qm2 = copy_QMrec(qr->qm[i+1]); qm2->nrQMatoms = qm->nrQMatoms; for(j=0;j<qm2->nrQMatoms;j++){ for(k=0;k<DIM;k++) qm2->xQM[j][k] = qm->xQM[j][k]; qm2->indexQM[j] = qm->indexQM[j]; qm2->atomicnumberQM[j] = qm->atomicnumberQM[j]; qm2->shiftQM[j] = qm->shiftQM[j]; } qm2->QMcharge = qm->QMcharge; srenew(forces,qm->nrQMatoms); srenew(fshift,qm->nrQMatoms); init_QMroutine(cr,qm,mm); QMener += call_QMroutine(cr,fr,qm,mm,forces,fshift); srenew(forces2,qm->nrQMatoms); srenew(fshift2,qm->nrQMatoms); init_QMroutine(cr,qm2,mm); QMener -= call_QMroutine(cr,fr,qm2,mm,forces2,fshift2); for(i=0;i<qm->nrQMatoms;i++){ for(j=0;j<DIM;j++){ f[qm->indexQM[i]][j] -= (forces[i][j]-forces2[i][j]); fr->fshift[qm->shiftQM[i]][j] += (fshift[i][j]-fshift2[i][j]); } } free(qm2); } qm = qr->qm[qr->nrQMlayers-1]; init_QMroutine(cr,qm,mm); srenew(forces,qm->nrQMatoms); srenew(fshift,qm->nrQMatoms); QMener += call_QMroutine(cr,fr,qm,mm,forces,fshift); for(i=0;i<qm->nrQMatoms;i++){ for(j=0;j<DIM;j++){ f[qm->indexQM[i]][j] -= forces[i][j]; fr->fshift[qm->shiftQM[i]][j] += fshift[i][j]; } } free(forces); free(fshift); free(forces2); free(fshift2); } if(qm->bTS||qm->bOPT){ for(i=0;i<qm->nrQMatoms;i++){ for(j=0;j<DIM;j++){ x[qm->indexQM[i]][j] = qm->xQM[i][j]; } } } return(QMener); }
#ifdef HAVE_CONFIG_H #include <config.h> #endif #include <stdio.h> #include <stdlib.h> #include <string.h> #include "domdec.h" #include "gmx_wallcycle.h" #include "trnio.h" #include "smalloc.h" #include "network.h" #include "pbc.h" #include "futil.h" #include "mdrun.h" #include "txtdump.h" #include "names.h" #include "mtop_util.h" #include "names.h" #include "nrjac.h" #include "vec.h" #include "gmx_ga2la.h" #include "xvgr.h" #include "gmxfio.h" #include "groupcoord.h" #include "pull_rotation.h" #include "gmx_sort.h" #include "copyrite.h" #include "gmx_cyclecounter.h" static char *RotStr = {"Enforced rotation:"}; #define WEIGHT_MIN (10*GMX_FLOAT_MIN) typedef struct { real xcproj; int ind; real m; rvec x; rvec x_ref; } sort_along_vec_t; typedef struct gmx_slabdata { int nat; rvec *x; rvec *ref; real *weight; } t_gmx_slabdata; typedef struct gmx_potfit { real *degangle; real *V; matrix *rotmat; } t_gmx_potfit; typedef struct gmx_enfrot { FILE *out_rot; FILE *out_torque; FILE *out_angles; FILE *out_slabs; int bufsize; rvec *xbuf; real *mbuf; sort_along_vec_t *data; real *mpi_inbuf; real *mpi_outbuf; int mpi_bufsize; unsigned long Flags; gmx_bool bOut; } t_gmx_enfrot; typedef struct gmx_enfrotgrp { real degangle; matrix rotmat; atom_id *ind_loc; int nat_loc; int nalloc_loc; real V; rvec *f_rot_loc; real *xc_ref_length; int *xc_ref_ind; rvec xc_center; rvec xc_ref_center; rvec *xc; ivec *xc_shifts; ivec *xc_eshifts; rvec *xc_old; rvec *xc_norm; rvec *xc_ref_sorted; int *xc_sortind; real *mc; real *mc_sorted; real invmass; real torque_v; real angle_v; real weight_v; rvec *xr_loc; rvec *x_loc_pbc; real *m_loc; int nslabs_alloc; int slab_first; int slab_last; int slab_first_ref; int slab_last_ref; int slab_buffer; int *firstatom; int *lastatom; rvec *slab_center; rvec *slab_center_ref; real *slab_weights; real *slab_torque_v; real max_beta; real *gn_atom; int *gn_slabind; rvec *slab_innersumvec; t_gmx_slabdata *slab_data; t_gmx_potfit *PotAngleFit; } t_gmx_enfrotgrp; #ifdef PRINT_FORCES #define PRINT_FORCE_J fprintf(stderr,"f%d = %15.8f %15.8f %15.8f\n",erg->xc_ref_ind[j],erg->f_rot_loc[j][XX], erg->f_rot_loc[j][YY], erg->f_rot_loc[j][ZZ]); #define PRINT_POT_TAU if (MASTER(cr)) { \ fprintf(stderr,"potential = %15.8f\n" "torque = %15.8f\n", erg->V, erg->torque_v); \ } #else #define PRINT_FORCE_J #define PRINT_POT_TAU #endif #define ISFLEX(rg) ( (rg->eType==erotgFLEX) || (rg->eType==erotgFLEXT) || (rg->eType==erotgFLEX2) || (rg->eType==erotgFLEX2T) ) #define ISCOLL(rg) ( (rg->eType==erotgFLEX) || (rg->eType==erotgFLEXT) || (rg->eType==erotgFLEX2) || (rg->eType==erotgFLEX2T) || (rg->eType==erotgRMPF) || (rg->eType==erotgRM2PF) ) static gmx_bool HaveFlexibleGroups(t_rot *rot) { int g; t_rotgrp *rotg; for (g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; if (ISFLEX(rotg)) return TRUE; } return FALSE; } static gmx_bool HavePotFitGroups(t_rot *rot) { int g; t_rotgrp *rotg; for (g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; if (erotgFitPOT == rotg->eFittype) return TRUE; } return FALSE; } static double** allocate_square_matrix(int dim) { int i; double** mat = NULL; snew(mat, dim); for(i=0; i<dim; i++) snew(mat[i], dim); return mat; } static void free_square_matrix(double** mat, int dim) { int i; for (i=0; i<dim; i++) sfree(mat[i]); sfree(mat); } static real get_fitangle(t_rotgrp *rotg, gmx_enfrotgrp_t erg) { int i; real fitangle = -999.9; real pot_min = GMX_FLOAT_MAX; t_gmx_potfit *fit; fit = erg->PotAngleFit; for (i = 0; i < rotg->PotAngle_nstep; i++) { if (fit->V[i] < pot_min) { pot_min = fit->V[i]; fitangle = fit->degangle[i]; } } return fitangle; } static gmx_inline gmx_bool bPotAngle(t_rot *rot, t_rotgrp *rotg, gmx_large_int_t step) { return ( (erotgFitPOT==rotg->eFittype) && (do_per_step(step, rot->nstsout) || do_per_step(step, rot->nstrout)) ); } static gmx_inline gmx_bool bSlabTau(t_rot *rot, t_rotgrp *rotg, gmx_large_int_t step) { return ( (ISFLEX(rotg)) && do_per_step(step, rot->nstsout) ); } static void reduce_output(t_commrec *cr, t_rot *rot, real t, gmx_large_int_t step) { int g,i,islab,nslabs=0; int count; t_rotgrp *rotg; gmx_enfrot_t er; gmx_enfrotgrp_t erg; real fitangle; gmx_bool bFlex; er=rot->enfrot; if (PAR(cr)) { count=0; for (g=0; g < rot->ngrp; g++) { rotg = &rot->grp[g]; erg = rotg->enfrotgrp; nslabs = erg->slab_last - erg->slab_first + 1; er->mpi_inbuf[count++] = erg->V; er->mpi_inbuf[count++] = erg->torque_v; er->mpi_inbuf[count++] = erg->angle_v; er->mpi_inbuf[count++] = erg->weight_v; if (bPotAngle(rot, rotg, step)) { for (i = 0; i < rotg->PotAngle_nstep; i++) er->mpi_inbuf[count++] = erg->PotAngleFit->V[i]; } if (bSlabTau(rot, rotg, step)) { for (i=0; i<nslabs; i++) er->mpi_inbuf[count++] = erg->slab_torque_v[i]; } } if (count > er->mpi_bufsize) gmx_fatal(FARGS, "%s MPI buffer overflow, please report this error.", RotStr); #ifdef GMX_MPI MPI_Reduce(er->mpi_inbuf, er->mpi_outbuf, count, GMX_MPI_REAL, MPI_SUM, MASTERRANK(cr), cr->mpi_comm_mygroup); #endif if (MASTER(cr)) { count=0; for (g=0; g < rot->ngrp; g++) { rotg = &rot->grp[g]; erg = rotg->enfrotgrp; nslabs = erg->slab_last - erg->slab_first + 1; erg->V = er->mpi_outbuf[count++]; erg->torque_v = er->mpi_outbuf[count++]; erg->angle_v = er->mpi_outbuf[count++]; erg->weight_v = er->mpi_outbuf[count++]; if (bPotAngle(rot, rotg, step)) { for (i = 0; i < rotg->PotAngle_nstep; i++) erg->PotAngleFit->V[i] = er->mpi_outbuf[count++]; } if (bSlabTau(rot, rotg, step)) { for (i=0; i<nslabs; i++) erg->slab_torque_v[i] = er->mpi_outbuf[count++]; } } } } if (MASTER(cr)) { for (g=0; g < rot->ngrp; g++) { rotg=&rot->grp[g]; bFlex = ISFLEX(rotg); erg=rotg->enfrotgrp; if ( do_per_step(step, rot->nstrout) ) { if (erotgFitPOT == rotg->eFittype) { fitangle = get_fitangle(rotg, erg); } else { if (bFlex) fitangle = erg->angle_v; else fitangle = (erg->angle_v/erg->weight_v)*180.0*M_1_PI; } fprintf(er->out_rot, "%12.4f", fitangle); fprintf(er->out_rot, "%12.3e", erg->torque_v); fprintf(er->out_rot, "%12.3e", erg->V); } if ( do_per_step(step, rot->nstsout) ) { if (bFlex) { fprintf(er->out_torque, "%12.3e%6d", t, g); for (i=erg->slab_first; i<=erg->slab_last; i++) { islab = i - erg->slab_first; if (erg->slab_weights[islab] > rotg->min_gaussian) fprintf(er->out_torque, "%6d%12.3e", i, erg->slab_torque_v[islab]); } fprintf(er->out_torque , "\n"); } if (erotgFitPOT == rotg->eFittype) { fprintf(er->out_angles, "%12.3e%6d%12.4f", t, g, erg->degangle); for (i = 0; i < rotg->PotAngle_nstep; i++) fprintf(er->out_angles, "%12.3e", erg->PotAngleFit->V[i]); fprintf(er->out_angles, "\n"); } } } if ( do_per_step(step, rot->nstrout) ) fprintf(er->out_rot, "\n"); } } extern real add_rot_forces(t_rot *rot, rvec f[], t_commrec *cr, gmx_large_int_t step, real t) { int g,l,ii; t_rotgrp *rotg; gmx_enfrot_t er; gmx_enfrotgrp_t erg; real Vrot = 0.0; er=rot->enfrot; for (g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; erg=rotg->enfrotgrp; Vrot += erg->V; for (l=0; l<erg->nat_loc; l++) { ii = erg->ind_loc[l]; rvec_inc(f[ii],erg->f_rot_loc[l]); } } if ( (do_per_step(step, rot->nstrout) || do_per_step(step, rot->nstsout)) && er->bOut) reduce_output(cr, rot, t, step); er->bOut = TRUE; PRINT_POT_TAU return Vrot; } #define GAUSS_NORM 0.569917543430618 static double calc_beta_max(real min_gaussian, real slab_dist) { double sigma; double arg; if (slab_dist <= 0) gmx_fatal(FARGS, "Slab distance of flexible rotation groups must be >=0 !"); if (min_gaussian <= 0) gmx_fatal(FARGS, "Cutoff value for Gaussian must be > 0. (You requested %f)"); sigma = 0.7*slab_dist; arg = min_gaussian/GAUSS_NORM; if (arg > 1.0) gmx_fatal(FARGS, "min_gaussian of flexible rotation groups must be <%g", GAUSS_NORM); return sqrt(-2.0*sigma*sigma*log(min_gaussian/GAUSS_NORM)); } static gmx_inline real calc_beta(rvec curr_x, t_rotgrp *rotg, int n) { return iprod(curr_x, rotg->vec) - rotg->slab_dist * n; } static gmx_inline real gaussian_weight(rvec curr_x, t_rotgrp *rotg, int n) { const real norm = GAUSS_NORM; real sigma; sigma = 0.7*rotg->slab_dist; return norm * exp( -0.5 * sqr( calc_beta(curr_x, rotg, n)/sigma ) ); } static real get_slab_weight(int j, t_rotgrp *rotg, rvec xc[], real mc[], rvec *x_weighted_sum) { rvec curr_x; rvec curr_x_weighted; real gaussian; real wgauss; real slabweight = 0.0; int i,islab; gmx_enfrotgrp_t erg; erg=rotg->enfrotgrp; clear_rvec(*x_weighted_sum); islab = j - erg->slab_first; for (i=0; i<rotg->nat; i++) { copy_rvec(xc[i], curr_x); gaussian = gaussian_weight(curr_x, rotg, j); wgauss = gaussian * mc[i]; svmul(wgauss, curr_x, curr_x_weighted); rvec_add(*x_weighted_sum, curr_x_weighted, *x_weighted_sum); slabweight += wgauss; } return slabweight; } static void get_slab_centers( t_rotgrp *rotg, rvec *xc, real *mc, int g, real time, FILE *out_slabs, gmx_bool bOutStep, gmx_bool bReference) { int j,islab; gmx_enfrotgrp_t erg; erg=rotg->enfrotgrp; for (j = erg->slab_first; j <= erg->slab_last; j++) { islab = j - erg->slab_first; erg->slab_weights[islab] = get_slab_weight(j, rotg, xc, mc, &erg->slab_center[islab]); if (erg->slab_weights[islab] > WEIGHT_MIN) { svmul(1.0/erg->slab_weights[islab], erg->slab_center[islab], erg->slab_center[islab]); } else { gmx_fatal(FARGS, "Not enough weight in slab %d. Slab center cannot be determined!", j); } if (bReference) copy_rvec(erg->slab_center[islab], erg->slab_center_ref[islab]); } if ( (NULL != out_slabs) && bOutStep) { fprintf(out_slabs, "%12.3e%6d", time, g); for (j = erg->slab_first; j <= erg->slab_last; j++) { islab = j - erg->slab_first; fprintf(out_slabs, "%6d%12.3e%12.3e%12.3e", j,erg->slab_center[islab][XX],erg->slab_center[islab][YY],erg->slab_center[islab][ZZ]); } fprintf(out_slabs, "\n"); } } static void calc_rotmat( rvec vec, real degangle, matrix rotmat) { real radangle; real cosa; real sina; real OMcosa; real dumxy, dumxz, dumyz; rvec rot_vec; radangle = degangle * M_PI/180.0; copy_rvec(vec , rot_vec ); cosa = cos(radangle); sina = sin(radangle); OMcosa = 1.0 - cosa; dumxy = rot_vec[XX]*rot_vec[YY]*OMcosa; dumxz = rot_vec[XX]*rot_vec[ZZ]*OMcosa; dumyz = rot_vec[YY]*rot_vec[ZZ]*OMcosa; rotmat[XX][XX] = cosa + rot_vec[XX]*rot_vec[XX]*OMcosa; rotmat[YY][XX] = dumxy + rot_vec[ZZ]*sina; rotmat[ZZ][XX] = dumxz - rot_vec[YY]*sina; rotmat[XX][YY] = dumxy - rot_vec[ZZ]*sina; rotmat[YY][YY] = cosa + rot_vec[YY]*rot_vec[YY]*OMcosa; rotmat[ZZ][YY] = dumyz + rot_vec[XX]*sina; rotmat[XX][ZZ] = dumxz + rot_vec[YY]*sina; rotmat[YY][ZZ] = dumyz - rot_vec[XX]*sina; rotmat[ZZ][ZZ] = cosa + rot_vec[ZZ]*rot_vec[ZZ]*OMcosa; #ifdef PRINTMATRIX int iii,jjj; for (iii=0; iii<3; iii++) { for (jjj=0; jjj<3; jjj++) fprintf(stderr, " %10.8f ", rotmat[iii][jjj]); fprintf(stderr, "\n"); } #endif } static gmx_inline real torque( rvec rotvec, rvec force, rvec x, rvec pivot) { rvec vectmp, tau; rvec_sub(x,pivot,vectmp); cprod(vectmp, force, tau); return iprod(tau, rotvec); } static void print_aligned(FILE *fp, char *str) { fprintf(fp, "%12s", str); } static void print_aligned_short(FILE *fp, char *str) { fprintf(fp, "%6s", str); } static FILE *open_output_file(const char *fn, int steps, const char what[]) { FILE *fp; fp = ffopen(fn, "w"); fprintf(fp, "# Output of %s is written in intervals of %d time step%s.\n#\n", what,steps, steps>1 ? "s":""); return fp; } static FILE *open_slab_out(const char *fn, t_rot *rot, const output_env_t oenv) { FILE *fp; int g,i; t_rotgrp *rotg; if (rot->enfrot->Flags & MD_APPENDFILES) { fp = gmx_fio_fopen(fn,"a"); } else { fp = open_output_file(fn, rot->nstsout, "gaussian weighted slab centers"); for (g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; if (ISFLEX(rotg)) { fprintf(fp, "# Rotation group %d (%s), slab distance %f nm, %s.\n", g, erotg_names[rotg->eType], rotg->slab_dist, rotg->bMassW? "centers of mass":"geometrical centers"); } } fprintf(fp, "# Reference centers are listed first (t=-1).\n"); fprintf(fp, "# The following columns have the syntax:\n"); fprintf(fp, "# "); print_aligned_short(fp, "t"); print_aligned_short(fp, "grp"); for (i=0; i<2; i++) { print_aligned_short(fp, "slab"); print_aligned(fp, "X center"); print_aligned(fp, "Y center"); print_aligned(fp, "Z center"); } fprintf(fp, " ...\n"); fflush(fp); } return fp; } static void add_to_string(char **str, char *buf) { int len; len = strlen(*str) + strlen(buf) + 1; srenew(*str, len); strcat(*str, buf); } static void add_to_string_aligned(char **str, char *buf) { char buf_aligned[STRLEN]; sprintf(buf_aligned, "%12s", buf); add_to_string(str, buf_aligned); } static FILE *open_rot_out(const char *fn, t_rot *rot, const output_env_t oenv) { FILE *fp; int g,nsets; t_rotgrp *rotg; const char **setname; char buf[50], buf2[75]; gmx_enfrotgrp_t erg; gmx_bool bFlex; char *LegendStr=NULL; if (rot->enfrot->Flags & MD_APPENDFILES) { fp = gmx_fio_fopen(fn,"a"); } else { fp = xvgropen(fn, "Rotation angles and energy", "Time (ps)", "angles (degrees) and energies (kJ/mol)", oenv); fprintf(fp, "# Output of enforced rotation data is written in intervals of %d time step%s.\n#\n", rot->nstrout, rot->nstrout > 1 ? "s":""); fprintf(fp, "# The scalar tau is the torque (kJ/mol) in the direction of the rotation vector v.\n"); fprintf(fp, "# To obtain the vectorial torque, multiply tau with the group's rot_vec.\n"); fprintf(fp, "# For flexible groups, tau(t,n) from all slabs n have been summed in a single value tau(t) here.\n"); fprintf(fp, "# The torques tau(t,n) are found in the rottorque.log (-rt) output file\n"); for (g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; erg=rotg->enfrotgrp; bFlex = ISFLEX(rotg); fprintf(fp, "#\n"); fprintf(fp, "# ROTATION GROUP %d, potential type '%s':\n" , g, erotg_names[rotg->eType]); fprintf(fp, "# rot_massw%d %s\n" , g, yesno_names[rotg->bMassW]); fprintf(fp, "# rot_vec%d %12.5e %12.5e %12.5e\n" , g, rotg->vec[XX], rotg->vec[YY], rotg->vec[ZZ]); fprintf(fp, "# rot_rate%d %12.5e degrees/ps\n" , g, rotg->rate); fprintf(fp, "# rot_k%d %12.5e kJ/(mol*nm^2)\n" , g, rotg->k); if ( rotg->eType==erotgISO || rotg->eType==erotgPM || rotg->eType==erotgRM || rotg->eType==erotgRM2) fprintf(fp, "# rot_pivot%d %12.5e %12.5e %12.5e nm\n", g, rotg->pivot[XX], rotg->pivot[YY], rotg->pivot[ZZ]); if (bFlex) { fprintf(fp, "# rot_slab_distance%d %f nm\n", g, rotg->slab_dist); fprintf(fp, "# rot_min_gaussian%d %12.5e\n", g, rotg->min_gaussian); } if ((rotg->eType==erotgISOPF) || (rotg->eType==erotgPMPF) || (rotg->eType==erotgRMPF) || (rotg->eType==erotgRM2PF || (rotg->eType==erotgFLEXT) || (rotg->eType==erotgFLEX2T)) ) { fprintf(fp, "# ref. grp. %d center %12.5e %12.5e %12.5e\n", g, erg->xc_ref_center[XX], erg->xc_ref_center[YY], erg->xc_ref_center[ZZ]); fprintf(fp, "# grp. %d init.center %12.5e %12.5e %12.5e\n", g, erg->xc_center[XX], erg->xc_center[YY], erg->xc_center[ZZ]); } if ( (rotg->eType == erotgRM2) || (rotg->eType==erotgFLEX2) || (rotg->eType==erotgFLEX2T) ) { fprintf(fp, "# rot_eps%d %12.5e nm^2\n", g, rotg->eps); } if (erotgFitPOT == rotg->eFittype) { fprintf(fp, "#\n"); fprintf(fp, "# theta_fit%d is determined by first evaluating the potential for %d angles around theta_ref%d.\n", g, rotg->PotAngle_nstep, g); fprintf(fp, "# The fit angle is the one with the smallest potential. It is given as the deviation\n"); fprintf(fp, "# from the reference angle, i.e. if theta_ref=X and theta_fit=Y, then the angle with\n"); fprintf(fp, "# minimal value of the potential is X+Y. Angular resolution is %g degrees.\n", rotg->PotAngle_step); } } snew(LegendStr, 1); LegendStr[0] = '\0'; sprintf(buf, "# %6s", "time"); add_to_string_aligned(&LegendStr, buf); nsets = 0; snew(setname, 4*rot->ngrp); for (g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; sprintf(buf, "theta_ref%d", g); add_to_string_aligned(&LegendStr, buf); sprintf(buf2, "%s (degrees)", buf); setname[nsets] = strdup(buf2); nsets++; } for (g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; bFlex = ISFLEX(rotg); if (bFlex || erotgFitPOT == rotg->eFittype) sprintf(buf, "theta_fit%d", g); else sprintf(buf, "theta_av%d", g); add_to_string_aligned(&LegendStr, buf); sprintf(buf2, "%s (degrees)", buf); setname[nsets] = strdup(buf2); nsets++; sprintf(buf, "tau%d", g); add_to_string_aligned(&LegendStr, buf); sprintf(buf2, "%s (kJ/mol)", buf); setname[nsets] = strdup(buf2); nsets++; sprintf(buf, "energy%d", g); add_to_string_aligned(&LegendStr, buf); sprintf(buf2, "%s (kJ/mol)", buf); setname[nsets] = strdup(buf2); nsets++; } fprintf(fp, "#\n"); if (nsets > 1) xvgr_legend(fp, nsets, setname, oenv); sfree(setname); fprintf(fp, "#\n# Legend for the following data columns:\n"); fprintf(fp, "%s\n", LegendStr); sfree(LegendStr); fflush(fp); } return fp; } static FILE *open_angles_out(const char *fn, t_rot *rot, const output_env_t oenv) { int g,i; FILE *fp; t_rotgrp *rotg; gmx_enfrotgrp_t erg; char buf[100]; if (rot->enfrot->Flags & MD_APPENDFILES) { fp = gmx_fio_fopen(fn,"a"); } else { fp = open_output_file(fn, rot->nstsout, "rotation group angles"); fprintf(fp, "# All angles given in degrees, time in ps.\n"); for (g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; erg=rotg->enfrotgrp; if ( ISFLEX(rotg) || (erotgFitPOT == rotg->eFittype) ) { if (ISFLEX(rotg)) sprintf(buf, " slab distance %f nm, ", rotg->slab_dist); else buf[0] = '\0'; fprintf(fp, "#\n# ROTATION GROUP %d '%s',%s fit type '%s'.\n", g, erotg_names[rotg->eType], buf, erotg_fitnames[rotg->eFittype]); if (erotgFitPOT == rotg->eFittype) { fprintf(fp, "# To obtain theta_fit%d, the potential is evaluated for %d angles around theta_ref%d\n", g, rotg->PotAngle_nstep, g); fprintf(fp, "# The fit angle in the rotation standard outfile is the one with minimal energy E(theta_fit) [kJ/mol].\n"); fprintf(fp, "#\n"); } fprintf(fp, "# Legend for the group %d data columns:\n", g); fprintf(fp, "# "); print_aligned_short(fp, "time"); print_aligned_short(fp, "grp"); print_aligned(fp, "theta_ref"); if (erotgFitPOT == rotg->eFittype) { for (i = 0; i < rotg->PotAngle_nstep; i++) { sprintf(buf, "E(%g)", erg->PotAngleFit->degangle[i]); print_aligned(fp, buf); } } else { print_aligned_short(fp, "slab"); print_aligned_short(fp, "atoms"); print_aligned(fp, "theta_fit"); print_aligned_short(fp, "slab"); print_aligned_short(fp, "atoms"); print_aligned(fp, "theta_fit"); fprintf(fp, " ..."); } fprintf(fp, "\n"); } } fflush(fp); } return fp; } static FILE *open_torque_out(const char *fn, t_rot *rot, const output_env_t oenv) { FILE *fp; int g; t_rotgrp *rotg; if (rot->enfrot->Flags & MD_APPENDFILES) { fp = gmx_fio_fopen(fn,"a"); } else { fp = open_output_file(fn, rot->nstsout,"torques"); for (g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; if (ISFLEX(rotg)) { fprintf(fp, "# Rotation group %d (%s), slab distance %f nm.\n", g, erotg_names[rotg->eType], rotg->slab_dist); fprintf(fp, "# The scalar tau is the torque (kJ/mol) in the direction of the rotation vector.\n"); fprintf(fp, "# To obtain the vectorial torque, multiply tau with\n"); fprintf(fp, "# rot_vec%d %10.3e %10.3e %10.3e\n", g, rotg->vec[XX], rotg->vec[YY], rotg->vec[ZZ]); fprintf(fp, "#\n"); } } fprintf(fp, "# Legend for the following data columns: (tau=torque for that slab):\n"); fprintf(fp, "# "); print_aligned_short(fp, "t"); print_aligned_short(fp, "grp"); print_aligned_short(fp, "slab"); print_aligned(fp, "tau"); print_aligned_short(fp, "slab"); print_aligned(fp, "tau"); fprintf(fp, " ...\n"); fflush(fp); } return fp; } static void swap_val(double* vec, int i, int j) { double tmp = vec[j]; vec[j]=vec[i]; vec[i]=tmp; } static void swap_col(double **mat, int i, int j) { double tmp[3] = {mat[0][j], mat[1][j], mat[2][j]}; mat[0][j]=mat[0][i]; mat[1][j]=mat[1][i]; mat[2][j]=mat[2][i]; mat[0][i]=tmp[0]; mat[1][i]=tmp[1]; mat[2][i]=tmp[2]; } static void diagonalize_symmetric( double **matrix, double **eigen_vec, double eigenval[3]) { int n_rot; jacobi(matrix,3,eigenval,eigen_vec,&n_rot); if (eigenval[0] > eigenval[1]) { swap_val(eigenval, 0, 1); swap_col(eigen_vec, 0, 1); } if (eigenval[1] > eigenval[2]) { swap_val(eigenval, 1, 2); swap_col(eigen_vec, 1, 2); } if (eigenval[0] > eigenval[1]) { swap_val(eigenval, 0, 1); swap_col(eigen_vec, 0, 1); } } static void align_with_z( rvec* s, int natoms, rvec axis) { int i, j, k; rvec zet = {0.0, 0.0, 1.0}; rvec rot_axis={0.0, 0.0, 0.0}; rvec *rotated_str=NULL; real ooanorm; real angle; matrix rotmat; snew(rotated_str, natoms); ooanorm = 1.0/norm(axis); svmul(ooanorm, axis, axis); cprod(axis, zet, rot_axis); angle = acos(axis[2]); if (angle < 0.0) angle += M_PI; calc_rotmat(rot_axis, angle*180.0/M_PI, rotmat); for (i=0; i<natoms; i++) { for(j=0; j<3; j++) { for(k=0; k<3; k++) { rotated_str[i][j] += rotmat[j][k]*s[i][k]; } } } for(i=0; i<natoms; i++) { for(j=0; j<3; j++) { s[i][j]=rotated_str[i][j]; } } sfree(rotated_str); } static void calc_correl_matrix(rvec* Xstr, rvec* Ystr, double** Rmat, int natoms) { int i, j, k; for (i=0; i<3; i++) for (j=0; j<3; j++) Rmat[i][j] = 0.0; for (i=0; i<3; i++) for (j=0; j<3; j++) for (k=0; k<natoms; k++) Rmat[i][j] += Ystr[k][i] * Xstr[k][j]; } static void weigh_coords(rvec* str, real* weight, int natoms) { int i, j; for(i=0; i<natoms; i++) { for(j=0; j<3; j++) str[i][j] *= sqrt(weight[i]); } } static real opt_angle_analytic( rvec* ref_s, rvec* act_s, real* weight, int natoms, rvec ref_com, rvec act_com, rvec axis) { int i, j, k; rvec *ref_s_1=NULL; rvec *act_s_1=NULL; rvec shift; double **Rmat, **RtR, **eigvec; double eigval[3]; double V[3][3], WS[3][3]; double rot_matrix[3][3]; double opt_angle; snew(ref_s_1, natoms); snew(act_s_1, natoms); for(i=0; i<natoms; i++) { copy_rvec(ref_s[i], ref_s_1[i]); copy_rvec(act_s[i], act_s_1[i]); } shift[XX] = -ref_com[XX]; shift[YY] = -ref_com[YY]; shift[ZZ] = -ref_com[ZZ]; translate_x(ref_s_1, natoms, shift); shift[XX] = -act_com[XX]; shift[YY] = -act_com[YY]; shift[ZZ] = -act_com[ZZ]; translate_x(act_s_1, natoms, shift); align_with_z(ref_s_1, natoms, axis); align_with_z(act_s_1, natoms, axis); Rmat = allocate_square_matrix(3); for (i=0; i<natoms; i++) { ref_s_1[i][2]=0.0; act_s_1[i][2]=0.0; } if (NULL != weight) { weigh_coords(ref_s_1, weight, natoms); weigh_coords(act_s_1, weight, natoms); } calc_correl_matrix(ref_s_1, act_s_1, Rmat, natoms); RtR = allocate_square_matrix(3); for (i=0; i<3; i++) { for (j=0; j<3; j++) { for (k=0; k<3; k++) { RtR[i][j] += Rmat[k][i] * Rmat[k][j]; } } } snew(eigvec,3); for (i=0; i<3; i++) snew(eigvec[i],3); diagonalize_symmetric(RtR, eigvec, eigval); swap_col(eigvec,0,1); swap_col(eigvec,1,2); swap_val(eigval,0,1); swap_val(eigval,1,2); for(i=0; i<3; i++) { for(j=0; j<3; j++) { V[i][j] = 0.0; WS[i][j] = 0.0; } } for (i=0; i<2; i++) for (j=0; j<2; j++) WS[i][j] = eigvec[i][j] / sqrt(eigval[j]); for (i=0; i<3; i++) { for (j=0; j<3; j++) { for (k=0; k<3; k++) { V[i][j] += Rmat[i][k]*WS[k][j]; } } } free_square_matrix(Rmat, 3); for (i=0; i<3; i++) for (j=0; j<3; j++) rot_matrix[i][j] = 0.0; for (i=0; i<3; i++) { for(j=0; j<3; j++) { for(k=0; k<3; k++){ rot_matrix[i][j] += eigvec[i][k]*V[j][k]; } } } rot_matrix[2][2] = 1.0; if (rot_matrix[0][0] > 1.0) { rot_matrix[0][0] = 1.0; } else if (rot_matrix[0][0] < -1.0) { rot_matrix[0][0] = -1.0; } opt_angle = (-1.0)*acos(rot_matrix[0][0])*180.0/M_PI; if (rot_matrix[0][1] < 0.0) opt_angle = (-1.0)*opt_angle; free_square_matrix(RtR, 3); sfree(ref_s_1); sfree(act_s_1); for (i=0; i<3; i++) sfree(eigvec[i]); sfree(eigvec); return (real) opt_angle; } static real flex_fit_angle(t_rotgrp *rotg) { int i; rvec *fitcoords=NULL; rvec center; real fitangle; rvec coord; real scal; gmx_enfrotgrp_t erg; erg=rotg->enfrotgrp; get_center(erg->xc, erg->mc_sorted, rotg->nat, center); if (rotg->eFittype == erotgFitNORM) { for (i=0; i<rotg->nat; i++) { rvec_sub(erg->xc[i], center, coord); scal = erg->xc_ref_length[erg->xc_sortind[i]] / norm(coord); svmul(scal, coord, erg->xc_norm[i]); } fitcoords = erg->xc_norm; } else { fitcoords = erg->xc; } fitangle = -opt_angle_analytic(erg->xc_ref_sorted, fitcoords, erg->mc_sorted, rotg->nat, erg->xc_ref_center, center, rotg->vec); return fitangle; } static void flex_fit_angle_perslab( int g, t_rotgrp *rotg, double t, real degangle, FILE *fp) { int i,l,n,islab,ind; rvec curr_x, ref_x; rvec act_center; rvec ref_center; real fitangle; t_gmx_slabdata *sd; gmx_enfrotgrp_t erg; real OOm_av; real m_rel; erg=rotg->enfrotgrp; OOm_av = erg->invmass*rotg->nat; for (n = erg->slab_first; n <= erg->slab_last; n++) { islab = n - erg->slab_first; sd = &(rotg->enfrotgrp->slab_data[islab]); sd->nat = erg->lastatom[islab]-erg->firstatom[islab]+1; ind = 0; for (l=erg->firstatom[islab]; l<=erg->lastatom[islab]; l++) { copy_rvec(erg->xc[l], curr_x); copy_rvec(erg->xc_ref_sorted[l], ref_x); copy_rvec(curr_x, sd->x[ind]); copy_rvec(ref_x , sd->ref[ind]); m_rel = erg->mc_sorted[l]*OOm_av; sd->weight[ind] = gaussian_weight(curr_x, rotg, n) * m_rel; ind++; } } fprintf(fp, "%12.3e%6d%12.3f", t, g, degangle); #define SLAB_MIN_ATOMS 4 for (n = erg->slab_first; n <= erg->slab_last; n++) { islab = n - erg->slab_first; sd = &(rotg->enfrotgrp->slab_data[islab]); if (sd->nat >= SLAB_MIN_ATOMS) { get_center(sd->ref, sd->weight, sd->nat, ref_center); get_center(sd->x , sd->weight, sd->nat, act_center); if (rotg->eFittype == erotgFitNORM) { for (i=0; i<sd->nat;i++) { rvec_dec(sd->ref[i], ref_center); rvec_dec(sd->x[i] , act_center); svmul( norm(sd->ref[i])/norm(sd->x[i]), sd->x[i], sd->x[i] ); } clear_rvec(ref_center); clear_rvec(act_center); } fitangle = -opt_angle_analytic(sd->ref, sd->x, sd->weight, sd->nat, ref_center, act_center, rotg->vec); fprintf(fp, "%6d%6d%12.3f", n, sd->nat, fitangle); } } fprintf(fp , "\n"); #undef SLAB_MIN_ATOMS } static gmx_inline void shift_single_coord(matrix box, rvec x, const ivec is) { int tx,ty,tz; tx=is[XX]; ty=is[YY]; tz=is[ZZ]; if(TRICLINIC(box)) { x[XX] += tx*box[XX][XX]+ty*box[YY][XX]+tz*box[ZZ][XX]; x[YY] += ty*box[YY][YY]+tz*box[ZZ][YY]; x[ZZ] += tz*box[ZZ][ZZ]; } else { x[XX] += tx*box[XX][XX]; x[YY] += ty*box[YY][YY]; x[ZZ] += tz*box[ZZ][ZZ]; } } #define round(a) (int)(a+0.5) static gmx_inline int get_homeslab( rvec curr_x, rvec rotvec, real slabdist) { real dist; dist = iprod(rotvec, curr_x); return round(dist / slabdist); } static int get_single_atom_gaussians( rvec curr_x, t_rotgrp *rotg) { int slab, homeslab; real g; int count = 0; gmx_enfrotgrp_t erg; erg=rotg->enfrotgrp; homeslab = get_homeslab(curr_x, rotg->vec, rotg->slab_dist); g = gaussian_weight(curr_x, rotg, homeslab); erg->gn_atom[count] = g; erg->gn_slabind[count] = homeslab; count++; slab = homeslab; while (g > rotg->min_gaussian) { slab++; g = gaussian_weight(curr_x, rotg, slab); erg->gn_slabind[count]=slab; erg->gn_atom[count]=g; count++; } count--; slab = homeslab; do { slab--; g = gaussian_weight(curr_x, rotg, slab); erg->gn_slabind[count]=slab; erg->gn_atom[count]=g; count++; } while (g > rotg->min_gaussian); count--; return count; } static void flex2_precalc_inner_sum(t_rotgrp *rotg) { int i,n,islab; rvec xi; rvec xcn, ycn; real gaussian_xi; rvec yi0; rvec rin; real fac,fac2; rvec innersumvec; real OOpsii,OOpsiistar; real sin_rin; rvec s_in,tmpvec,tmpvec2; real mi,wi; real N_M; gmx_enfrotgrp_t erg; erg=rotg->enfrotgrp; N_M = rotg->nat * erg->invmass; for (n=erg->slab_first; n <= erg->slab_last; n++) { islab = n - erg->slab_first; copy_rvec(erg->slab_center[islab], xcn); copy_rvec(erg->slab_center_ref[islab+erg->slab_buffer], ycn); clear_rvec(innersumvec); for (i = erg->firstatom[islab]; i <= erg->lastatom[islab]; i++) { copy_rvec(erg->xc[i],xi); gaussian_xi = gaussian_weight(xi,rotg,n); mi = erg->mc_sorted[i]; wi = N_M*mi; copy_rvec(erg->xc_ref_sorted[i],yi0); rvec_sub(yi0, ycn, tmpvec2); mvmul(erg->rotmat, tmpvec2, rin); rvec_sub(xi, xcn, tmpvec2); cprod(rotg->vec, tmpvec2, tmpvec); OOpsiistar = norm2(tmpvec)+rotg->eps; OOpsii = norm(tmpvec); unitv(tmpvec, s_in); sin_rin=iprod(s_in,rin); fac = OOpsii/OOpsiistar; svmul(fac, rin, tmpvec); fac2 = fac*fac*OOpsii; svmul(fac2*sin_rin, s_in, tmpvec2); rvec_dec(tmpvec, tmpvec2); svmul(wi*gaussian_xi*sin_rin, tmpvec, tmpvec2); rvec_inc(innersumvec,tmpvec2); } copy_rvec(innersumvec, erg->slab_innersumvec[islab]); } } static void flex_precalc_inner_sum(t_rotgrp *rotg) { int i,n,islab; rvec xi; rvec xcn, ycn; rvec qin,rin; real bin; rvec tmpvec; rvec innersumvec; real gaussian_xi; real mi,wi; real N_M; gmx_enfrotgrp_t erg; erg=rotg->enfrotgrp; N_M = rotg->nat * erg->invmass; for (n=erg->slab_first; n <= erg->slab_last; n++) { islab = n - erg->slab_first; copy_rvec(erg->slab_center[islab], xcn); copy_rvec(erg->slab_center_ref[islab+erg->slab_buffer], ycn); clear_rvec(innersumvec); for (i=erg->firstatom[islab]; i<=erg->lastatom[islab]; i++) { copy_rvec(erg->xc[i],xi); gaussian_xi = gaussian_weight(xi,rotg,n); mi = erg->mc_sorted[i]; wi = N_M*mi; rvec_sub(erg->xc_ref_sorted[i], ycn, tmpvec); mvmul(erg->rotmat, tmpvec, rin); cprod(rotg->vec, rin, tmpvec); unitv(tmpvec, qin); rvec_sub(xi, xcn, tmpvec); bin = iprod(qin, tmpvec); svmul(wi*gaussian_xi*bin, qin, tmpvec); rvec_add(innersumvec, tmpvec, innersumvec); } copy_rvec(innersumvec, erg->slab_innersumvec[islab]); } } static real do_flex2_lowlevel( t_rotgrp *rotg, real sigma, rvec x[], gmx_bool bOutstepRot, gmx_bool bOutstepSlab, matrix box) { int count,ic,ii,j,m,n,islab,iigrp,ifit; rvec xj; rvec yj0; rvec xcn, ycn; real V; real gaussian_xj; real beta; real numerator,fit_numerator; rvec rjn,fit_rjn; real fac,fac2; real OOpsij,OOpsijstar; real OOsigma2; real sjn_rjn; real betasigpsi; rvec sjn,tmpvec,tmpvec2,yj0_ycn; rvec sum1vec_part,sum1vec,sum2vec_part,sum2vec,sum3vec,sum4vec,innersumvec; real sum3,sum4; gmx_enfrotgrp_t erg; real mj,wj; real N_M; real Wjn; gmx_bool bCalcPotFit; rvec slab_force; rvec slab_sum1vec_part; real slab_sum3part,slab_sum4part; rvec slab_sum1vec, slab_sum2vec, slab_sum3vec, slab_sum4vec; erg=rotg->enfrotgrp; flex2_precalc_inner_sum(rotg); bCalcPotFit = (bOutstepRot || bOutstepSlab) && (erotgFitPOT==rotg->eFittype); N_M = rotg->nat * erg->invmass; V = 0.0; OOsigma2 = 1.0 / (sigma*sigma); for (j=0; j<erg->nat_loc; j++) { ii = erg->ind_loc[j]; iigrp = erg->xc_ref_ind[j]; mj = erg->mc[iigrp]; wj = N_M*mj; rvec_sub(x[ii], erg->xc_center, xj); shift_single_coord(box, xj, erg->xc_shifts[iigrp]); count = get_single_atom_gaussians(xj, rotg); clear_rvec(sum1vec_part); clear_rvec(sum2vec_part); sum3 = 0.0; sum4 = 0.0; for (ic=0; ic < count; ic++) { n = erg->gn_slabind[ic]; gaussian_xj = erg->gn_atom[ic]; islab = n - erg->slab_first; copy_rvec(rotg->x_ref[iigrp], yj0); beta = calc_beta(xj, rotg,n); copy_rvec(erg->slab_center[islab], xcn); copy_rvec(erg->slab_center_ref[islab+erg->slab_buffer], ycn); rvec_sub(yj0, ycn, yj0_ycn); mvmul(erg->rotmat, yj0_ycn, rjn); rvec_sub(xj, xcn, tmpvec2); cprod(rotg->vec, tmpvec2, tmpvec); OOpsijstar = norm2(tmpvec)+rotg->eps; numerator = sqr(iprod(tmpvec, rjn)); V += 0.5*rotg->k*wj*gaussian_xj*numerator/OOpsijstar; if (bCalcPotFit) { for (ifit = 0; ifit < rotg->PotAngle_nstep; ifit++) { mvmul(erg->PotAngleFit->rotmat[ifit], yj0_ycn, fit_rjn); fit_numerator = sqr(iprod(tmpvec, fit_rjn)); erg->PotAngleFit->V[ifit] += 0.5*rotg->k*wj*gaussian_xj*fit_numerator/OOpsijstar; } } OOpsij = norm(tmpvec); unitv(tmpvec, sjn); sjn_rjn=iprod(sjn,rjn); fac = OOpsij/OOpsijstar; svmul(fac, rjn, tmpvec); fac2 = fac*fac*OOpsij; svmul(fac2*sjn_rjn, sjn, tmpvec2); rvec_dec(tmpvec, tmpvec2); fac2 = wj*gaussian_xj; svmul(fac2*sjn_rjn, tmpvec, slab_sum1vec_part); rvec_inc(sum1vec_part, slab_sum1vec_part); betasigpsi = beta*OOsigma2*OOpsij; slab_sum4part = fac2*betasigpsi*fac*sjn_rjn*sjn_rjn; sum4 += slab_sum4part; Wjn = gaussian_xj*mj/erg->slab_weights[islab]; copy_rvec(erg->slab_innersumvec[islab], innersumvec); svmul(Wjn, innersumvec, innersumvec); rvec_inc(sum2vec_part, innersumvec); slab_sum3part = betasigpsi * iprod(sjn, innersumvec); sum3 += slab_sum3part; if (bOutstepRot) { cprod(slab_sum1vec_part, rotg->vec, slab_sum1vec); cprod(innersumvec, rotg->vec, slab_sum2vec); svmul(slab_sum3part, rotg->vec, slab_sum3vec); svmul(slab_sum4part, rotg->vec, slab_sum4vec); for (m=0; m<DIM; m++) slab_force[m] = rotg->k * (-slab_sum1vec[m] + slab_sum2vec[m] - slab_sum3vec[m] + 0.5*slab_sum4vec[m]); erg->slab_torque_v[islab] += torque(rotg->vec, slab_force, xj, xcn); } } cprod(sum1vec_part, rotg->vec, sum1vec); cprod(sum2vec_part, rotg->vec, sum2vec); svmul(sum3, rotg->vec, sum3vec); svmul(sum4, rotg->vec, sum4vec); for (m=0; m<DIM; m++) erg->f_rot_loc[j][m] = rotg->k * (-sum1vec[m] + sum2vec[m] - sum3vec[m] + 0.5*sum4vec[m]); #ifdef SUM_PARTS fprintf(stderr, "sum1: %15.8f %15.8f %15.8f\n", -rotg->k*sum1vec[XX], -rotg->k*sum1vec[YY], -rotg->k*sum1vec[ZZ]); fprintf(stderr, "sum2: %15.8f %15.8f %15.8f\n", rotg->k*sum2vec[XX], rotg->k*sum2vec[YY], rotg->k*sum2vec[ZZ]); fprintf(stderr, "sum3: %15.8f %15.8f %15.8f\n", -rotg->k*sum3vec[XX], -rotg->k*sum3vec[YY], -rotg->k*sum3vec[ZZ]); fprintf(stderr, "sum4: %15.8f %15.8f %15.8f\n", 0.5*rotg->k*sum4vec[XX], 0.5*rotg->k*sum4vec[YY], 0.5*rotg->k*sum4vec[ZZ]); #endif PRINT_FORCE_J } return V; } static real do_flex_lowlevel( t_rotgrp *rotg, real sigma, rvec x[], gmx_bool bOutstepRot, gmx_bool bOutstepSlab, matrix box) { int count,ic,ifit,ii,j,m,n,islab,iigrp; rvec xj,yj0; rvec xcn, ycn; rvec yj0_ycn; rvec xj_xcn; rvec qjn,fit_qjn; rvec sum_n1,sum_n2; rvec innersumvec; rvec s_n; rvec force_n; rvec force_n1,force_n2; rvec tmpvec,tmpvec2,tmp_f; real V; real OOsigma2; real beta; real bjn, fit_bjn; real gaussian_xj; real betan_xj_sigma2; real mj,wj; real N_M; gmx_enfrotgrp_t erg; gmx_bool bCalcPotFit; erg=rotg->enfrotgrp; flex_precalc_inner_sum(rotg); bCalcPotFit = (bOutstepRot || bOutstepSlab) && (erotgFitPOT==rotg->eFittype); OOsigma2 = 1.0/(sigma*sigma); N_M = rotg->nat * erg->invmass; V = 0.0; for (j=0; j<erg->nat_loc; j++) { ii = erg->ind_loc[j]; iigrp = erg->xc_ref_ind[j]; mj = erg->mc[iigrp]; wj = N_M*mj; rvec_sub(x[ii], erg->xc_center, xj); shift_single_coord(box, xj, erg->xc_shifts[iigrp]); count = get_single_atom_gaussians(xj, rotg); clear_rvec(sum_n1); clear_rvec(sum_n2); for (ic=0; ic < count; ic++) { n = erg->gn_slabind[ic]; gaussian_xj = erg->gn_atom[ic]; islab = n - erg->slab_first; copy_rvec(rotg->x_ref[iigrp], yj0); beta = calc_beta(xj, rotg, n); copy_rvec(erg->slab_center[islab], xcn); copy_rvec(erg->slab_center_ref[islab+erg->slab_buffer], ycn); rvec_sub(yj0, ycn, yj0_ycn); mvmul(erg->rotmat, yj0_ycn, tmpvec2); rvec_sub(xj, xcn, xj_xcn); cprod(rotg->vec, tmpvec2, tmpvec); unitv(tmpvec,qjn); bjn = iprod(qjn, xj_xcn); V += 0.5*rotg->k*wj*gaussian_xj*sqr(bjn); if (bCalcPotFit) { for (ifit = 0; ifit < rotg->PotAngle_nstep; ifit++) { mvmul(erg->PotAngleFit->rotmat[ifit], yj0_ycn, tmpvec2); cprod(rotg->vec, tmpvec2, tmpvec); unitv(tmpvec,fit_qjn); fit_bjn = iprod(fit_qjn, xj_xcn); erg->PotAngleFit->V[ifit] += 0.5*rotg->k*wj*gaussian_xj*sqr(fit_bjn); } } betan_xj_sigma2 = beta*OOsigma2; svmul(bjn*0.5*betan_xj_sigma2, rotg->vec, tmpvec2); rvec_sub(qjn,tmpvec2,tmpvec); svmul(gaussian_xj*bjn,tmpvec,tmpvec2); rvec_inc(sum_n1,tmpvec2); copy_rvec(erg->slab_innersumvec[islab], s_n); svmul(betan_xj_sigma2*iprod(s_n, xj_xcn), rotg->vec, tmpvec); rvec_sub(s_n, tmpvec, innersumvec); svmul(gaussian_xj/erg->slab_weights[islab], innersumvec, innersumvec); rvec_add(sum_n2, innersumvec, sum_n2); if (bOutstepRot) { svmul(-rotg->k*wj, tmpvec2 , force_n1); svmul( rotg->k*mj, innersumvec, force_n2); rvec_add(force_n1, force_n2, force_n); erg->slab_torque_v[islab] += torque(rotg->vec, force_n, xj, xcn); } } svmul(wj, sum_n1, sum_n1); svmul(mj, sum_n2, sum_n2); rvec_sub(sum_n2,sum_n1,tmp_f); for(m=0; m<DIM; m++) erg->f_rot_loc[j][m] = rotg->k*tmp_f[m]; PRINT_FORCE_J } return V; } #ifdef PRINT_COORDS static void print_coordinates(t_rotgrp *rotg, rvec x[], matrix box, int step) { int i; static FILE *fp; static char buf[STRLEN]; static gmx_bool bFirst=1; if (bFirst) { sprintf(buf, "coords%d.txt", cr->nodeid); fp = fopen(buf, "w"); bFirst = 0; } fprintf(fp, "\nStep %d\n", step); fprintf(fp, "box: %f %f %f %f %f %f %f %f %f\n", box[XX][XX], box[XX][YY], box[XX][ZZ], box[YY][XX], box[YY][YY], box[YY][ZZ], box[ZZ][XX], box[ZZ][ZZ], box[ZZ][ZZ]); for (i=0; i<rotg->nat; i++) { fprintf(fp, "%4d %f %f %f\n", i, erg->xc[i][XX], erg->xc[i][YY], erg->xc[i][ZZ]); } fflush(fp); } #endif static int projection_compare(const void *a, const void *b) { sort_along_vec_t *xca, *xcb; xca = (sort_along_vec_t *)a; xcb = (sort_along_vec_t *)b; if (xca->xcproj < xcb->xcproj) return -1; else if (xca->xcproj > xcb->xcproj) return 1; else return 0; } static void sort_collective_coordinates( t_rotgrp *rotg, sort_along_vec_t *data) { int i; gmx_enfrotgrp_t erg; erg=rotg->enfrotgrp; for (i=0; i<rotg->nat; i++) { data[i].xcproj = iprod(erg->xc[i], rotg->vec); data[i].m = erg->mc[i]; data[i].ind = i; copy_rvec(erg->xc[i] , data[i].x ); copy_rvec(rotg->x_ref[i], data[i].x_ref); } gmx_qsort(data, rotg->nat, sizeof(sort_along_vec_t), projection_compare); for (i=0; i<rotg->nat; i++) { copy_rvec(data[i].x , erg->xc[i] ); copy_rvec(data[i].x_ref, erg->xc_ref_sorted[i]); erg->mc_sorted[i] = data[i].m; erg->xc_sortind[i] = data[i].ind; } } static void get_firstlast_atom_per_slab(t_rotgrp *rotg) { int i,islab,n; real beta; gmx_enfrotgrp_t erg; erg=rotg->enfrotgrp; n = erg->slab_first; i = 0; do { do { beta = calc_beta(erg->xc[i], rotg, n); i++; } while ((beta < -erg->max_beta) && (i < rotg->nat)); i--; islab = n - erg->slab_first; erg->firstatom[islab] = i; n++; } while (n <= erg->slab_last); n = erg->slab_last; i = rotg->nat-1; do { do { beta = calc_beta(erg->xc[i], rotg, n); i--; } while ((beta > erg->max_beta) && (i > -1)); i++; islab = n - erg->slab_first; erg->lastatom[islab] = i; n--; } while (n >= erg->slab_first); } static gmx_inline int get_first_slab( t_rotgrp *rotg, real max_beta, rvec firstatom) { return ceil((iprod(firstatom, rotg->vec) - max_beta)/rotg->slab_dist); } static gmx_inline int get_last_slab( t_rotgrp *rotg, real max_beta, rvec lastatom) { return floor((iprod(lastatom, rotg->vec) + max_beta)/rotg->slab_dist); } static void get_firstlast_slab_check( t_rotgrp *rotg, t_gmx_enfrotgrp *erg, rvec firstatom, rvec lastatom, int g) { erg->slab_first = get_first_slab(rotg, erg->max_beta, firstatom); erg->slab_last = get_last_slab(rotg, erg->max_beta, lastatom); if (erg->slab_first < erg->slab_first_ref) gmx_fatal(FARGS, "%s No reference data for first slab (n=%d), unable to proceed.", RotStr, erg->slab_first); if (erg->slab_last > erg->slab_last_ref) gmx_fatal(FARGS, "%s No reference data for last slab (n=%d), unable to proceed.", RotStr, erg->slab_last); } static void do_flexible( gmx_bool bMaster, gmx_enfrot_t enfrot, t_rotgrp *rotg, int g, rvec x[], matrix box, double t, gmx_large_int_t step, gmx_bool bOutstepRot, gmx_bool bOutstepSlab) { int l,nslabs; real sigma; gmx_enfrotgrp_t erg; erg=rotg->enfrotgrp; sigma = 0.7*rotg->slab_dist; sort_collective_coordinates(rotg, enfrot->data); get_firstlast_slab_check(rotg, erg, erg->xc[0], erg->xc[rotg->nat-1], g); get_firstlast_atom_per_slab(rotg); get_slab_centers(rotg,erg->xc,erg->mc_sorted,g,t,enfrot->out_slabs,bOutstepSlab,FALSE); nslabs = erg->slab_last - erg->slab_first + 1; for (l=0; l<nslabs; l++) erg->slab_torque_v[l] = 0.0; if (rotg->eType == erotgFLEX || rotg->eType == erotgFLEXT) erg->V = do_flex_lowlevel(rotg, sigma, x, bOutstepRot, bOutstepSlab, box); else if (rotg->eType == erotgFLEX2 || rotg->eType == erotgFLEX2T) erg->V = do_flex2_lowlevel(rotg, sigma, x, bOutstepRot, bOutstepSlab, box); else gmx_fatal(FARGS, "Unknown flexible rotation type"); if ( bMaster && (erotgFitPOT != rotg->eFittype) ) { if (bOutstepRot) { erg->angle_v = flex_fit_angle(rotg); } if (bOutstepSlab) { flex_fit_angle_perslab(g, rotg, t, erg->degangle, enfrot->out_angles); } } erg->torque_v = 0.0; for (l=0; l<nslabs; l++) erg->torque_v += erg->slab_torque_v[l]; } static void angle(t_rotgrp *rotg, rvec x_act, rvec x_ref, real *alpha, real *weight) { rvec xp, xrp; rvec dum; svmul(iprod(rotg->vec, x_ref), rotg->vec, dum); rvec_sub(x_ref, dum, xrp); svmul(iprod(rotg->vec, x_act), rotg->vec, dum); rvec_sub(x_act, dum, xp); cprod(xp, xrp, dum); if (iprod(rotg->vec, dum) >= 0) *alpha = -gmx_angle(xrp, xp); else *alpha = +gmx_angle(xrp, xp); *weight = norm(xp); } static gmx_inline void project_onto_plane(rvec dr, const rvec v) { rvec tmp; svmul(iprod(dr,v),v,tmp); rvec_dec(dr, tmp); } static void do_fixed( t_rotgrp *rotg, rvec x[], matrix box, double t, gmx_large_int_t step, gmx_bool bOutstepRot, gmx_bool bOutstepSlab) { int ifit,j,jj,m; rvec dr; rvec tmp_f; real alpha; real weight; gmx_enfrotgrp_t erg; rvec xi_xc; gmx_bool bCalcPotFit; rvec fit_xr_loc; real wi; real N_M; real k_wi; gmx_bool bProject; erg=rotg->enfrotgrp; bProject = (rotg->eType==erotgPM) || (rotg->eType==erotgPMPF); bCalcPotFit = (bOutstepRot || bOutstepSlab) && (erotgFitPOT==rotg->eFittype); N_M = rotg->nat * erg->invmass; for (j=0; j<erg->nat_loc; j++) { rvec_sub(erg->x_loc_pbc[j], erg->xc_center, xi_xc); rvec_sub(erg->xr_loc[j], xi_xc, dr); if (bProject) project_onto_plane(dr, rotg->vec); wi = N_M*erg->m_loc[j]; k_wi = rotg->k*wi; for (m=0; m<DIM; m++) { tmp_f[m] = k_wi*dr[m]; erg->f_rot_loc[j][m] = tmp_f[m]; erg->V += 0.5*k_wi*sqr(dr[m]); } if (bCalcPotFit) { for (ifit = 0; ifit < rotg->PotAngle_nstep; ifit++) { jj = erg->xc_ref_ind[j]; mvmul(erg->PotAngleFit->rotmat[ifit], rotg->x_ref[jj], fit_xr_loc); rvec_sub(fit_xr_loc, xi_xc, dr); if (bProject) project_onto_plane(dr, rotg->vec); erg->PotAngleFit->V[ifit] += 0.5*k_wi*norm2(dr); } } if (bOutstepRot) { erg->torque_v += torque(rotg->vec, tmp_f, erg->x_loc_pbc[j], erg->xc_center); angle(rotg, xi_xc, erg->xr_loc[j], &alpha, &weight); erg->angle_v += alpha * weight; erg->weight_v += weight; } PRINT_FORCE_J } } static void do_radial_motion( t_rotgrp *rotg, rvec x[], matrix box, double t, gmx_large_int_t step, gmx_bool bOutstepRot, gmx_bool bOutstepSlab) { int j,jj,ifit; rvec tmp_f; real alpha; real weight; gmx_enfrotgrp_t erg; rvec xj_u; rvec tmpvec,fit_tmpvec; real fac,fac2,sum=0.0; rvec pj; gmx_bool bCalcPotFit; real wj; real N_M; erg=rotg->enfrotgrp; bCalcPotFit = (bOutstepRot || bOutstepSlab) && (erotgFitPOT==rotg->eFittype); N_M = rotg->nat * erg->invmass; for (j=0; j<erg->nat_loc; j++) { rvec_sub(erg->x_loc_pbc[j], erg->xc_center, xj_u); cprod(rotg->vec, erg->xr_loc[j], tmpvec); unitv(tmpvec, pj); fac = iprod(pj, xj_u); fac2 = fac*fac; wj = N_M*erg->m_loc[j]; svmul(-rotg->k*wj*fac, pj, tmp_f); copy_rvec(tmp_f, erg->f_rot_loc[j]); sum += wj*fac2; if (bCalcPotFit) { for (ifit = 0; ifit < rotg->PotAngle_nstep; ifit++) { jj = erg->xc_ref_ind[j]; mvmul(erg->PotAngleFit->rotmat[ifit], rotg->x_ref[jj], fit_tmpvec); cprod(rotg->vec, fit_tmpvec, tmpvec); unitv(tmpvec, pj); fac = iprod(pj, xj_u); fac2 = fac*fac; erg->PotAngleFit->V[ifit] += 0.5*rotg->k*wj*fac2; } } if (bOutstepRot) { erg->torque_v += torque(rotg->vec, tmp_f, erg->x_loc_pbc[j], erg->xc_center); angle(rotg, xj_u, erg->xr_loc[j], &alpha, &weight); erg->angle_v += alpha * weight; erg->weight_v += weight; } PRINT_FORCE_J } erg->V = 0.5*rotg->k*sum; } static void do_radial_motion_pf( t_rotgrp *rotg, rvec x[], matrix box, double t, gmx_large_int_t step, gmx_bool bOutstepRot, gmx_bool bOutstepSlab) { int i,ii,iigrp,ifit,j; rvec xj; rvec xj_xc; rvec yj0_yc0; rvec tmp_f; real alpha; real weight; gmx_enfrotgrp_t erg; rvec tmpvec, tmpvec2; rvec innersumvec; rvec innersumveckM; real fac,fac2,V=0.0; rvec qi,qj; gmx_bool bCalcPotFit; real mj,wi,wj; real N_M; erg=rotg->enfrotgrp; bCalcPotFit = (bOutstepRot || bOutstepSlab) && (erotgFitPOT==rotg->eFittype); N_M = rotg->nat * erg->invmass; get_center(erg->xc, erg->mc, rotg->nat, erg->xc_center); clear_rvec(innersumvec); for (i=0; i < rotg->nat; i++) { wi = N_M*erg->mc[i]; mvmul(erg->rotmat, rotg->x_ref[i], tmpvec); cprod(rotg->vec, tmpvec, tmpvec2); unitv(tmpvec2, qi); rvec_sub(erg->xc[i], erg->xc_center, tmpvec); svmul(wi*iprod(qi, tmpvec), qi, tmpvec2); rvec_inc(innersumvec, tmpvec2); } svmul(rotg->k*erg->invmass, innersumvec, innersumveckM); for (j=0; j<erg->nat_loc; j++) { ii = erg->ind_loc[j]; iigrp = erg->xc_ref_ind[j]; mj = erg->mc[iigrp]; wj = N_M*mj; copy_rvec(x[ii], xj); shift_single_coord(box, xj, erg->xc_shifts[iigrp]); copy_rvec(rotg->x_ref[iigrp], yj0_yc0); mvmul(erg->rotmat, yj0_yc0, tmpvec2); cprod(rotg->vec, tmpvec2, tmpvec); unitv(tmpvec, qj); rvec_sub(xj, erg->xc_center, xj_xc); fac = iprod(qj, xj_xc); fac2 = fac*fac; svmul(-rotg->k*wj*fac, qj, tmp_f); svmul(mj, innersumveckM, tmpvec); rvec_inc(tmp_f, tmpvec); copy_rvec(tmp_f, erg->f_rot_loc[j]); V += wj*fac2; if (bCalcPotFit) { for (ifit = 0; ifit < rotg->PotAngle_nstep; ifit++) { mvmul(erg->PotAngleFit->rotmat[ifit], yj0_yc0, tmpvec2); cprod(rotg->vec, tmpvec2, tmpvec); unitv(tmpvec, qj); fac = iprod(qj, xj_xc); fac2 = fac*fac; erg->PotAngleFit->V[ifit] += 0.5*rotg->k*wj*fac2; } } if (bOutstepRot) { erg->torque_v += torque(rotg->vec, tmp_f, xj, erg->xc_center); angle(rotg, xj_xc, yj0_yc0, &alpha, &weight); erg->angle_v += alpha * weight; erg->weight_v += weight; } PRINT_FORCE_J } erg->V = 0.5*rotg->k*V; } static void radial_motion2_precalc_inner_sum(t_rotgrp *rotg, rvec innersumvec) { int i; gmx_enfrotgrp_t erg; rvec xi_xc; rvec tmpvec,tmpvec2; real fac,fac2; rvec ri,si; real siri; rvec v_xi_xc; real psii,psiistar; real wi; real N_M; rvec sumvec; erg=rotg->enfrotgrp; N_M = rotg->nat * erg->invmass; clear_rvec(sumvec); for (i=0; i<rotg->nat; i++) { wi = N_M*erg->mc[i]; rvec_sub(erg->xc[i], erg->xc_center, xi_xc); mvmul(erg->rotmat, rotg->x_ref[i], ri); cprod(rotg->vec, xi_xc, v_xi_xc); fac = norm2(v_xi_xc); psiistar = 1.0/(fac + rotg->eps); psii = gmx_invsqrt(fac); svmul(psii, v_xi_xc, si); fac = iprod(v_xi_xc, ri); fac2 = fac*fac; siri = iprod(si, ri); svmul(psiistar/psii, ri, tmpvec); svmul(psiistar*psiistar/(psii*psii*psii) * siri, si, tmpvec2); rvec_dec(tmpvec, tmpvec2); cprod(tmpvec, rotg->vec, tmpvec2); svmul(wi*siri, tmpvec2, tmpvec); rvec_inc(sumvec, tmpvec); } svmul(rotg->k*erg->invmass, sumvec, innersumvec); } static void do_radial_motion2( t_rotgrp *rotg, rvec x[], matrix box, double t, gmx_large_int_t step, gmx_bool bOutstepRot, gmx_bool bOutstepSlab) { int ii,iigrp,ifit,j; rvec xj; real alpha; real weight; gmx_enfrotgrp_t erg; rvec xj_u; rvec yj0_yc0; rvec tmpvec,tmpvec2; real fac,fit_fac,fac2,Vpart=0.0; rvec rj,fit_rj,sj; real sjrj; rvec v_xj_u; real psij,psijstar; real mj,wj; real N_M; gmx_bool bPF; rvec innersumvec; gmx_bool bCalcPotFit; erg=rotg->enfrotgrp; bPF = rotg->eType==erotgRM2PF; bCalcPotFit = (bOutstepRot || bOutstepSlab) && (erotgFitPOT==rotg->eFittype); clear_rvec(yj0_yc0); clear_rvec(innersumvec); if (bPF) { get_center(erg->xc, erg->mc, rotg->nat, erg->xc_center); radial_motion2_precalc_inner_sum(rotg,innersumvec); } N_M = rotg->nat * erg->invmass; for (j=0; j<erg->nat_loc; j++) { if (bPF) { ii = erg->ind_loc[j]; iigrp = erg->xc_ref_ind[j]; mj = erg->mc[iigrp]; copy_rvec(x[ii], xj); shift_single_coord(box, xj, erg->xc_shifts[iigrp]); copy_rvec(rotg->x_ref[iigrp], yj0_yc0); mvmul(erg->rotmat, yj0_yc0, rj); } else { mj = erg->m_loc[j]; copy_rvec(erg->x_loc_pbc[j], xj); copy_rvec(erg->xr_loc[j], rj); } wj = N_M*mj; rvec_sub(xj, erg->xc_center, xj_u); cprod(rotg->vec, xj_u, v_xj_u); fac = norm2(v_xj_u); psijstar = 1.0/(fac + rotg->eps); psij = gmx_invsqrt(fac); svmul(psij, v_xj_u, sj); fac = iprod(v_xj_u, rj); fac2 = fac*fac; sjrj = iprod(sj, rj); svmul(psijstar/psij, rj, tmpvec); svmul(psijstar*psijstar/(psij*psij*psij) * sjrj, sj, tmpvec2); rvec_dec(tmpvec, tmpvec2); cprod(tmpvec, rotg->vec, tmpvec2); svmul(-rotg->k*wj*sjrj, tmpvec2, tmpvec); svmul(mj, innersumvec, tmpvec2); rvec_add(tmpvec2, tmpvec, erg->f_rot_loc[j]); Vpart += wj*psijstar*fac2; if (bCalcPotFit) { for (ifit = 0; ifit < rotg->PotAngle_nstep; ifit++) { if (bPF) { mvmul(erg->PotAngleFit->rotmat[ifit], yj0_yc0, fit_rj); } else { iigrp = erg->xc_ref_ind[j]; mvmul(erg->PotAngleFit->rotmat[ifit], rotg->x_ref[iigrp], fit_rj); } fit_fac = iprod(v_xj_u, fit_rj); erg->PotAngleFit->V[ifit] += 0.5*rotg->k*wj*psijstar*fit_fac*fit_fac; } } if (bOutstepRot) { erg->torque_v += torque(rotg->vec, erg->f_rot_loc[j], xj, erg->xc_center); angle(rotg, xj_u, rj, &alpha, &weight); erg->angle_v += alpha * weight; erg->weight_v += weight; } PRINT_FORCE_J } erg->V = 0.5*rotg->k*Vpart; } static void get_firstlast_atom_ref( t_rotgrp *rotg, int *firstindex, int *lastindex) { gmx_enfrotgrp_t erg; int i; real xcproj; real minproj, maxproj; erg=rotg->enfrotgrp; minproj = iprod(rotg->x_ref[0], rotg->vec); maxproj = minproj; *firstindex = 0; *lastindex = rotg->nat-1; for (i=0; i<rotg->nat; i++) { xcproj = iprod(rotg->x_ref[i], rotg->vec); if (xcproj < minproj) { minproj = xcproj; *firstindex = i; } if (xcproj > maxproj) { maxproj = xcproj; *lastindex = i; } } } static void allocate_slabs( t_rotgrp *rotg, FILE *fplog, int g, gmx_bool bVerbose) { gmx_enfrotgrp_t erg; int i, nslabs; erg=rotg->enfrotgrp; nslabs = erg->slab_last_ref - erg->slab_first_ref + 1; erg->nslabs_alloc = nslabs; if ( (NULL != fplog) && bVerbose ) fprintf(fplog, "%s allocating memory to store data for %d slabs (rotation group %d).\n", RotStr, nslabs,g); snew(erg->slab_center , nslabs); snew(erg->slab_center_ref , nslabs); snew(erg->slab_weights , nslabs); snew(erg->slab_torque_v , nslabs); snew(erg->slab_data , nslabs); snew(erg->gn_atom , nslabs); snew(erg->gn_slabind , nslabs); snew(erg->slab_innersumvec, nslabs); for (i=0; i<nslabs; i++) { snew(erg->slab_data[i].x , rotg->nat); snew(erg->slab_data[i].ref , rotg->nat); snew(erg->slab_data[i].weight, rotg->nat); } snew(erg->xc_ref_sorted, rotg->nat); snew(erg->xc_sortind , rotg->nat); snew(erg->firstatom , nslabs); snew(erg->lastatom , nslabs); } static void get_firstlast_slab_ref(t_rotgrp *rotg, real mc[], int ref_firstindex, int ref_lastindex) { gmx_enfrotgrp_t erg; int first,last,firststart; rvec dummy; erg=rotg->enfrotgrp; first = get_first_slab(rotg, erg->max_beta, rotg->x_ref[ref_firstindex]); last = get_last_slab( rotg, erg->max_beta, rotg->x_ref[ref_lastindex ]); firststart = first; while (get_slab_weight(first, rotg, rotg->x_ref, mc, &dummy) > WEIGHT_MIN) { first--; } erg->slab_first_ref = first+1; while (get_slab_weight(last, rotg, rotg->x_ref, mc, &dummy) > WEIGHT_MIN) { last++; } erg->slab_last_ref = last-1; erg->slab_buffer = firststart - erg->slab_first_ref; } static void init_rot_group(FILE *fplog,t_commrec *cr,int g,t_rotgrp *rotg, rvec *x,gmx_mtop_t *mtop,gmx_bool bVerbose,FILE *out_slabs, gmx_bool bOutputCenters) { int i,ii; rvec coord,*xdum; gmx_bool bFlex,bColl; t_atom *atom; gmx_enfrotgrp_t erg; int ref_firstindex, ref_lastindex; real mass,totalmass; real start=0.0; bFlex = ISFLEX(rotg); bColl = ISCOLL(rotg); erg=rotg->enfrotgrp; if (bColl) { snew(erg->xc , rotg->nat); snew(erg->xc_shifts , rotg->nat); snew(erg->xc_eshifts, rotg->nat); snew(erg->xc_old , rotg->nat); if (MASTER(cr)) { for (i=0; i<rotg->nat; i++) { ii = rotg->ind[i]; copy_rvec(x[ii], erg->xc_old[i]); } } #ifdef GMX_MPI if (PAR(cr)) gmx_bcast(rotg->nat*sizeof(erg->xc_old[0]),erg->xc_old, cr); #endif if (rotg->eFittype == erotgFitNORM) { snew(erg->xc_ref_length, rotg->nat); snew(erg->xc_norm , rotg->nat); } } else { snew(erg->xr_loc , rotg->nat); snew(erg->x_loc_pbc, rotg->nat); } snew(erg->f_rot_loc , rotg->nat); snew(erg->xc_ref_ind, rotg->nat); if (erotgFitPOT == rotg->eFittype) { snew(erg->PotAngleFit, 1); snew(erg->PotAngleFit->degangle, rotg->PotAngle_nstep); snew(erg->PotAngleFit->V , rotg->PotAngle_nstep); snew(erg->PotAngleFit->rotmat , rotg->PotAngle_nstep); start = -0.5 * (rotg->PotAngle_nstep - 1)*rotg->PotAngle_step; for (i = 0; i < rotg->PotAngle_nstep; i++) erg->PotAngleFit->degangle[i] = start + i*rotg->PotAngle_step; } else { erg->PotAngleFit = NULL; } if (!PAR(cr)) for (i=0; i<rotg->nat; i++) erg->xc_ref_ind[i] = i; snew(erg->mc, rotg->nat); if (bFlex) snew(erg->mc_sorted, rotg->nat); if (!bColl) snew(erg->m_loc, rotg->nat); totalmass=0.0; for (i=0; i<rotg->nat; i++) { if (rotg->bMassW) { gmx_mtop_atomnr_to_atom(mtop,rotg->ind[i],&atom); mass=atom->m; } else { mass=1.0; } erg->mc[i] = mass; totalmass += mass; } erg->invmass = 1.0/totalmass; if ((rotg->eType==erotgISO) || (rotg->eType==erotgPM) || (rotg->eType==erotgRM) || (rotg->eType==erotgRM2)) { copy_rvec(rotg->pivot, erg->xc_ref_center); copy_rvec(rotg->pivot, erg->xc_center ); } else { get_center(rotg->x_ref, erg->mc, rotg->nat, erg->xc_ref_center); if (MASTER(cr)) { snew(xdum, rotg->nat); for (i=0; i<rotg->nat; i++) { ii = rotg->ind[i]; copy_rvec(x[ii], xdum[i]); } get_center(xdum, erg->mc, rotg->nat, erg->xc_center); sfree(xdum); } #ifdef GMX_MPI if (PAR(cr)) gmx_bcast(sizeof(erg->xc_center), erg->xc_center, cr); #endif } if ( (rotg->eType != erotgFLEX) && (rotg->eType != erotgFLEX2) ) { for (i=0; i<rotg->nat; i++) rvec_dec(rotg->x_ref[i], erg->xc_ref_center); } if (bFlex) { erg->max_beta = calc_beta_max(rotg->min_gaussian, rotg->slab_dist); get_firstlast_atom_ref(rotg, &ref_firstindex, &ref_lastindex); get_firstlast_slab_ref(rotg, erg->mc, ref_firstindex, ref_lastindex); allocate_slabs(rotg, fplog, g, bVerbose); erg->slab_first = erg->slab_first_ref; erg->slab_last = erg->slab_last_ref; get_slab_centers(rotg,rotg->x_ref,erg->mc,g,-1,out_slabs,bOutputCenters,TRUE); if (rotg->eFittype == erotgFitNORM) { for (i=0; i<rotg->nat; i++) { rvec_sub(rotg->x_ref[i], erg->xc_ref_center, coord); erg->xc_ref_length[i] = norm(coord); } } } } extern void dd_make_local_rotation_groups(gmx_domdec_t *dd,t_rot *rot) { gmx_ga2la_t ga2la; int g; t_rotgrp *rotg; gmx_enfrotgrp_t erg; ga2la = dd->ga2la; for(g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; erg = rotg->enfrotgrp; dd_make_local_group_indices(ga2la,rotg->nat,rotg->ind, &erg->nat_loc,&erg->ind_loc,&erg->nalloc_loc,erg->xc_ref_ind); } } static int calc_mpi_bufsize(t_rot *rot) { int g; int count_group, count_total; t_rotgrp *rotg; gmx_enfrotgrp_t erg; count_total = 0; for (g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; erg = rotg->enfrotgrp; count_group = 4; if (ISFLEX(rotg)) count_group += erg->slab_last_ref - erg->slab_first_ref + 1; if (erotgFitPOT == rotg->eFittype) count_group += rotg->PotAngle_nstep; count_total += count_group; } return count_total; } extern void init_rot(FILE *fplog,t_inputrec *ir,int nfile,const t_filenm fnm[], t_commrec *cr, rvec *x, matrix box, gmx_mtop_t *mtop, const output_env_t oenv, gmx_bool bVerbose, unsigned long Flags) { t_rot *rot; t_rotgrp *rotg; int g; int nat_max=0; gmx_enfrot_t er; gmx_enfrotgrp_t erg; rvec *x_pbc=NULL; if ( (PAR(cr)) && !DOMAINDECOMP(cr) ) gmx_fatal(FARGS, "Enforced rotation is only implemented for domain decomposition!"); if ( MASTER(cr) && bVerbose) fprintf(stdout, "%s Initializing ...\n", RotStr); rot = ir->rot; snew(rot->enfrot, 1); er = rot->enfrot; er->Flags = Flags; if (er->Flags & MD_APPENDFILES) er->bOut = FALSE; else er->bOut = TRUE; if ( MASTER(cr) && er->bOut ) please_cite(fplog, "Kutzner2011"); if (er->Flags & MD_RERUN) { if (NULL != fplog) fprintf(fplog, "%s rerun - will write rotation output every available step.\n", RotStr); rot->nstrout = 1; rot->nstsout = 1; } er->out_slabs = NULL; if ( MASTER(cr) && HaveFlexibleGroups(rot) ) er->out_slabs = open_slab_out(opt2fn("-rs",nfile,fnm), rot, oenv); if (MASTER(cr)) { snew(x_pbc,mtop->natoms); m_rveccopy(mtop->natoms,x,x_pbc); do_pbc_first_mtop(NULL,ir->ePBC,box,mtop,x_pbc); } for (g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; if (NULL != fplog) fprintf(fplog,"%s group %d type '%s'\n", RotStr, g, erotg_names[rotg->eType]); if (rotg->nat > 0) { snew(rotg->enfrotgrp, 1); erg = rotg->enfrotgrp; nat_max=max(nat_max, rotg->nat); if (PAR(cr)) { erg->nat_loc = 0; erg->nalloc_loc = 0; erg->ind_loc = NULL; } else { erg->nat_loc = rotg->nat; erg->ind_loc = rotg->ind; } init_rot_group(fplog,cr,g,rotg,x_pbc,mtop,bVerbose,er->out_slabs, !(er->Flags & MD_APPENDFILES) ); } } er->bufsize = nat_max; snew(er->data, nat_max); snew(er->xbuf, nat_max); snew(er->mbuf, nat_max); if (PAR(cr)) { er->mpi_bufsize = calc_mpi_bufsize(rot) + 100; snew(er->mpi_inbuf , er->mpi_bufsize); snew(er->mpi_outbuf, er->mpi_bufsize); } else { er->mpi_bufsize = 0; er->mpi_inbuf = NULL; er->mpi_outbuf = NULL; } er->out_angles = NULL; er->out_rot = NULL; er->out_torque = NULL; if (MASTER(cr)) { er->out_rot = open_rot_out(opt2fn("-ro",nfile,fnm), rot, oenv); if (rot->nstsout > 0) { if ( HaveFlexibleGroups(rot) || HavePotFitGroups(rot) ) er->out_angles = open_angles_out(opt2fn("-ra",nfile,fnm), rot, oenv); if ( HaveFlexibleGroups(rot) ) er->out_torque = open_torque_out(opt2fn("-rt",nfile,fnm), rot, oenv); } sfree(x_pbc); } } extern void finish_rot(FILE *fplog,t_rot *rot) { gmx_enfrot_t er; er=rot->enfrot; if (er->out_rot) gmx_fio_fclose(er->out_rot); if (er->out_slabs) gmx_fio_fclose(er->out_slabs); if (er->out_angles) gmx_fio_fclose(er->out_angles); if (er->out_torque) gmx_fio_fclose(er->out_torque); } static void rotate_local_reference(t_rotgrp *rotg) { gmx_enfrotgrp_t erg; int i,ii; erg=rotg->enfrotgrp; for (i=0; i<erg->nat_loc; i++) { ii = erg->xc_ref_ind[i]; mvmul(erg->rotmat, rotg->x_ref[ii], erg->xr_loc[i]); } } static void choose_pbc_image(rvec x[], t_rotgrp *rotg, matrix box, int npbcdim) { int d,i,ii,m; gmx_enfrotgrp_t erg; rvec xref,xcurr,dx; ivec shift; erg=rotg->enfrotgrp; for (i=0; i<erg->nat_loc; i++) { clear_ivec(shift); ii = erg->ind_loc[i]; copy_rvec(erg->xr_loc[i], xref); rvec_sub(x[ii], erg->xc_center, xcurr); rvec_sub(xcurr, xref, dx); for(m=npbcdim-1; m>=0; m--) { while (dx[m] < -0.5*box[m][m]) { for(d=0; d<DIM; d++) dx[d] += box[m][d]; shift[m]++; } while (dx[m] >= 0.5*box[m][m]) { for(d=0; d<DIM; d++) dx[d] -= box[m][d]; shift[m]--; } } copy_rvec(x[ii], erg->x_loc_pbc[i]); shift_single_coord(box, erg->x_loc_pbc[i], shift); } } extern void do_rotation( t_commrec *cr, t_inputrec *ir, matrix box, rvec x[], real t, gmx_large_int_t step, gmx_wallcycle_t wcycle, gmx_bool bNS) { int g,i,ii; t_rot *rot; t_rotgrp *rotg; gmx_bool outstep_slab, outstep_rot; gmx_bool bFlex,bColl; gmx_enfrot_t er; gmx_enfrotgrp_t erg; rvec transvec; t_gmx_potfit *fit=NULL; gmx_cycles_t cycles_comp; #ifdef TAKETIME double t0; #endif rot=ir->rot; er=rot->enfrot; outstep_rot = do_per_step(step, rot->nstrout) && er->bOut; outstep_slab = do_per_step(step, rot->nstsout) && er->bOut; if (outstep_rot && MASTER(cr)) fprintf(er->out_rot, "%12.3e",t); for(g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; erg=rotg->enfrotgrp; bFlex = ISFLEX(rotg); bColl = ISCOLL(rotg); erg->degangle = rotg->rate * t; calc_rotmat(rotg->vec,erg->degangle,erg->rotmat); if (bColl) { communicate_group_positions(cr,erg->xc, erg->xc_shifts, erg->xc_eshifts, bNS, x, rotg->nat, erg->nat_loc, erg->ind_loc, erg->xc_ref_ind, erg->xc_old, box); } else { if (bNS) { for (i=0; i<erg->nat_loc; i++) { ii = erg->xc_ref_ind[i]; erg->m_loc[i] = erg->mc[ii]; } } rotate_local_reference(rotg); choose_pbc_image(x, rotg, box, 3); if ( (rotg->eType==erotgISOPF) || (rotg->eType==erotgPMPF) ) get_center_comm(cr, erg->x_loc_pbc, erg->m_loc, erg->nat_loc, rotg->nat, erg->xc_center); } } cycles_comp = gmx_cycles_read(); #ifdef TAKETIME t0 = MPI_Wtime(); #endif for(g=0; g<rot->ngrp; g++) { rotg = &rot->grp[g]; erg=rotg->enfrotgrp; bFlex = ISFLEX(rotg); bColl = ISCOLL(rotg); if (outstep_rot && MASTER(cr)) fprintf(er->out_rot, "%12.4f", erg->degangle); if ( (outstep_rot || outstep_slab) && (erotgFitPOT == rotg->eFittype) ) { fit = erg->PotAngleFit; for (i = 0; i < rotg->PotAngle_nstep; i++) { calc_rotmat(rotg->vec, erg->degangle + fit->degangle[i], fit->rotmat[i]); erg->PotAngleFit->V[i] = 0.0; } } erg->V = 0.0; erg->torque_v = 0.0; erg->angle_v = 0.0; erg->weight_v = 0.0; switch(rotg->eType) { case erotgISO: case erotgISOPF: case erotgPM: case erotgPMPF: do_fixed(rotg,x,box,t,step,outstep_rot,outstep_slab); break; case erotgRM: do_radial_motion(rotg,x,box,t,step,outstep_rot,outstep_slab); break; case erotgRMPF: do_radial_motion_pf(rotg,x,box,t,step,outstep_rot,outstep_slab); break; case erotgRM2: case erotgRM2PF: do_radial_motion2(rotg,x,box,t,step,outstep_rot,outstep_slab); break; case erotgFLEXT: case erotgFLEX2T: get_center(erg->xc, erg->mc, rotg->nat, erg->xc_center); svmul(-1.0, erg->xc_center, transvec); translate_x(erg->xc, rotg->nat, transvec); do_flexible(MASTER(cr),er,rotg,g,x,box,t,step,outstep_rot,outstep_slab); break; case erotgFLEX: case erotgFLEX2: clear_rvec(erg->xc_center); do_flexible(MASTER(cr),er,rotg,g,x,box,t,step,outstep_rot,outstep_slab); break; default: gmx_fatal(FARGS, "No such rotation potential."); break; } } #ifdef TAKETIME if (MASTER(cr)) fprintf(stderr, "%s calculation (step %d) took %g seconds.\n", RotStr, step, MPI_Wtime()-t0); #endif cycles_comp = gmx_cycles_read() - cycles_comp; if (DOMAINDECOMP(cr) && wcycle) dd_cycles_add(cr->dd,cycles_comp,ddCyclF); }
#ifndef CGAL_ARR_DCEL_BASE_H #define CGAL_ARR_DCEL_BASE_H #include <CGAL/license/Arrangement_on_surface_2.h> #include <CGAL/disable_warnings.h> #include <CGAL/basic.h> #include <CGAL/Arr_enums.h> #include <list> #include <map> #include <CGAL/N_step_adaptor_derived.h> #include <CGAL/Compact_container.h> #include <CGAL/function_objects.h> #include <CGAL/Iterator_project.h> #include <CGAL/Arrangement_2/Arrangement_2_iterators.h> #include <CGAL/assertions.h> #include <boost/pool/pool_alloc.hpp> namespace CGAL { inline void* _clean_pointer(const void* p) { CGAL_static_assertion(sizeof(void*) == sizeof(size_t)); const size_t mask = ~1; const size_t val = (reinterpret_cast<size_t>(p) & mask); return (reinterpret_cast<void*>(val)); } inline void* _set_lsb(const void* p) { const size_t mask = 1; const size_t val = (reinterpret_cast<size_t>(p) | mask); return (reinterpret_cast<void*>( val)); } inline bool _is_lsb_set(const void* p) { const size_t mask = 1; const size_t val = reinterpret_cast<size_t>(p); return ((val & mask) != 0); } template <typename Point_> class Arr_vertex_base { public: typedef Point_ Point; template<typename PNT> struct rebind { typedef Arr_vertex_base<PNT> other; }; protected: void* p_inc; Point* p_pt; char pss[2]; public: Arr_vertex_base() : p_inc(nullptr), p_pt(nullptr) { pss[0] = pss[1] = static_cast<char>(CGAL::ARR_INTERIOR); } virtual ~Arr_vertex_base() {} void* for_compact_container() const { return static_cast<void*>(p_pt); } void for_compact_container(void* ptr) { p_pt = static_cast<Point*>(ptr); } void* inc() const { return p_inc; } void set_inc(void * inc) const { const_cast<Arr_vertex_base&>(*this).p_inc = inc; } bool has_null_point() const { return (p_pt == nullptr); } const Point& point() const { CGAL_assertion(p_pt != nullptr); return (*p_pt); } Point& point() { CGAL_assertion(p_pt != nullptr); return (*p_pt); } void set_point(Point* p) { p_pt = p; } Arr_parameter_space parameter_space_in_x() const { return (Arr_parameter_space(pss[0])); } Arr_parameter_space parameter_space_in_y() const { return (Arr_parameter_space(pss[1])); } void set_boundary(Arr_parameter_space ps_x, Arr_parameter_space ps_y) { pss[0] = static_cast<char>(ps_x); pss[1] = static_cast<char>(ps_y); return; } virtual void assign(const Arr_vertex_base<Point>& v) { p_pt = v.p_pt; pss[0] = v.pss[0]; pss[1] = v.pss[1]; } }; template <typename X_monotone_curve_> class Arr_halfedge_base { public: typedef X_monotone_curve_ X_monotone_curve; template<typename XCV> struct rebind { typedef Arr_halfedge_base<XCV> other; }; protected: void* p_opp; void* p_prev; void* p_next; void* p_v; void* p_comp; X_monotone_curve* p_cv; public: Arr_halfedge_base() : p_opp(nullptr), p_prev(nullptr), p_next(nullptr), p_v(nullptr), p_comp(nullptr), p_cv(nullptr) {} virtual ~Arr_halfedge_base() {} void* for_compact_container() const { return static_cast<void*>(p_cv); } void for_compact_container(void* ptr) { p_cv = static_cast<X_monotone_curve*>(ptr); } bool has_null_curve() const { return (p_cv == nullptr); } const X_monotone_curve& curve() const { CGAL_precondition(p_cv != nullptr); return (*p_cv); } X_monotone_curve& curve() { CGAL_precondition(p_cv != nullptr); return (*p_cv); } void set_curve(X_monotone_curve* c) { p_cv = c; Arr_halfedge_base<X_monotone_curve>* opp = reinterpret_cast<Arr_halfedge_base<X_monotone_curve>* >(p_opp); opp->p_cv = c; } virtual void assign(const Arr_halfedge_base<X_monotone_curve>& he) { p_cv = he.p_cv; } }; class Arr_face_base { public: typedef std::list<void*> Outer_ccbs_container; typedef Outer_ccbs_container::iterator Outer_ccb_iterator; typedef Outer_ccbs_container::const_iterator Outer_ccb_const_iterator; typedef std::list<void*> Inner_ccbs_container; typedef Inner_ccbs_container::iterator Inner_ccb_iterator; typedef Inner_ccbs_container::const_iterator Inner_ccb_const_iterator; typedef std::list<void*> Isolated_vertices_container; typedef Isolated_vertices_container::iterator Isolated_vertex_iterator; typedef Isolated_vertices_container::const_iterator Isolated_vertex_const_iterator; protected: enum { IS_UNBOUNDED = 1, IS_FICTITIOUS = 2 }; int flags; Outer_ccbs_container outer_ccbs; Inner_ccbs_container inner_ccbs; Isolated_vertices_container iso_verts; public: Arr_face_base() : flags(0) {} virtual ~Arr_face_base() {} bool is_unbounded() const { return ((flags & IS_UNBOUNDED) != 0); } void set_unbounded(bool unbounded) { flags = (unbounded) ? (flags | IS_UNBOUNDED) : (flags & ~IS_UNBOUNDED); } bool is_fictitious() const { return ((flags & IS_FICTITIOUS) != 0); } void set_fictitious(bool fictitious) { flags = (fictitious) ? (flags | IS_FICTITIOUS) : (flags & ~IS_FICTITIOUS); } virtual void assign(const Arr_face_base& f) { flags = f.flags; } }; template <class V, class H, class F> class Arr_vertex; template <class V, class H, class F> class Arr_halfedge; template <class V, class H, class F> class Arr_face; template <class V, class H, class F> class Arr_outer_ccb; template <class V, class H, class F> class Arr_inner_ccb; template <class V, class H, class F> class Arr_isolated_vertex; template <class V, class H, class F> class Arr_vertex : public V { public: typedef V Base; typedef Arr_vertex<V,H,F> Vertex; typedef Arr_halfedge<V,H,F> Halfedge; typedef Arr_isolated_vertex<V,H,F> Isolated_vertex; Arr_vertex() {} bool is_isolated() const { return (_is_lsb_set(this->p_inc)); } const Halfedge* halfedge() const { CGAL_precondition(! is_isolated()); return (reinterpret_cast<const Halfedge*>(this->p_inc)); } Halfedge* halfedge() { CGAL_precondition(! is_isolated()); return (reinterpret_cast<Halfedge*>(this->p_inc)); } void set_halfedge(Halfedge* he) { this->p_inc = he; } const Isolated_vertex* isolated_vertex() const { CGAL_precondition(is_isolated()); return (reinterpret_cast<const Isolated_vertex*>(_clean_pointer (this->p_inc))); } Isolated_vertex* isolated_vertex() { CGAL_precondition(is_isolated()); return (reinterpret_cast<Isolated_vertex*>(_clean_pointer(this->p_inc))); } void set_isolated_vertex(Isolated_vertex* iv) { this->p_inc = _set_lsb(iv); } }; template <class V, class H, class F> class Arr_halfedge : public H { public: typedef H Base; typedef Arr_vertex<V,H,F> Vertex; typedef Arr_halfedge<V,H,F> Halfedge; typedef Arr_face<V,H,F> Face; typedef Arr_outer_ccb<V,H,F> Outer_ccb; typedef Arr_inner_ccb<V,H,F> Inner_ccb; Arr_halfedge() {} const Halfedge* opposite () const { return (reinterpret_cast<const Halfedge*>(this->p_opp)); } Halfedge* opposite() { return (reinterpret_cast<Halfedge*>(this->p_opp)); } void set_opposite(Halfedge* he) { this->p_opp = he; } Arr_halfedge_direction direction() const { if (_is_lsb_set(this->p_v)) return (ARR_LEFT_TO_RIGHT); else return (ARR_RIGHT_TO_LEFT); } void set_direction(Arr_halfedge_direction dir) { Halfedge* opp = reinterpret_cast<Halfedge*>(this->p_opp); if (dir == ARR_LEFT_TO_RIGHT) { this->p_v = _set_lsb(this->p_v); opp->p_v = _clean_pointer(opp->p_v); } else { this->p_v = _clean_pointer(this->p_v); opp->p_v = _set_lsb(opp->p_v); } } const Halfedge* prev() const { return (reinterpret_cast<const Halfedge*>(this->p_prev)); } Halfedge* prev() { return (reinterpret_cast<Halfedge*>(this->p_prev)); } void set_prev(Halfedge* he) { this->p_prev = he; he->p_next = this; } const Halfedge* next() const { return (reinterpret_cast<const Halfedge*>(this->p_next)); } Halfedge* next() { return (reinterpret_cast<Halfedge*>(this->p_next)); } void set_next(Halfedge* he) { this->p_next = he; he->p_prev = this; } const Vertex* vertex() const { return (reinterpret_cast<const Vertex*>(_clean_pointer(this->p_v))); } Vertex* vertex() { return (reinterpret_cast<Vertex*>(_clean_pointer(this->p_v))); } void set_vertex(Vertex* v) { if (_is_lsb_set(this->p_v)) this->p_v = _set_lsb(v); else this->p_v = v; } bool is_on_outer_ccb() const { return (!_is_lsb_set(this->p_comp)); } const Outer_ccb* outer_ccb() const { CGAL_precondition(! is_on_inner_ccb()); return (reinterpret_cast<const Outer_ccb*>(this->p_comp)); } Outer_ccb* outer_ccb() { CGAL_precondition(! is_on_inner_ccb()); return (reinterpret_cast<Outer_ccb*>(this->p_comp)); } void set_outer_ccb(Outer_ccb *oc) { this->p_comp = oc; } bool is_on_inner_ccb() const { return (_is_lsb_set(this->p_comp)); } const Inner_ccb* inner_ccb() const { CGAL_precondition(is_on_inner_ccb()); return (reinterpret_cast<const Inner_ccb*>(_clean_pointer(this->p_comp))); } Inner_ccb* inner_ccb() { CGAL_precondition(is_on_inner_ccb()); return (reinterpret_cast<Inner_ccb*>(_clean_pointer(this->p_comp))); } void set_inner_ccb(Inner_ccb *ic) { this->p_comp = _set_lsb(ic); } }; template <class V, class H, class F> class Arr_face : public F, public Compact_container_base { public: typedef F Base; typedef Arr_vertex<V,H,F> Vertex; typedef Arr_halfedge<V,H,F> Halfedge; typedef Arr_face<V,H,F> Face; typedef Arr_outer_ccb<V,H,F> Outer_ccb; typedef Arr_inner_ccb<V,H,F> Inner_ccb; typedef Arr_isolated_vertex<V,H,F> Isolated_vertex; typedef Inner_ccb Hole; private: typedef Cast_function_object<void*, Halfedge*> _Ccb_to_halfedge_cast; typedef _Ccb_to_halfedge_cast _Const_ccb_to_halfedge_cast; public: Arr_face() {} typedef Iterator_project<typename F::Outer_ccb_iterator, _Ccb_to_halfedge_cast> Outer_ccb_iterator; typedef Iterator_project<typename F::Outer_ccb_const_iterator, _Const_ccb_to_halfedge_cast> Outer_ccb_const_iterator; size_t number_of_outer_ccbs() const { return (this->outer_ccbs.size()); } Outer_ccb_iterator outer_ccbs_begin() { return (this->outer_ccbs.begin()); } Outer_ccb_iterator outer_ccbs_end() { return (this->outer_ccbs.end()); } Outer_ccb_const_iterator outer_ccbs_begin() const { return (this->outer_ccbs.begin()); } Outer_ccb_const_iterator outer_ccbs_end() const { return (this->outer_ccbs.end()); } void add_outer_ccb(Outer_ccb *oc, Halfedge *h) { oc->set_iterator(this->outer_ccbs.insert(this->outer_ccbs.end(), h)); } void erase_outer_ccb(Outer_ccb *oc) { this->outer_ccbs.erase(oc->iterator().current_iterator()); } typedef Iterator_project<typename F::Inner_ccb_iterator, _Ccb_to_halfedge_cast> Inner_ccb_iterator; typedef Iterator_project<typename F::Inner_ccb_const_iterator, _Const_ccb_to_halfedge_cast> Inner_ccb_const_iterator; typedef Inner_ccb_iterator Hole_iterator; typedef Inner_ccb_const_iterator Hole_const_iterator; size_t number_of_inner_ccbs() const { return (this->inner_ccbs.size()); } Inner_ccb_iterator inner_ccbs_begin() { return (this->inner_ccbs.begin()); } Inner_ccb_iterator inner_ccbs_end() { return (this->inner_ccbs.end()); } Inner_ccb_const_iterator inner_ccbs_begin() const { return (this->inner_ccbs.begin()); } Inner_ccb_const_iterator inner_ccbs_end() const { return (this->inner_ccbs.end()); } void add_inner_ccb(Inner_ccb* ic, Halfedge* h) { ic->set_iterator(this->inner_ccbs.insert(this->inner_ccbs.end(), h)); } void erase_inner_ccb(Inner_ccb* ic) { this->inner_ccbs.erase(ic->iterator().current_iterator()); } Inner_ccb_iterator splice_inner_ccbs(Arr_face& other) { const bool was_empty = this->inner_ccbs.empty(); typename Base::Inner_ccbs_container::iterator previous = this->inner_ccbs.end(); if (!was_empty) --previous; this->inner_ccbs.splice(this->inner_ccbs.end(), other.inner_ccbs); if (was_empty) previous = this->inner_ccbs.begin(); else ++previous; for (typename Base::Inner_ccbs_container::iterator it = previous; it != this->inner_ccbs.end(); ++it) { Inner_ccb* ccb = static_cast<Halfedge*>(*it)->inner_ccb(); ccb->set_iterator(it); ccb->set_face(this); } return previous; } size_t number_of_holes() const { return number_of_inner_ccbs(); } Hole_iterator holes_begin() { return inner_ccbs_begin(); } Hole_iterator holes_end() { return inner_ccbs_end(); } Hole_const_iterator holes_begin() const { return inner_ccbs_begin(); } Hole_const_iterator holes_end() const { return inner_ccbs_end(); } typedef I_Dereference_iterator< typename F::Isolated_vertex_iterator, Vertex, typename F::Isolated_vertex_iterator::difference_type, typename F::Isolated_vertex_iterator::iterator_category> Isolated_vertex_iterator; typedef I_Dereference_const_iterator< typename F::Isolated_vertex_const_iterator, typename F::Isolated_vertex_iterator, Vertex, typename F::Isolated_vertex_iterator::difference_type, typename F::Isolated_vertex_iterator::iterator_category> Isolated_vertex_const_iterator; size_t number_of_isolated_vertices() const { return (this->iso_verts.size()); } Isolated_vertex_iterator isolated_vertices_begin() { return (this->iso_verts.begin()); } Isolated_vertex_iterator isolated_vertices_end() { return (this->iso_verts.end()); } Isolated_vertex_const_iterator isolated_vertices_begin() const { return (this->iso_verts.begin()); } Isolated_vertex_const_iterator isolated_vertices_end() const { return (this->iso_verts.end()); } void add_isolated_vertex(Isolated_vertex *iv, Vertex* v) { iv->set_iterator(this->iso_verts.insert(this->iso_verts.end(), v)); } void erase_isolated_vertex(Isolated_vertex *iv) { this->iso_verts.erase(iv->iterator().current_iterator()); } Isolated_vertex_iterator splice_isolated_vertices(Arr_face& other) { const bool was_empty = this->iso_verts.empty(); typename Base::Isolated_vertices_container::iterator previous = this->iso_verts.end(); if (!was_empty) --previous; this->iso_verts.splice(this->iso_verts.end(), other.iso_verts); if (was_empty) previous = this->iso_verts.begin(); else ++previous; for (typename Base::Isolated_vertices_container::iterator it = previous; it != this->iso_verts.end(); ++it) { Isolated_vertex* iv = static_cast<Vertex*>(*it)->isolated_vertex(); iv->set_iterator(it); iv->set_face(this); } return previous; } }; template <class V, class H, class F> class Arr_outer_ccb { public: typedef Arr_outer_ccb<V,H,F> Self; typedef Arr_halfedge<V,H,F> Halfedge; typedef Arr_face<V,H,F> Face; typedef typename Face::Outer_ccb_iterator Outer_ccb_iterator; private: Face* p_f; Outer_ccb_iterator iter; bool iter_is_not_singular; public: Arr_outer_ccb() : p_f(nullptr), iter_is_not_singular(false) {} Arr_outer_ccb(const Arr_outer_ccb& other) : p_f(other.p_f), iter_is_not_singular(other.iter_is_not_singular) { if (other.iter_is_not_singular) iter = other.iter; } void* for_compact_container() const { return static_cast<void*>(p_f); } void for_compact_container(void* ptr) { p_f = static_cast<Face*>(ptr); } const Halfedge* halfedge() const { return (*iter); } Halfedge* halfedge() { return (*iter); } void set_halfedge(Halfedge* he) { *iter = he; } const Face* face() const { return (p_f); } Face* face() { return (p_f); } void set_face(Face* f) { p_f = f; } Outer_ccb_iterator iterator() const { CGAL_assertion(iter_is_not_singular); return (iter); } Outer_ccb_iterator iterator() { CGAL_assertion(iter_is_not_singular); return (iter); } void set_iterator(Outer_ccb_iterator it) { iter = it; iter_is_not_singular = true; } }; template <class V, class H, class F> class Arr_inner_ccb : public Compact_container_base { public: typedef Arr_inner_ccb<V,H,F> Self; typedef Arr_halfedge<V,H,F> Halfedge; typedef Arr_face<V,H,F> Face; typedef typename Face::Inner_ccb_iterator Inner_ccb_iterator; private: Face* p_f; Inner_ccb_iterator iter; bool iter_is_not_singular; public: Arr_inner_ccb() : p_f(nullptr), iter_is_not_singular(false) {} Arr_inner_ccb(const Arr_inner_ccb& other) : p_f(other.p_f), iter_is_not_singular(other.iter_is_not_singular) { if (other.iter_is_not_singular) iter = other.iter; } const Halfedge* halfedge() const { return (*iter); } Halfedge* halfedge() { return (*iter); } void set_halfedge(Halfedge *he) { *iter = he; } const Face* face() const { return (p_f); } Face* face() { return (p_f); } void set_face(Face* f) { p_f = f; } Inner_ccb_iterator iterator() const { CGAL_assertion(iter_is_not_singular); return (iter); } Inner_ccb_iterator iterator() { CGAL_assertion(iter_is_not_singular); return (iter); } void set_iterator(Inner_ccb_iterator it) { iter = it; iter_is_not_singular = true; } }; template <class V, class H, class F> class Arr_isolated_vertex { public: typedef Arr_isolated_vertex<V,H,F> Self; typedef Arr_face<V,H,F> Face; typedef typename Face::Isolated_vertex_iterator Isolated_vertex_iterator; private: Face* p_f; Isolated_vertex_iterator iv_it; bool iter_is_not_singular; public: Arr_isolated_vertex() : p_f(nullptr), iter_is_not_singular(false) {} Arr_isolated_vertex(const Arr_isolated_vertex& other) : p_f(other.p_f), iter_is_not_singular(other.iter_is_not_singular) { if (other.iter_is_not_singular) iv_it = other.iv_it; } void* for_compact_container() const { return static_cast<void*>(p_f); } void for_compact_container(void* ptr) { p_f = static_cast<Face*>(ptr); } const Face* face() const { return (p_f); } Face* face() { return (p_f); } void set_face(Face* f) { p_f = f; } Isolated_vertex_iterator iterator() const { CGAL_assertion(iter_is_not_singular); return (iv_it); } Isolated_vertex_iterator iterator() { CGAL_assertion(iter_is_not_singular); return (iv_it); } void set_iterator(Isolated_vertex_iterator iv) { iv_it = iv; iter_is_not_singular = true; } }; template <class V, class H, class F, class Allocator = CGAL_ALLOCATOR(int)> class Arr_dcel_base { public: typedef Arr_dcel_base<V,H,F> Self; typedef Arr_vertex<V,H,F> Vertex; typedef Arr_halfedge<V,H,F> Halfedge; typedef Arr_face<V,H,F> Face; typedef Arr_outer_ccb<V,H,F> Outer_ccb; typedef Arr_inner_ccb<V,H,F> Inner_ccb; typedef Arr_isolated_vertex<V,H,F> Isolated_vertex; typedef Inner_ccb Hole; protected: typedef std::allocator_traits<Allocator> Allocator_traits; typedef typename Allocator_traits::template rebind_alloc<Vertex> Vertex_allocator; typedef typename Allocator_traits::template rebind_alloc<Halfedge> Halfedge_allocator; typedef typename Allocator_traits::template rebind_alloc<Face> Face_allocator; typedef typename Allocator_traits::template rebind_alloc<Outer_ccb> Outer_ccb_allocator; typedef typename Allocator_traits::template rebind_alloc<Inner_ccb> Inner_ccb_allocator; typedef typename Allocator_traits::template rebind_alloc<Isolated_vertex> Iso_vert_allocator; typedef Compact_container<Vertex, Vertex_allocator> Vertex_list; typedef Compact_container<Halfedge, Halfedge_allocator> Halfedge_list; typedef Compact_container<Face, Face_allocator> Face_list; typedef Compact_container<Outer_ccb, Outer_ccb_allocator> Outer_ccb_list; typedef Compact_container<Inner_ccb, Inner_ccb_allocator> Inner_ccb_list; typedef Compact_container<Isolated_vertex, Iso_vert_allocator> Iso_vert_list; public: typedef typename Halfedge_list::size_type Size; typedef typename Halfedge_list::size_type size_type; typedef typename Halfedge_list::difference_type difference_type; typedef typename Halfedge_list::difference_type Difference; typedef std::bidirectional_iterator_tag iterator_category; protected: Vertex_list vertices; Halfedge_list halfedges; Face_list faces; Outer_ccb_list out_ccbs; Inner_ccb_list in_ccbs; Iso_vert_list iso_verts; public: typedef typename Vertex_list::iterator Vertex_iterator; typedef typename Halfedge_list::iterator Halfedge_iterator; typedef typename Face_list::iterator Face_iterator; typedef CGAL::N_step_adaptor_derived<Halfedge_iterator, 2> Edge_iterator; typedef typename Vertex_list::const_iterator Vertex_const_iterator; typedef typename Halfedge_list::const_iterator Halfedge_const_iterator; typedef typename Face_list::const_iterator Face_const_iterator; typedef CGAL::N_step_adaptor_derived<Halfedge_const_iterator, 2> Edge_const_iterator; private: Arr_dcel_base(const Self&); Self& operator=(const Self&); public: Arr_dcel_base() {} ~Arr_dcel_base() { delete_all(); } Size size_of_vertices() const { return (vertices.size()); } Size size_of_halfedges() const { return (halfedges.size()); } Size size_of_faces() const { return (faces.size()); } Size size_of_outer_ccbs() const { return (out_ccbs.size()); } Size size_of_inner_ccbs() const { return (in_ccbs.size()); } Size size_of_isolated_vertices() const { return (iso_verts.size()); } Vertex_iterator vertices_begin() { return vertices.begin(); } Vertex_iterator vertices_end() { return vertices.end(); } Iterator_range<Prevent_deref<Vertex_iterator> > vertex_handles() { return make_prevent_deref_range(vertices_begin(), vertices_end()); } Halfedge_iterator halfedges_begin() { return halfedges.begin();} Halfedge_iterator halfedges_end() { return halfedges.end(); } Iterator_range<Prevent_deref<Halfedge_iterator> > halfedge_handles() { return make_prevent_deref_range(halfedges_begin(), halfedges_end()); } Face_iterator faces_begin() { return faces.begin(); } Face_iterator faces_end() { return faces.end(); } Iterator_range<Prevent_deref<Face_iterator> > face_handles() { return make_prevent_deref_range(faces_begin(), faces_end()); } Edge_iterator edges_begin() { return halfedges.begin(); } Edge_iterator edges_end() { return halfedges.end(); } Iterator_range<Prevent_deref<Edge_iterator> > edge_handles() { return make_prevent_deref_range(edges_begin(), edges_end()); } Vertex_const_iterator vertices_begin() const { return vertices.begin(); } Vertex_const_iterator vertices_end() const { return vertices.end(); } Iterator_range<Prevent_deref<Vertex_const_iterator> > vertex_handles() const { return make_prevent_deref_range(vertices_begin(), vertices_end()); } Halfedge_const_iterator halfedges_begin() const { return halfedges.begin(); } Halfedge_const_iterator halfedges_end() const { return halfedges.end(); } Iterator_range<Prevent_deref<Halfedge_const_iterator> > halfedge_handles() const { return make_prevent_deref_range(halfedges_begin(), halfedges_end()); } Face_const_iterator faces_begin() const { return faces.begin(); } Face_const_iterator faces_end() const { return faces.end(); } Iterator_range<Prevent_deref<Face_const_iterator> > face_handles() const { return make_prevent_deref_range(faces_begin(), faces_end()); } Edge_const_iterator edges_begin() const { return halfedges.begin(); } Edge_const_iterator edges_end() const { return halfedges.end(); } Iterator_range<Prevent_deref<Edge_const_iterator> > edge_handles() const { return make_prevent_deref_range(edges_begin(), edges_end()); } Vertex* new_vertex() { return &*vertices.emplace(); } Halfedge* new_edge() { Halfedge* h1 = _new_halfedge(); Halfedge* h2 = _new_halfedge(); h1->set_opposite(h2); h2->set_opposite(h1); return (h1); } Face* new_face() { return &*faces.emplace(); } Outer_ccb* new_outer_ccb() { return &*out_ccbs.emplace(); } Inner_ccb* new_inner_ccb() { return &*in_ccbs.emplace(); } Isolated_vertex* new_isolated_vertex() { return &*iso_verts.emplace(); } void delete_vertex(Vertex* v) { vertices.erase (vertices.iterator_to(*v)); } void delete_edge(Halfedge *h) { Halfedge* h_opp = h->opposite(); _delete_halfedge(h); _delete_halfedge(h_opp); } void delete_face(Face* f) { faces.erase (faces.iterator_to(*f)); } void delete_outer_ccb(Outer_ccb* oc) { out_ccbs.erase (out_ccbs.iterator_to(*oc)); } void delete_inner_ccb(Inner_ccb* ic) { in_ccbs.erase (in_ccbs.iterator_to(*ic)); } void delete_isolated_vertex(Isolated_vertex* iv) { iso_verts.erase (iso_verts.iterator_to(*iv)); } void delete_all() { Vertex_iterator vit = vertices.begin(), v_curr; while (vit != vertices.end()) { v_curr = vit; ++vit; delete_vertex(&(*v_curr)); } Halfedge_iterator hit = halfedges.begin(), h_curr; while (hit != halfedges.end()) { h_curr = hit; ++hit; _delete_halfedge(&(*h_curr)); } Face_iterator fit = faces.begin(), f_curr; while (fit != faces.end()) { f_curr = fit; ++fit; delete_face(&(*f_curr)); } typename Outer_ccb_list::iterator ocit = out_ccbs.begin(), oc_curr; while (ocit != out_ccbs.end()) { oc_curr = ocit; ++ocit; delete_outer_ccb(&(*oc_curr)); } typename Inner_ccb_list::iterator icit = in_ccbs.begin(), ic_curr; while (icit != in_ccbs.end()) { ic_curr = icit; ++icit; delete_inner_ccb(&(*ic_curr)); } typename Iso_vert_list::iterator ivit = iso_verts.begin(), iv_curr; while (ivit != iso_verts.end()) { iv_curr = ivit; ++ivit; delete_isolated_vertex(&(*iv_curr)); } } void assign(const Self& dcel) { delete_all(); typedef std::map<const Vertex*, Vertex*> Vertex_map; typedef std::map<const Halfedge*, Halfedge*> Halfedge_map; typedef std::map<const Face*, Face*> Face_map; typedef std::map<const Outer_ccb*, Outer_ccb*> Outer_ccb_map; typedef std::map<const Inner_ccb*, Inner_ccb*> Inner_ccb_map; typedef std::map<const Isolated_vertex*, Isolated_vertex*> Iso_vert_map; Vertex_map v_map; Vertex_const_iterator vit; Vertex* dup_v; for (vit = dcel.vertices_begin(); vit != dcel.vertices_end(); ++vit) { dup_v = new_vertex(); dup_v->assign(*vit); v_map.insert(typename Vertex_map::value_type(&(*vit), dup_v)); } Halfedge_map he_map; Halfedge_const_iterator hit; Halfedge* dup_h; for (hit = dcel.halfedges_begin(); hit != dcel.halfedges_end(); ++hit) { dup_h = _new_halfedge(); dup_h->assign(*hit); he_map.insert(typename Halfedge_map::value_type(&(*hit), dup_h)); } Face_map f_map; Face_const_iterator fit; Face* dup_f; for (fit = dcel.faces_begin(); fit != dcel.faces_end(); ++fit) { dup_f = new_face(); dup_f->assign(*fit); f_map.insert(typename Face_map::value_type(&(*fit), dup_f)); } Outer_ccb_map oc_map; typename Outer_ccb_list::const_iterator ocit; Outer_ccb* dup_oc; for (ocit = dcel.out_ccbs.begin(); ocit != dcel.out_ccbs.end(); ++ocit) { dup_oc = new_outer_ccb(); oc_map.insert(typename Outer_ccb_map::value_type(&(*ocit), dup_oc)); } Inner_ccb_map ic_map; typename Inner_ccb_list::const_iterator icit; Inner_ccb* dup_ic; for (icit = dcel.in_ccbs.begin(); icit != dcel.in_ccbs.end(); ++icit) { dup_ic = new_inner_ccb(); ic_map.insert(typename Inner_ccb_map::value_type(&(*icit), dup_ic)); } Iso_vert_map iv_map; typename Iso_vert_list::const_iterator ivit; Isolated_vertex* dup_iv; for (ivit = dcel.iso_verts.begin(); ivit != dcel.iso_verts.end(); ++ivit) { dup_iv = new_isolated_vertex(); iv_map.insert(typename Iso_vert_map::value_type(&(*ivit), dup_iv)); } const Vertex* v; const Halfedge* h; const Face* f; const Outer_ccb* oc; const Inner_ccb* ic; const Isolated_vertex* iv; for (vit = dcel.vertices_begin(); vit != dcel.vertices_end(); ++vit) { v = &(*vit); dup_v = (v_map.find(v))->second; if (v->is_isolated()) { iv = v->isolated_vertex(); dup_iv = (iv_map.find(iv))->second; dup_v->set_isolated_vertex(dup_iv); } else { h = v->halfedge(); dup_h = (he_map.find(h))->second; dup_v->set_halfedge(dup_h); } } const Halfedge* opp; const Halfedge* prev; const Halfedge* next; Halfedge* dup_opp; Halfedge* dup_prev; Halfedge* dup_next; for (hit = dcel.halfedges_begin(); hit != dcel.halfedges_end(); ++hit) { h = &(*hit); v = h->vertex(); opp = h->opposite(); prev = h->prev(); next = h->next(); dup_h = (he_map.find(h))->second; dup_v = (v_map.find(v))->second; dup_opp = (he_map.find(opp))->second; dup_prev = (he_map.find(prev))->second; dup_next = (he_map.find(next))->second; dup_h->set_vertex(dup_v); dup_h->set_opposite(dup_opp); dup_h->set_prev(dup_prev); dup_h->set_next(dup_next); dup_h->set_direction(h->direction()); if (h->is_on_inner_ccb()) { ic = h->inner_ccb(); dup_ic = (ic_map.find(ic))->second; dup_h->set_inner_ccb(dup_ic); } else { oc = h->outer_ccb(); dup_oc = (oc_map.find(oc))->second; dup_h->set_outer_ccb(dup_oc); } } typename Face::Outer_ccb_const_iterator out_ccb_it; typename Face::Inner_ccb_const_iterator in_ccb_it; typename Face::Isolated_vertex_const_iterator iso_vert_it; const Halfedge* hccb; const Vertex* iso_vert; Halfedge* dup_hccb; Vertex* dup_iso_vert; for (fit = dcel.faces_begin(); fit != dcel.faces_end(); ++fit) { f = &(*fit); dup_f = (f_map.find(f))->second; dup_f->set_unbounded(f->is_unbounded()); dup_f->set_fictitious(f->is_fictitious()); for (out_ccb_it = f->outer_ccbs_begin(); out_ccb_it != f->outer_ccbs_end(); ++out_ccb_it) { hccb = *out_ccb_it; dup_hccb = (he_map.find(hccb))->second; dup_oc = dup_hccb->outer_ccb(); dup_oc->set_face(dup_f); dup_f->add_outer_ccb(dup_oc, dup_hccb); } for (in_ccb_it = f->inner_ccbs_begin(); in_ccb_it != f->inner_ccbs_end(); ++in_ccb_it) { hccb = *in_ccb_it; dup_hccb = (he_map.find(hccb))->second; dup_ic = dup_hccb->inner_ccb(); dup_ic->set_face(dup_f); dup_f->add_inner_ccb(dup_ic, dup_hccb); } for (iso_vert_it = f->isolated_vertices_begin(); iso_vert_it != f->isolated_vertices_end(); ++iso_vert_it) { iso_vert = &(*iso_vert_it); dup_iso_vert = (v_map.find(iso_vert))->second; dup_iv = dup_iso_vert->isolated_vertex(); dup_iv->set_face(dup_f); dup_f->add_isolated_vertex(dup_iv, dup_iso_vert); } } } protected: Halfedge* _new_halfedge() { return &*halfedges.emplace(); } void _delete_halfedge(Halfedge* h) { halfedges.erase (halfedges.iterator_to(*h)); } }; } #include <CGAL/enable_warnings.h> #endif
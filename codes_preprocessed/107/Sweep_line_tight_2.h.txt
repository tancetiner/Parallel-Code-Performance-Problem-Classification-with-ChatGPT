#ifndef CGAL_SWEEP_LINE_TIGHT_H #define CGAL_SWEEP_LINE_TIGHT_H #include <CGAL/Sweep_line_2/Sweep_line_functors.h> #include <map> #include <set> #include <assert.h> #ifndef VERBOSE #define SL_DEBUG(a) #define PRINT_INSERT(a) #define PRINT_ERASE(a) #define PRINT_NEW_EVENT(p, e) #define DBG(a) #define STORE_RESULT(a) #else #define SL_DEBUG(a) {a} #define PRINT_INSERT(a) { std::cout << "+++ inserting "; \ (a)->Print(); \ std::cout << " currentPos = " << m_currentPos \ << "\n"; \ } #define PRINT_ERASE(a) { std::cout << "--- erasing " ; \ (a)->Print(); } #define PRINT_NEW_EVENT(p, e) \ { std::cout << "%%% a new event was created at " << (p) << std::endl; \ (e)->Print(); } #define DBG(a) { std::cout << a << std::endl; } #define STORE_RESULT(a) {a} #endif #include <list> CGAL_BEGIN_NAMESPACE template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> class Sweep_line_tight_2 { public: typedef SweepLineTraits_2 Traits; typedef typename Traits::Point_2 Point_2; typedef typename Traits::Curve_2 Curve_2; typedef typename Traits::X_curve_2 X_curve_2; typedef SweepEvent Event; typedef Point_less_functor<Point_2, Traits> PointLess; typedef std::map<const Point_2, Event*, PointLess> EventQueue; typedef typename EventQueue::iterator EventQueueIter; typedef typename EventQueue::value_type EventQueueValueType; typedef std::vector<Event*> EventPtrContainer; typedef typename EventPtrContainer::iterator EventPtrContainerIter; typedef typename Event::SubCurveIter EventCurveIter; typedef CurveWrap Subcurve; typedef std::list<Subcurve*> SubCurveList; typedef typename SubCurveList::iterator SubCurveListIter; typedef Status_line_curve_less_functor<Traits, Subcurve> StatusLineCurveLess; typedef typename StatusLineCurveLess::Compare_param CompareParams; typedef std::set<Subcurve*, StatusLineCurveLess> StatusLine; typedef typename StatusLine::iterator StatusLineIter; typedef typename Event::VerticalCurveList VerticalCurveList; typedef typename Event::VerticalCurveListIter VerticalCurveListIter; typedef typename Event::VerticalXPointList VerticalXPointList; typedef typename Event::VerticalXPointListIter VerticalXPointListIter; typedef std::list<Event *> EventList; typedef typename EventList::iterator EventListIter; typedef std::list<X_curve_2> CurveList; typedef typename CurveList::iterator CurveListIter; class SweepLineGetSubCurves {}; class SweepLineGetPoints {}; class SweepLineGetInterCurveList {}; class SweepLinePlanarmap {}; Sweep_line_tight_2() : m_traits(new Traits()), m_traitsOwner(true), m_includeEndPoints(true), m_found_intersection(false) {} Sweep_line_tight_2(Traits *t) : m_traits(t), m_traitsOwner(false), m_includeEndPoints(true), m_found_intersection(false) {} virtual ~Sweep_line_tight_2(); template <class OutpoutIterator> void get_subcurves(CurveInputIterator begin, CurveInputIterator end, OutpoutIterator subcurves, bool overlapping = false) { Init(begin, end); SL_DEBUG( PrintSubCurves(); PrintEventQueue(); ) m_overlapping = overlapping; Sweep(subcurves, SweepLineGetSubCurves()); } template <class OutpoutIterator> void get_intersection_points(CurveInputIterator begin, CurveInputIterator end, OutpoutIterator points, bool includeEndPoints = true) { Init(begin, end); SL_DEBUG( PrintSubCurves(); PrintEventQueue(); ) m_includeEndPoints = includeEndPoints; Sweep(points, SweepLineGetPoints()); } template <class OutputIterator> void get_intersecting_curves(CurveInputIterator begin, CurveInputIterator end, OutputIterator intersecting_curves, bool endpoints = true) { SweepLineGetInterCurveList tag; } bool do_curves_intersect(CurveInputIterator begin, CurveInputIterator end) { Init(begin, end); SL_DEBUG( PrintSubCurves(); PrintEventQueue(); ) m_includeEndPoints = false; std::vector<Point_2> dummy; Sweep(std::back_inserter(dummy), SweepLineGetPoints(), true); return m_found_intersection; } protected: void Init(CurveInputIterator begin, CurveInputIterator end); void InitCurve(X_curve_2 &curve); template <class OutpoutIterator, class Op> void Sweep(OutpoutIterator out, Op tag, bool stop_at_first_int=false) { EventQueueIter eventIter = m_queue->begin(); m_prevPos = eventIter->first; while ( eventIter != m_queue->end() ) { const Point_2 *p = &(eventIter->first); if ( m_traits->compare_x(m_sweepLinePos, *p) == SMALLER ) m_prevPos = m_sweepLinePos; m_sweepLinePos = *p; m_currentPos = *p; m_verticals.clear(); m_verticalSubCurves.clear(); while (eventIter != m_queue->end() && m_traits->compare_x(eventIter->first, m_sweepLinePos) == EQUAL) { p = &(eventIter->first); m_currentEvent = eventIter->second; SL_DEBUG(std::cout << "------------- " << *p << " --------------" << std::endl; PrintStatusLine(); m_currentEvent->Print(); ) FirstPass(); HandleVerticalCurveBottom(tag); HandleVerticalOverlapCurves(); HandleLeftCurves(out, tag); m_miniq.push_back(m_currentEvent); ++eventIter; } m_queue->erase(m_queue->begin(), eventIter); EventListIter itt = m_miniq.begin(); while ( itt != m_miniq.end()) { m_currentEvent = *itt; HandleVerticalCurveTop(out, tag); HandleRightCurves(); ++itt; } m_miniq.clear(); eventIter = m_queue->begin(); } if ( stop_at_first_int && m_found_intersection ) return; } void FirstPass(); void HandleVerticalCurveBottom(SweepLineGetSubCurves &tag); void HandleVerticalCurveBottom(SweepLineGetPoints &tag); void HandleVerticalOverlapCurves(); template <class OutpoutIterator> void HandleLeftCurves(OutpoutIterator out, SweepLineGetSubCurves &tag) { SL_DEBUG(std::cout << "Handling left curve" << std::endl;) SL_DEBUG(m_currentEvent->Print();) EventCurveIter leftCurveIter = m_currentEvent->leftCurvesBegin(); m_currentPos = m_prevPos; const Point_2 &eventPoint = m_currentEvent->getPoint(); while ( leftCurveIter != m_currentEvent->leftCurvesEnd() ) { Subcurve *leftCurve = *leftCurveIter; const X_curve_2 &cv = leftCurve->getCurve(); const Point_2 &lastPoint = leftCurve->getLastPoint(); if ( leftCurve->isSource(eventPoint)) { if ( !leftCurve->isTarget(lastPoint) ) { X_curve_2 a,b; m_traits->curve_split(cv, a, b, lastPoint); AddCurveToOutput(a, leftCurve, out); } else { AddCurveToOutput(cv, leftCurve, out); } } else if ( leftCurve->isTarget(eventPoint)) { if ( !leftCurve->isSource(lastPoint)) { X_curve_2 a,b; m_traits->curve_split(cv, a, b, lastPoint); AddCurveToOutput(b, leftCurve, out); } else { AddCurveToOutput(cv, leftCurve, out); } } else { X_curve_2 a,b; if ( leftCurve->isSource(lastPoint)) { m_traits->curve_split(cv, a, b, eventPoint); AddCurveToOutput(a, leftCurve, out); } else if ( leftCurve->isTarget(lastPoint)) { m_traits->curve_split(cv, b, a, eventPoint); AddCurveToOutput(a, leftCurve, out); } else { const X_curve_2 &lastCurve = leftCurve->getLastCurve(); if ( leftCurve->isSourceLeftToTarget() ) { m_traits->curve_split(lastCurve, a, b, eventPoint); AddCurveToOutput(a, leftCurve, out); } else { m_traits->curve_split(lastCurve, b, a, eventPoint); AddCurveToOutput(a, leftCurve, out); } } leftCurve->setLastPoint(eventPoint); leftCurve->setLastCurve(b); } RemoveCurveFromStatusLine(leftCurve); m_currentPos = m_prevPos; ++leftCurveIter; } } template <class OutpoutIterator> void HandleVerticalCurveTop(OutpoutIterator out, SweepLineGetSubCurves &tag) { SL_DEBUG(std::cout<<"HandleVerticalCurveTop... (" << m_currentEvent->getPoint() << ")\n";) if ( !m_currentEvent->doesContainVerticalCurve() ) { SL_DEBUG(std::cout<<"exiting\n ";) return; } SL_DEBUG(std::cout<<"\n ";) VerticalCurveList &vcurves = m_currentEvent->getVerticalCurves(); VerticalCurveListIter vciter = vcurves.begin(); while ( vciter !=vcurves.end() ) { Subcurve *vcurve = *vciter; const Point_2 &topPoint = m_currentEvent->getPoint(); if ( vcurve->isBottomEnd(topPoint)) { SL_DEBUG(std::cout<<"this is the bottom. skipping.\n";) ++vciter; continue; } SL_DEBUG(std::cout<<"handling top point of vertical curve\n";) StatusLineIter slIter = m_statusLine->lower_bound(vcurve); if ( slIter != m_statusLine->end() ) { SL_DEBUG(std::cout<<"starting at curve \n";) SL_DEBUG((*slIter)->Print();) while (slIter != m_statusLine->end() && m_traits->curve_is_in_x_range((*slIter)->getCurve(), topPoint) && m_traits->curve_get_point_status((*slIter)->getCurve(), topPoint) == SMALLER && m_traits->curve_is_in_x_range((*slIter)->getCurve(), vcurve->getBottomEnd()) && m_traits->curve_get_point_status((*slIter)->getCurve(), vcurve->getBottomEnd()) == LARGER) { SL_DEBUG(std::cout<<"checking \n";) SL_DEBUG((*slIter)->Print();) if ( m_traits->compare_x((*slIter)->getLeftEnd(), topPoint) == EQUAL) { m_currentEvent->addVerticalCurveXPoint((*slIter)->getLeftEnd(), true); } ++slIter; } } SL_DEBUG(std::cout<<"handling the splitting now\n";) VerticalXPointList &pointList = m_currentEvent->getVerticalXPointList(); if ( pointList.empty() ) { AddVerticalCurveToOutput(out, vcurve->getCurve()); ++vciter; continue; } X_curve_2 a, b, c; a = vcurve->getCurve(); SL_DEBUG(std::cout << "there are " << pointList.size() << " points\n";) SL_DEBUG(m_currentEvent->PrintVerticalXPoints();) for ( VerticalXPointListIter i = pointList.begin() ; i != pointList.end(); ++i ) { SL_DEBUG(std::cout<< "splitting: " << a << " at " << *i ;) if ( !vcurve->isPointInRange(*i) ) { SL_DEBUG(std::cout << " not !\n";) continue; } SL_DEBUG(std::cout << " yes! \n";) m_traits->curve_split(a, b, c, *i); if ( vcurve->isSourceLeftToTarget()) { AddVerticalCurveToOutput(out, b); a = c; } else { AddVerticalCurveToOutput(out, c); a = b; } } if ( vcurve->isSourceLeftToTarget() ) { AddVerticalCurveToOutput(out, c); } else { AddVerticalCurveToOutput(out, b); } ++vciter; } } void HandleRightCurves(); bool Intersect(Subcurve *c1, Subcurve *c2); void IntersectCurveGroup(Subcurve *c1, SubCurveList &mylist); void RemoveCurveFromStatusLine(Subcurve *leftCurve); bool isInternalXPoint(const Point_2 &p); bool HandleVerticalCurveXAtEnd(Subcurve *vcurve, Subcurve *curve, Event *topEndEvent, SweepLineGetSubCurves tag); bool HandleVerticalCurveXAtEnd(Subcurve *vcurve, Subcurve *curve, Event *topEndEvent, SweepLineGetPoints tag); bool DoCurvesOverlap(Subcurve *c1, Subcurve *c2); bool SimilarCurves(const X_curve_2 &a, const X_curve_2 &b); bool VerticalSubCurveExists(const X_curve_2 &a); template <class OutpoutIterator> void AddCurveToOutput(const X_curve_2 &cv, Subcurve *curve, OutpoutIterator out) { static Subcurve *prevCurve = 0; static X_curve_2 prevXCv; if ( m_overlapping ) { *out = cv; ++out; } else { if ( prevCurve && SimilarCurves(cv, prevXCv)) { SL_DEBUG(std::cout << " curve already reported... " << std::endl;) return; } prevCurve = curve; prevXCv = cv; *out = cv; ++out; } } template <class OutpoutIterator> void AddVerticalCurveToOutput(OutpoutIterator out, const X_curve_2 &cv) { if ( m_overlapping ) { *out = cv; ++out; } else { if ( VerticalSubCurveExists(cv)) { SL_DEBUG(std::cout << " curve already reported... " << std::endl;) return; } m_verticalSubCurves.push_back(cv); *out = cv; ++out; } } bool isPointInCurveInterior(const X_curve_2 &c, const Point_2 &p) { if (! m_traits->curve_is_in_x_range(c,p) || m_traits->curve_get_point_status(c, p) != EQUAL) return false; if ( isEndPoint(p) ) return false; return true; } template <class OutpoutIterator> void HandleVerticalCurveTop(OutpoutIterator out, SweepLineGetPoints &tag) { SL_DEBUG(std::cout<<"HandleVerticalCurveTop... ";) if ( !m_currentEvent->doesContainVerticalCurve() ) { SL_DEBUG(std::cout<<"exiting\n ";) return; } SL_DEBUG(std::cout<<"\n ";) VerticalCurveList &vcurves = m_currentEvent->getVerticalCurves(); VerticalCurveListIter vciter = vcurves.begin(); while ( vciter != vcurves.end() ) { Subcurve *vcurve = *vciter; const Point_2 &topPoint = m_currentEvent->getPoint(); if ( vcurve->isBottomEnd(topPoint)) { SL_DEBUG(std::cout<<"this is the bottom. skipping.\n";) ++vciter; continue; } SL_DEBUG(std::cout<<"handling top point of vertical curve\n";) StatusLineIter slIter = m_statusLine->lower_bound(vcurve); if ( slIter != m_statusLine->end() ) { SL_DEBUG(std::cout<<"starting at curve \n";) SL_DEBUG((*slIter)->Print();) const Point_2 &bottomPoint = vcurve->getBottomEnd(); while (slIter != m_statusLine->end() && m_traits->curve_is_in_x_range((*slIter)->getCurve(), topPoint) && m_traits->curve_get_point_status((*slIter)->getCurve(), topPoint) == SMALLER && m_traits->curve_is_in_x_range((*slIter)->getCurve(), bottomPoint) && m_traits->curve_get_point_status((*slIter)->getCurve(), bottomPoint) == LARGER) { SL_DEBUG(std::cout<<"checking \n";) SL_DEBUG((*slIter)->Print();) if ( m_traits->compare_x((*slIter)->getLeftEnd(),topPoint) == EQUAL) { m_currentEvent->addVerticalCurveXPoint((*slIter)->getLeftEnd()); if ( !m_includeEndPoints && !isInternalXPoint((*slIter)->getLeftEnd())) { *out = (*slIter)->getLeftEnd(); ++out; m_found_intersection = true; } } ++slIter; } } ++vciter; } } template <class OutpoutIterator> void HandleLeftCurves(OutpoutIterator out, SweepLineGetPoints &tag) { SL_DEBUG(std::cout << "Handling left curve" << std::endl;) SL_DEBUG(m_currentEvent->Print();) const Point_2 &eventPoint = m_currentEvent->getPoint(); if ( !m_currentEvent->hasLeftCurves() ) { if (m_includeEndPoints || m_currentEvent->isInternalIntersectionPoint()) { *out = eventPoint; ++out; m_found_intersection = true; } return; } EventCurveIter leftCurveIter = m_currentEvent->leftCurvesBegin(); m_currentPos = m_prevPos; while ( leftCurveIter != m_currentEvent->leftCurvesEnd() ) { RemoveCurveFromStatusLine(*leftCurveIter); PRINT_ERASE((*leftCurveIter)); m_currentPos = m_prevPos; ++leftCurveIter; } if ( m_includeEndPoints || m_currentEvent->isInternalIntersectionPoint() ) { *out = eventPoint; ++out; m_found_intersection = true; } } #ifndef NDEBUG void PrintEventQueue(); void PrintSubCurves(); void PrintStatusLine(); void PrintVerticals(); #endif protected: Traits *m_traits; bool m_traitsOwner; bool m_overlapping; bool m_includeEndPoints; EventPtrContainer m_events; EventQueue *m_queue; SubCurveList m_subCurves; StatusLine *m_statusLine; CompareParams *m_comp_param; Point_2 m_currentPos; Point_2 m_prevPos; Point_2 m_sweepLinePos; std::vector<X_curve_2> m_xcurves; Event *m_currentEvent; EventList m_miniq; SubCurveList m_verticals; CurveList m_verticalSubCurves; bool m_found_intersection; int m_curveId; #ifndef NDEBUG int m_eventId; #endif }; template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: ~Sweep_line_tight_2() { if ( m_traitsOwner ) delete m_traits; for ( SubCurveListIter sci = m_subCurves.begin() ; sci != m_subCurves.end() ; ++sci) { delete *sci; } for ( EventPtrContainerIter ei = m_events.begin(); ei != m_events.end() ; ++ei) { delete *ei; } delete m_queue; delete m_statusLine; delete m_comp_param; } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: Init(CurveInputIterator begin, CurveInputIterator end) { PointLess pred(m_traits); m_queue = new EventQueue(pred); m_comp_param = new CompareParams(m_traits); StatusLineCurveLess slcurveless(m_comp_param); m_statusLine = new StatusLine(slcurveless); #ifndef NDEBUG m_eventId = 0; #endif m_curveId = 0; int count = 0; CurveInputIterator iter; for ( iter = begin ; iter != end ; ++iter) { if ( m_traits->is_x_monotone(*iter) ) InitCurve(*iter); else { std::list<X_curve_2> xcurves; m_traits->make_x_monotone(*iter, xcurves); SL_DEBUG( std::cout << "curve " << *iter << " was split into " << xcurves.size() << " curves." << std::endl; ) for (typename std::list<X_curve_2>::iterator i = xcurves.begin(); i != xcurves.end() ; ++i ) { m_xcurves.push_back(*i); InitCurve(m_xcurves[count]); count++; } } } } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: InitCurve(X_curve_2 &curve) { const Point_2 &source = m_traits->curve_source(curve); const Point_2 &target = m_traits->curve_target(curve); Event *e = 0; Subcurve *subCv = new Subcurve(m_curveId++, curve, &m_currentPos, m_traits); m_subCurves.push_back(subCv); EventQueueIter eventIter = m_queue->find(source); if ( eventIter != m_queue->end() ) { SL_DEBUG(std::cout << "event " << source << " already exists\n";) e = eventIter->second; } else { e = new Event(source, m_traits); #ifndef NDEBUG e->id = m_eventId++; #endif m_events.push_back(e); m_queue->insert(EventQueueValueType(source, e)); } e->addCurve(subCv); PRINT_NEW_EVENT(source, e); eventIter = m_queue->find(target); if ( eventIter != m_queue->end() ) { SL_DEBUG(std::cout << "event " << target << " already exists\n";) e = eventIter->second; } else { e = new Event(target, m_traits); #ifndef NDEBUG e->id = m_eventId++; #endif m_events.push_back(e); m_queue->insert(EventQueueValueType(target, e)); } e->addCurve(subCv); PRINT_NEW_EVENT(target, e); } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: FirstPass() { if ( m_statusLine->size() == 0 ) return; const Point_2& p = m_currentEvent->getPoint(); DBG("First pass"); EventCurveIter rightIter = m_currentEvent->rightCurvesBegin(); m_currentPos = m_sweepLinePos; m_comp_param->m_compare_func = 0; while ( rightIter != m_currentEvent->rightCurvesEnd()) { if ( !(*rightIter)->isEndPoint(p)) { ++rightIter; continue; } #if 0 StatusLineIter slIter = m_statusLine->begin(); while ( slIter != m_statusLine->end() ) { if (m_traits->curve_is_in_x_range((*slIter)->getCurve(), p) && m_traits->curve_get_point_status((*slIter)->getCurve(), p)==EQUAL && !(*slIter)->isEndPoint(p)) { m_currentEvent->addCurveToRight(*slIter); m_currentEvent->addCurveToLeft(*slIter, m_prevPos); } ++slIter; } #else StatusLineIter slIter = m_statusLine->lower_bound(*rightIter); StatusLineIter prev = slIter; StatusLineIter next = slIter; if ( slIter != m_statusLine->begin() ) { --prev; while (m_traits->curve_is_in_x_range((*prev)->getCurve(), p) && m_traits->curve_get_point_status((*prev)->getCurve(), p)==EQUAL && !(*prev)->isEndPoint(p)) { m_currentEvent->addCurveToRight(*prev); m_currentEvent->addCurveToLeft(*prev, m_prevPos); if ( prev == m_statusLine->begin() ) break; --prev; } } if ( slIter != m_statusLine->end() ) { while (m_traits->curve_is_in_x_range((*next)->getCurve(), p) && m_traits->curve_get_point_status((*next)->getCurve(), p)==EQUAL && !(*next)->isEndPoint(p)) { m_currentEvent->addCurveToRight(*next); m_currentEvent->addCurveToLeft(*next, m_prevPos); ++next; if ( next == m_statusLine->end() ) break; } } #endif ++rightIter; } m_comp_param->m_compare_func = 1; SL_DEBUG(m_currentEvent->Print();) SL_DEBUG(std::cout << "First pass - done\n" ;) } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: HandleVerticalCurveBottom(SweepLineGetSubCurves &tag) { SL_DEBUG(std::cout<<"\nHandleVerticalCurveBottom... (" << m_currentEvent->getPoint() << ")\n";) if ( !m_currentEvent->doesContainVerticalCurve() ) { SL_DEBUG(std::cout<<" - not vertical - exiting\n ";) return; } SL_DEBUG(std::cout<<"\n ";) VerticalCurveList &vcurves = m_currentEvent->getVerticalCurves(); VerticalCurveListIter vciter = vcurves.begin(); const Point_2 &currentPoint = m_currentEvent->getPoint(); SL_DEBUG(std::cout << vcurves.size() << " vertical curves in event\n";) while ( vciter != vcurves.end() ) { Subcurve *vcurve = *vciter; SL_DEBUG(std::cout << "working on " << vcurve->getCurve() << "\n";) if ( vcurve->isTopEnd(currentPoint)) { vciter++; continue; } SL_DEBUG(std::cout<<"handling bottom point of vertical curve\n";) StatusLineIter slIter = m_statusLine->lower_bound(vcurve); if ( slIter == m_statusLine->end() ) { SL_DEBUG(std::cout<<"no curves intersecting. exiting\n";) vciter++; continue; } SL_DEBUG(std::cout<<"starting at curve \n";) SL_DEBUG((*slIter)->Print();) const Point_2 &topEnd = vcurve->getTopEnd(); EventQueueIter topEndEventIter = m_queue->find(topEnd); assert(topEndEventIter!=m_queue->end()); Event *topEndEvent = topEndEventIter->second; bool lastEventCreatedHere = false; Event *prevEvent = 0; while (slIter != m_statusLine->end() && (! m_traits->curve_is_in_x_range((*slIter)->getCurve(), topEnd) || m_traits->curve_get_point_status((*slIter)->getCurve(), topEnd) != LARGER) && (! m_traits->curve_is_in_x_range((*slIter)->getCurve(), currentPoint) || m_traits->curve_get_point_status((*slIter)->getCurve(), currentPoint) != SMALLER)) { SL_DEBUG(std::cout<<"intersecting with \n";) SL_DEBUG((*slIter)->Print();) if ( HandleVerticalCurveXAtEnd(vcurve, *slIter, topEndEvent, tag)) { ++slIter; continue; } const X_curve_2 &cv1 = vcurve->getCurve(); const X_curve_2 &cv2 = (*slIter)->getCurve(); Point_2 xp; bool res = m_traits->nearest_intersection_to_right(cv1, cv2, currentPoint, xp, xp); SL_DEBUG(assert(res==true);) res = 0; EventQueueIter eqi = m_queue->find(xp); Event *e = 0; if ( eqi == m_queue->end() ) { e = new Event(xp, m_traits); #ifndef NDEBUG e->id = m_eventId++; #endif m_events.push_back(e); e->addCurveToLeft(*slIter, m_sweepLinePos); e->addCurveToRight(*slIter); PRINT_NEW_EVENT(xp, e); m_queue->insert(EventQueueValueType(xp, e)); lastEventCreatedHere = true; } else { e = eqi->second; if ( e == prevEvent ) { if ( lastEventCreatedHere ) { if ( !(*slIter)->isLeftEnd(xp) ) e->addCurveToLeft(*slIter, m_sweepLinePos); if ( !(*slIter)->isRightEnd(xp) ) e->addCurveToRight(*slIter); } } else lastEventCreatedHere = false; SL_DEBUG(std::cout << "Updating event \n";) SL_DEBUG(e->Print();) } topEndEvent->addVerticalCurveXPoint(xp); ++slIter; prevEvent = e; } vciter++; } SL_DEBUG(std::cout<<"Done Handling vertical\n";) } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: HandleVerticalOverlapCurves() { SL_DEBUG(std::cout<<"\nHandleVerticalOverlapCurves... (" << m_currentEvent->getPoint() << ")";) if ( !m_currentEvent->doesContainVerticalCurve() ) { SL_DEBUG(std::cout << "no vertical - exiting\n";) return; } SL_DEBUG(std::cout << "\n";) SL_DEBUG(PrintVerticals();) const Point_2 &point = m_currentEvent->getPoint(); SubCurveListIter iter = m_verticals.begin(); while ( iter != m_verticals.end() ) { Subcurve *curve = *iter; if (m_traits->curve_is_in_x_range(curve->getCurve(), point) && m_traits->curve_get_point_status(curve->getCurve(), point) == SMALLER) { iter = m_verticals.erase(iter); } else if (!curve->isEndPoint(point)) { EventQueueIter eventIter = m_queue->find(curve->getTopEnd()); assert(eventIter!=m_queue->end()); (eventIter->second)->addVerticalCurveXPoint(point, true); m_currentEvent->markInternalIntersectionPoint(); ++iter; } else { ++iter; } } VerticalCurveList &vcurves = m_currentEvent->getVerticalCurves(); VerticalCurveListIter vciter = vcurves.begin(); while ( vciter != vcurves.end() ) { Subcurve *vcurve = *vciter; if ( vcurve->isBottomEnd(point) ) { m_verticals.push_back(vcurve); } ++vciter; } } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: HandleRightCurves() { SL_DEBUG(std::cout << "Handling right curves (" ;) SL_DEBUG(std::cout << m_currentEvent->getPoint() << ")\n";) int numRightCurves = m_currentEvent->getNumRightCurves(); if ( numRightCurves == 0 ) return; m_currentPos = m_sweepLinePos; if ( numRightCurves == 1 ) { SL_DEBUG(std::cout << " - beginning of curve " << std::endl;) SL_DEBUG( Subcurve *tmp1 = *(m_currentEvent->rightCurvesBegin()); PRINT_INSERT(tmp1); ) std::pair<StatusLineIter, bool> tmp = m_statusLine->insert(*(m_currentEvent->rightCurvesBegin())); StatusLineIter slIter = tmp.first; SL_DEBUG(PrintStatusLine();) if ( m_statusLine->size() == 1 ) return; StatusLineIter prev = slIter; StatusLineIter next = slIter; ++next; SubCurveList mylist; if ( slIter != m_statusLine->begin() ) { --prev; StatusLineIter tmp = prev; mylist.push_back(*prev); while ( tmp != m_statusLine->begin() ) { --tmp; if ( DoCurvesOverlap(*prev, *tmp) ) mylist.push_back(*tmp); else break; } } if ( next != m_statusLine->end() ) { StatusLineIter tmp = next; mylist.push_back(*next); ++tmp; while ( tmp != m_statusLine->end() ) { if ( DoCurvesOverlap(*next, *tmp) ) { mylist.push_back(*tmp); ++tmp; } else break; } } IntersectCurveGroup(*(m_currentEvent->rightCurvesBegin()), mylist); } else { SubCurveList mylist; SubCurveList prevlist; SubCurveList currentlist; SL_DEBUG(std::cout << " - intersection point " << std::endl;) EventCurveIter firstOne = m_currentEvent->rightCurvesBegin(); EventCurveIter lastOne = m_currentEvent->rightCurvesEnd(); --lastOne; EventCurveIter rightCurveEnd = m_currentEvent->rightCurvesEnd(); PRINT_INSERT(*firstOne); std::pair<StatusLineIter, bool> tmp = m_statusLine->insert(*firstOne); StatusLineIter slIter = tmp.first; SL_DEBUG(PrintStatusLine();) if ( slIter != m_statusLine->begin() ) { StatusLineIter prev = slIter; --prev; StatusLineIter tmp = prev; prevlist.push_back(*prev); while ( tmp != m_statusLine->begin() ) { --tmp; if ( DoCurvesOverlap(*prev, *tmp)) prevlist.push_back(*tmp); else break; } IntersectCurveGroup(*slIter, prevlist); } currentlist.push_back(*firstOne); EventCurveIter currentOne = firstOne; ++currentOne; EventCurveIter prevOne = firstOne; while ( currentOne != rightCurveEnd ) { m_currentPos = m_sweepLinePos; PRINT_INSERT(*currentOne); ++slIter; slIter = m_statusLine->insert(slIter, *currentOne); SL_DEBUG(PrintStatusLine();); if ( DoCurvesOverlap(*currentOne, *prevOne)) { IntersectCurveGroup(*currentOne, currentlist); currentlist.push_back(*currentOne); } else { prevlist = currentlist; currentlist.clear(); currentlist.push_back(*currentOne); } IntersectCurveGroup(*currentOne, prevlist); prevOne = currentOne; ++currentOne; } lastOne = currentOne; --lastOne; m_currentPos = m_sweepLinePos; PRINT_INSERT(*lastOne); SL_DEBUG(PrintStatusLine();) StatusLineIter next = slIter; ++next; if ( next != m_statusLine->end() ) { IntersectCurveGroup(*next, currentlist); StatusLineIter tmp = next; ++tmp; while ( tmp != m_statusLine->end() ) { if ( DoCurvesOverlap(*next, *tmp)) { IntersectCurveGroup(*tmp, currentlist); ++tmp; } else break; } } } } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: IntersectCurveGroup(Subcurve *c1, SubCurveList &mylist) { SL_DEBUG(std::cout << "Intersecting with " << mylist.size() << " curves\n";) SubCurveListIter i = mylist.begin(); while ( i != mylist.end()) { Intersect(c1, *i); ++i; } } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: RemoveCurveFromStatusLine(Subcurve *leftCurve) { SL_DEBUG(std::cout << "RemoveCurveFromStatusLine\n";) SL_DEBUG(PrintStatusLine();) SL_DEBUG(leftCurve->Print();) StatusLineIter sliter = m_statusLine->find(leftCurve); if ( !leftCurve->isEndPoint(m_currentEvent->getPoint())) { m_statusLine->erase(sliter); return; } m_currentPos = m_prevPos; assert(sliter!=m_statusLine->end()); StatusLineIter end = m_statusLine->end(); --end; if ( sliter != m_statusLine->begin() && sliter != end ) { SubCurveList mylist; StatusLineIter prev = sliter; --prev; StatusLineIter tmp = prev; mylist.push_back(*prev); while ( tmp != m_statusLine->begin() ) { --tmp; if ( DoCurvesOverlap(*prev, *tmp)) mylist.push_back(*tmp); else break; } StatusLineIter next = sliter; ++next; tmp = next; IntersectCurveGroup(*tmp, mylist); ++tmp; while ( tmp != m_statusLine->end() ) { if ( DoCurvesOverlap(*next, *tmp)) { IntersectCurveGroup(*tmp, mylist); ++tmp; } else break; } } m_statusLine->erase(sliter); } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline bool Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: Intersect(Subcurve *c1, Subcurve *c2) { SL_DEBUG(std::cout << "Looking for intersection between:\n\t";) SL_DEBUG(c1->Print();) SL_DEBUG(std::cout << "\t";) SL_DEBUG(c2->Print();) SL_DEBUG(std::cout << "\n";) SL_DEBUG(std::cout << "relative to " << m_currentEvent->getPoint() << "\n";) if ( c1->getId() == c2->getId() ) { SL_DEBUG(std::cout << "same curve, returning....\n";) return false; } Subcurve *scv1 = c1; Subcurve *scv2 = c2; const X_curve_2 &cv1 = scv1->getCurve(); const X_curve_2 &cv2 = scv2->getCurve(); bool isOverlap = false; Point_2 xp, xp1; if ( m_traits->nearest_intersection_to_right(cv1, cv2, m_currentEvent->getPoint(), xp, xp1)) { if ( !m_traits->point_is_same(xp, xp1)) { if ( m_traits->compare_x(xp1, xp) == LARGER ) xp = xp1; SL_DEBUG(std::cout << "overlap detected\n";) isOverlap = true; } SL_DEBUG( std::cout << " a new event is created between:\n\t"; scv1->Print(); std::cout << "\t"; scv2->Print(); std::cout << "\trelative to (" << m_sweepLinePos << ")\n\t at (" << xp << ")" << std::endl; ) EventQueueIter eqi = m_queue->find(xp); Event *e = 0; if ( eqi == m_queue->end() ) { e = new Event(xp, m_traits); #ifndef NDEBUG e->id = m_eventId++; #endif m_events.push_back(e); e->addCurveToLeft(c1, m_sweepLinePos); e->addCurveToLeft(c2, m_sweepLinePos); e->addCurveToRight(c1); e->addCurveToRight(c2); PRINT_NEW_EVENT(xp, e); m_queue->insert(EventQueueValueType(xp, e)); return isOverlap; } else { SL_DEBUG(std::cout << "event already exists,updating.. (" << xp <<")\n";) e = eqi->second; if ( !scv1->isEndPoint(xp)) { e->addCurveToLeft(c1, m_sweepLinePos); e->addCurveToRight(c1); } if ( !scv2->isEndPoint(xp) ) { e->addCurveToLeft(c2, m_sweepLinePos); e->addCurveToRight(c2); } SL_DEBUG(e->Print();) } return isOverlap; } SL_DEBUG(std::cout << "not found 2\n";) return isOverlap; } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline bool Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: isInternalXPoint(const Point_2 &p) { EventListIter itt = m_miniq.begin(); while ( itt != m_miniq.end() ) { if ( m_traits->point_is_same(p, (*itt)->getPoint())) { if ((*itt)->isInternalIntersectionPoint()) return true; (*itt)->markInternalIntersectionPoint(); return false; } ++itt; } assert(0); return false; } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline bool Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: HandleVerticalCurveXAtEnd(Subcurve *vcurve, Subcurve *curve, Event *topEndEvent, SweepLineGetSubCurves tag) { const Point_2 &topEnd = vcurve->getTopEnd(); if (m_traits->curve_is_in_x_range(curve->getCurve(), topEnd) && m_traits->curve_get_point_status(curve->getCurve(), topEnd) == EQUAL) { if ( !curve->isLeftEnd(topEnd)) { topEndEvent->addCurveToLeft(curve, m_prevPos); } if ( ! curve->isRightEnd(topEnd)) { topEndEvent->addCurveToRight(curve); } return true; } const Point_2 &currentPoint = m_currentEvent->getPoint(); if (m_traits->curve_is_in_x_range((curve)->getCurve(), currentPoint) && m_traits->curve_get_point_status((curve)->getCurve(), currentPoint) == EQUAL) { if ( !(curve)->isLeftEnd(currentPoint)) { m_currentEvent->addCurveToLeft(curve, m_prevPos); } if ( ! (curve)->isRightEnd(currentPoint)) { m_currentEvent->addCurveToRight(curve); } return true;; } return false; } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline bool Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: DoCurvesOverlap(Subcurve *c1, Subcurve *c2) { SL_DEBUG(std::cout << "DoCurvesOverlap " << m_sweepLinePos << "\n" << "\t" << c1->getCurve() << "\n" << "\t" << c2->getCurve() << "\n";) #if 0 if ((m_traits->curve_compare_at_x(c1->getCurve(), c2->getCurve(), m_sweepLinePos) != EQUAL) || (m_traits->curve_compare_at_x_right(c1->getCurve(), c2->getCurve(), m_sweepLinePos) != EQUAL)) return false; #endif if ( m_traits->curves_overlap(c1->getCurve(),c2->getCurve()) ) return true; return false; } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline bool Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: SimilarCurves(const X_curve_2 &a, const X_curve_2 &b) { if ( m_traits->curve_is_same(a, b)) return true; if ( m_traits->curve_is_same(m_traits->curve_flip(a), b)) return true; return false; } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline bool Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: VerticalSubCurveExists(const X_curve_2 &a) { for (typename std::list<X_curve_2>::iterator iter = m_verticalSubCurves.begin() ; iter != m_verticalSubCurves.end() ; ++iter) { if (SimilarCurves(*iter, a)) return true; } return false; } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: HandleVerticalCurveBottom(SweepLineGetPoints &tag) { SL_DEBUG(std::cout<<"HandleVerticalCurveBottom... ";) if ( !m_currentEvent->doesContainVerticalCurve() ) { SL_DEBUG(std::cout<<"exiting\n ";) return; } SL_DEBUG(std::cout<<"\n ";) VerticalCurveList &vcurves = m_currentEvent->getVerticalCurves(); VerticalCurveListIter vciter = vcurves.begin(); const Point_2 &currentPoint = m_currentEvent->getPoint(); while ( vciter != vcurves.end() ) { Subcurve *vcurve = *vciter; if ( vcurve->isTopEnd(currentPoint)) { ++vciter; continue; } SL_DEBUG(std::cout<<"handling bottom point of vertical curve\n";); StatusLineIter slIter = m_statusLine->lower_bound(vcurve); if ( slIter == m_statusLine->end() ) { SL_DEBUG(std::cout<<"no curves intersecting. exiting\n";); ++vciter; continue; } SL_DEBUG(std::cout<<"starting at curve \n";); SL_DEBUG((*slIter)->Print();); const Point_2 &topEnd = vcurve->getTopEnd(); EventQueueIter topEndEventIter = m_queue->find(topEnd); assert(topEndEventIter!=m_queue->end()); Event *topEndEvent = topEndEventIter->second; while (slIter != m_statusLine->end() && (! m_traits->curve_is_in_x_range((*slIter)->getCurve(), topEnd) || m_traits->curve_get_point_status((*slIter)->getCurve(), topEnd) != LARGER) && (! m_traits->curve_is_in_x_range((*slIter)->getCurve(), currentPoint) || m_traits->curve_get_point_status((*slIter)->getCurve(), currentPoint) != SMALLER)) { SL_DEBUG(std::cout<<"intersecting with \n";) SL_DEBUG((*slIter)->Print();) if ( HandleVerticalCurveXAtEnd(vcurve, *slIter, topEndEvent, tag)) { ++slIter; continue; } Point_2 xp; bool res = m_traits->nearest_intersection_to_right(vcurve->getCurve(), (*slIter)->getCurve(), currentPoint, xp, xp); SL_DEBUG(assert(res==true);) res = 0; EventQueueIter eqi = m_queue->find(xp); Event *e = 0; if ( eqi == m_queue->end() ) { e = new Event(xp, m_traits); #ifndef NDEBUG e->id = m_eventId++; #endif m_events.push_back(e); e->addCurveToLeft(*slIter, m_sweepLinePos); e->addCurveToRight(*slIter); PRINT_NEW_EVENT(xp, e); m_queue->insert(EventQueueValueType(xp, e)); } else { e = eqi->second; e->markInternalIntersectionPoint(); SL_DEBUG(std::cout << "Updating event \n";) SL_DEBUG(e->Print();) e->addCurve(vcurve); } topEndEvent->addVerticalCurveXPoint(xp); ++slIter; } ++vciter; } SL_DEBUG(std::cout<<"Done Handling vertical\n";) } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline bool Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: HandleVerticalCurveXAtEnd(Subcurve *vcurve, Subcurve *curve, Event *topEndEvent, SweepLineGetPoints tag) { const Point_2 &topEnd = vcurve->getTopEnd(); if (m_traits->curve_is_in_x_range((curve)->getCurve(), topEnd) && m_traits->curve_get_point_status((curve)->getCurve(), topEnd) == EQUAL) { if ( !curve->isEndPoint(topEnd)) { topEndEvent->markInternalIntersectionPoint(); } return true; } if (m_traits->curve_is_in_x_range((curve)->getCurve(), m_currentEvent->getPoint()) && m_traits->curve_get_point_status((curve)->getCurve(), m_currentEvent->getPoint()) == EQUAL) { if ( !curve->isEndPoint(m_currentEvent->getPoint())) { m_currentEvent->markInternalIntersectionPoint(); } return true; } return false; } #ifndef NDEBUG template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: PrintEventQueue() { SL_DEBUG(std::cout << std::endl << "Event queue: " << std::endl;) EventQueueIter iter = m_queue->begin(); while ( iter != m_queue->end() ) { SL_DEBUG(std::cout << "Point (" << iter->first << ")" << std::endl;) Event *e = iter->second; e->Print(); ++iter; } SL_DEBUG(std::cout << "--------------------------------" << std::endl;) } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: PrintSubCurves() { SL_DEBUG(std::cout << std::endl << "Sub curves: " << std::endl;) SubCurveListIter iter = m_subCurves.begin(); while ( iter != m_subCurves.end() ) { (*iter)->Print(); ++iter; } } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: PrintStatusLine() { if ( m_statusLine->size() == 0) { std::cout << std::endl << "Status line: empty" << std::endl; return; } std::cout << std::endl << "Status line: (" << m_currentPos << ")" << std::endl; StatusLineIter iter = m_statusLine->begin(); while ( iter != m_statusLine->end() ) { (*iter)->Print(); ++iter; } std::cout << "Status line - end" << std::endl; } template <class CurveInputIterator, class SweepLineTraits_2, class SweepEvent, class CurveWrap> inline void Sweep_line_tight_2<CurveInputIterator,SweepLineTraits_2,SweepEvent,CurveWrap>:: PrintVerticals() { if ( m_verticals.size() == 0) { std::cout << std::endl << "Verticals: empty" << std::endl; return; } std::cout << std::endl << "Verticals: " << m_verticals.size() << " (" << m_currentEvent->getPoint() << ")" << std::endl; SubCurveListIter iter = m_verticals.begin(); while ( iter != m_verticals.end() ) { (*iter)->Print(); ++iter; } std::cout << "Verticals - end" << std::endl; } #endif CGAL_END_NAMESPACE #endif
#ifndef GMX_SELECTION_NBSEARCH_H #define GMX_SELECTION_NBSEARCH_H #include <memory> #include <vector> #include "gromacs/math/vec.h" #include "gromacs/math/vectypes.h" #include "gromacs/utility/arrayref.h" #include "gromacs/utility/classhelpers.h" #include "gromacs/utility/gmxassert.h" #include "gromacs/utility/real.h" struct t_blocka; struct t_pbc; namespace gmx { namespace internal { class AnalysisNeighborhoodSearchImpl; class AnalysisNeighborhoodPairSearchImpl; }; class AnalysisNeighborhoodSearch; class AnalysisNeighborhoodPairSearch; class AnalysisNeighborhoodPositions { public: AnalysisNeighborhoodPositions(const rvec &x) : count_(1), index_(-1), x_(&x), exclusionIds_(nullptr), indices_(nullptr) { } AnalysisNeighborhoodPositions(const rvec x[], int count) : count_(count), index_(-1), x_(x), exclusionIds_(nullptr), indices_(nullptr) { } AnalysisNeighborhoodPositions(const std::vector<RVec> &x) : count_(x.size()), index_(-1), x_(as_rvec_array(x.data())), exclusionIds_(nullptr), indices_(nullptr) { } AnalysisNeighborhoodPositions & exclusionIds(ConstArrayRef<int> ids) { GMX_ASSERT(static_cast<int>(ids.size()) == count_, "Exclusion id array should match the number of positions"); exclusionIds_ = ids.data(); return *this; } AnalysisNeighborhoodPositions & indexed(ConstArrayRef<int> indices) { count_ = indices.size(); indices_ = indices.data(); return *this; } AnalysisNeighborhoodPositions &selectSingleFromArray(int index) { GMX_ASSERT(index >= 0 && index < count_, "Invalid position index"); index_ = index; return *this; } private: int count_; int index_; const rvec *x_; const int *exclusionIds_; const int *indices_; friend class internal::AnalysisNeighborhoodSearchImpl; friend class internal::AnalysisNeighborhoodPairSearchImpl; }; class AnalysisNeighborhood { public: enum SearchMode { eSearchMode_Automatic, eSearchMode_Simple, eSearchMode_Grid }; AnalysisNeighborhood(); ~AnalysisNeighborhood(); void setCutoff(real cutoff); void setXYMode(bool bXY); void setTopologyExclusions(const t_blocka *excls); void setMode(SearchMode mode); SearchMode mode() const; AnalysisNeighborhoodSearch initSearch(const t_pbc *pbc, const AnalysisNeighborhoodPositions &positions); private: class Impl; PrivateImplPointer<Impl> impl_; }; class AnalysisNeighborhoodPair { public: AnalysisNeighborhoodPair() : refIndex_(-1), testIndex_(0), distance2_(0.0) { clear_rvec(dx_); } AnalysisNeighborhoodPair(int refIndex, int testIndex, real distance2, const rvec dx) : refIndex_(refIndex), testIndex_(testIndex), distance2_(distance2) { copy_rvec(dx, dx_); } bool isValid() const { return refIndex_ >= 0; } int refIndex() const { GMX_ASSERT(isValid(), "Accessing invalid object"); return refIndex_; } int testIndex() const { GMX_ASSERT(isValid(), "Accessing invalid object"); return testIndex_; } real distance2() const { GMX_ASSERT(isValid(), "Accessing invalid object"); return distance2_; } const rvec &dx() const { GMX_ASSERT(isValid(), "Accessing invalid object"); return dx_; } private: int refIndex_; int testIndex_; real distance2_; rvec dx_; }; class AnalysisNeighborhoodSearch { public: typedef std::shared_ptr<internal::AnalysisNeighborhoodSearchImpl> ImplPointer; AnalysisNeighborhoodSearch(); explicit AnalysisNeighborhoodSearch(const ImplPointer &impl); void reset(); AnalysisNeighborhood::SearchMode mode() const; bool isWithin(const AnalysisNeighborhoodPositions &positions) const; real minimumDistance(const AnalysisNeighborhoodPositions &positions) const; AnalysisNeighborhoodPair nearestPoint(const AnalysisNeighborhoodPositions &positions) const; AnalysisNeighborhoodPairSearch startPairSearch(const AnalysisNeighborhoodPositions &positions) const; private: typedef internal::AnalysisNeighborhoodSearchImpl Impl; ImplPointer impl_; }; class AnalysisNeighborhoodPairSearch { public: typedef std::shared_ptr<internal::AnalysisNeighborhoodPairSearchImpl> ImplPointer; explicit AnalysisNeighborhoodPairSearch(const ImplPointer &impl); bool findNextPair(AnalysisNeighborhoodPair *pair); void skipRemainingPairsForTestPosition(); private: ImplPointer impl_; }; } #endif
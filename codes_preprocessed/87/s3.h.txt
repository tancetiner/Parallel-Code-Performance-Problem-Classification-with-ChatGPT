#ifndef TILEDB_S3_H #define TILEDB_S3_H #ifdef HAVE_S3 #include "tiledb/common/logger.h" #include "tiledb/common/status.h" #include "tiledb/common/thread_pool.h" #include "tiledb/sm/buffer/buffer.h" #include "tiledb/sm/config/config.h" #include "tiledb/sm/filesystem/s3_thread_pool_executor.h" #include "tiledb/sm/misc/constants.h" #include "tiledb/sm/misc/uri.h" #include "tiledb/sm/stats/stats.h" #include <aws/core/Aws.h> #include <aws/core/auth/AWSCredentialsProviderChain.h> #include <aws/core/client/ClientConfiguration.h> #include <aws/core/client/RetryStrategy.h> #include <aws/core/http/HttpClient.h> #include <aws/core/utils/HashingUtils.h> #include <aws/core/utils/Outcome.h> #include <aws/core/utils/StringUtils.h> #include <aws/core/utils/UUID.h> #include <aws/core/utils/memory/stl/AWSStringStream.h> #include <aws/core/utils/ratelimiter/DefaultRateLimiter.h> #include <aws/core/utils/threading/Executor.h> #include <aws/identity-management/auth/STSAssumeRoleCredentialsProvider.h> #include <aws/s3/S3Client.h> #include <aws/s3/model/CompleteMultipartUploadRequest.h> #include <aws/s3/model/CopyObjectRequest.h> #include <aws/s3/model/CreateBucketRequest.h> #include <aws/s3/model/DeleteBucketRequest.h> #include <aws/s3/model/DeleteObjectRequest.h> #include <aws/s3/model/GetBucketLocationRequest.h> #include <aws/s3/model/GetObjectRequest.h> #include <aws/s3/model/HeadBucketRequest.h> #include <aws/s3/model/HeadObjectRequest.h> #include <aws/s3/model/ListObjectsRequest.h> #include <aws/s3/model/PutObjectRequest.h> #include <aws/s3/model/UploadPartRequest.h> #include <sys/types.h> #include <mutex> #include <string> #include <vector> using namespace tiledb::common; namespace tiledb { namespace sm { class S3 { public: S3(); ~S3(); Status init(const Config& config, ThreadPool* thread_pool); Status create_bucket(const URI& bucket) const; Status disconnect(); Status empty_bucket(const URI& bucket) const; Status flush_object(const URI& uri); Status is_empty_bucket(const URI& bucket, bool* is_empty) const; Status is_bucket(const URI& uri, bool* exists) const; Status is_dir(const URI& uri, bool* exists) const; Status is_object(const URI& uri, bool* exists) const; Status ls( const URI& prefix, std::vector<std::string>* paths, const std::string& delimiter = "/", int max_paths = -1) const; Status move_object(const URI& old_uri, const URI& new_uri); Status move_dir(const URI& old_uri, const URI& new_uri); Status copy_file(const URI& old_uri, const URI& new_uri); Status copy_dir(const URI& old_uri, const URI& new_uri); Status object_size(const URI& uri, uint64_t* nbytes) const; Status read( const URI& uri, off_t offset, void* buffer, uint64_t length, uint64_t read_ahead_length, uint64_t* length_returned) const; Status remove_bucket(const URI& bucket) const; Status remove_object(const URI& uri) const; Status remove_dir(const URI& prefix) const; Status touch(const URI& uri) const; Status write(const URI& uri, const void* buffer, uint64_t length); private: enum State { UNINITIALIZED, INITIALIZED, DISCONNECTED }; class S3RetryStrategy : public Aws::Client::RetryStrategy { public: S3RetryStrategy(const uint64_t max_retries, const uint64_t scale_factor) : max_retries_(max_retries) , scale_factor_(scale_factor) { } bool ShouldRetry( const Aws::Client::AWSError<Aws::Client::CoreErrors>& error, long attempted_retries) const override { if (error.GetErrorType() == Aws::Client::CoreErrors::SLOW_DOWN) { if (attempted_retries == 100) { return false; } STATS_ADD_COUNTER( stats::Stats::CounterType::VFS_S3_SLOW_DOWN_RETRIES, 1) return true; } if (static_cast<uint64_t>(attempted_retries) >= max_retries_) return false; return error.ShouldRetry(); } long CalculateDelayBeforeNextRetry( const Aws::Client::AWSError<Aws::Client::CoreErrors>& error, long attempted_retries) const override { if (error.GetErrorType() == Aws::Client::CoreErrors::SLOW_DOWN) { return 1250 + rand() % 500; } if (attempted_retries == 0) return 0; return (1L << attempted_retries) * static_cast<long>(scale_factor_); } private: uint64_t max_retries_; uint64_t scale_factor_; }; struct MakeUploadPartCtx { MakeUploadPartCtx( Aws::S3::Model::UploadPartOutcomeCallable&& in_upload_part_outcome_callable, const int in_upload_part_num) : upload_part_outcome_callable( std::move(in_upload_part_outcome_callable)) , upload_part_num(in_upload_part_num) { } Aws::S3::Model::UploadPartOutcomeCallable upload_part_outcome_callable; const int upload_part_num; }; struct MultiPartUploadState { MultiPartUploadState( const int in_part_number, Aws::String&& in_bucket, Aws::String&& in_key, Aws::String&& in_upload_id, std::map<int, Aws::S3::Model::CompletedPart>&& in_completed_parts) : part_number_(in_part_number) , bucket_(std::move(in_bucket)) , key_(std::move(in_key)) , upload_id_(std::move(in_upload_id)) , completed_parts_(std::move(in_completed_parts)) , st_(Status::Ok()) , mtx_(){}; MultiPartUploadState(MultiPartUploadState&& other) { std::lock_guard<std::mutex> lck(other.mtx_); this->part_number_ = other.part_number_; this->bucket_ = std::move(other.bucket_); this->key_ = std::move(other.key_); this->upload_id_ = std::move(other.upload_id_); this->completed_parts_ = std::move(other.completed_parts_); this->st_ = other.st_; } MultiPartUploadState(const MultiPartUploadState& other) { this->part_number_ = other.part_number_; this->bucket_ = other.bucket_; this->key_ = other.key_; this->upload_id_ = other.upload_id_; this->completed_parts_ = other.completed_parts_; this->st_ = other.st_; } uint64_t part_number_; Aws::String bucket_; Aws::String key_; Aws::String upload_id_; std::map<int, Aws::S3::Model::CompletedPart> completed_parts_; Status st_; mutable std::mutex mtx_; uint64_t part_number() const; void part_number(const uint64_t& part_number); Aws::String bucket() const; void bucket(const Aws::String& bucket); Aws::String key() const; void key(const Aws::String& key); Aws::String upload_id() const; void upload_id(const Aws::String& upload_id); std::map<int, Aws::S3::Model::CompletedPart> completed_parts() const; void completed_parts_emplace( const int& part_num, const Aws::S3::Model::CompletedPart& part); Status st() const; void st(const Status& st); }; State state_; mutable std::shared_ptr<Aws::S3::S3Client> client_; mutable std::mutex client_init_mtx_; mutable std::unique_ptr<Aws::Client::ClientConfiguration> client_config_; mutable std::shared_ptr<S3ThreadPoolExecutor> s3_tp_executor_; mutable std::shared_ptr<Aws::Auth::AWSCredentialsProvider> credentials_provider_; uint64_t file_buffer_size_; Aws::SDKOptions options_; std::unordered_map<std::string, MultiPartUploadState> multipart_upload_states_; std::mutex multipart_upload_mtx_; uint64_t max_parallel_ops_; uint64_t multipart_part_size_; std::unordered_map<std::string, Buffer*> file_buffers_; std::string region_; ThreadPool* vfs_thread_pool_; bool use_virtual_addressing_; bool use_multipart_upload_; Config config_; Aws::S3::Model::RequestPayer request_payer_; Status init_client() const; Status copy_object(const URI& old_uri, const URI& new_uri); Status fill_file_buffer( Buffer* buff, const void* buffer, uint64_t length, uint64_t* nbytes_filled); std::string add_front_slash(const std::string& path) const; std::string remove_front_slash(const std::string& path) const; std::string remove_trailing_slash(const std::string& path) const; Status flush_file_buffer(const URI& uri, Buffer* buff, bool last_part); Status get_file_buffer(const URI& uri, Buffer** buff); Status initiate_multipart_request(Aws::Http::URI aws_uri); std::string join_authority_and_path( const std::string& authority, const std::string& path) const; Status is_object( const Aws::String& bucket_name, const Aws::String& object_key, bool* exists) const; Status wait_for_object_to_propagate( const Aws::String& bucketName, const Aws::String& objectKey) const; Status wait_for_object_to_be_deleted( const Aws::String& bucketName, const Aws::String& objectKey) const; Status wait_for_bucket_to_be_created(const URI& bucket_uri) const; Aws::S3::Model::CompleteMultipartUploadRequest make_multipart_complete_request(const MultiPartUploadState& state); Aws::S3::Model::AbortMultipartUploadRequest make_multipart_abort_request( const MultiPartUploadState& state); template <typename R, typename E> Status finish_flush_object( const Aws::Utils::Outcome<R, E>& outcome, const URI& uri, Buffer* const buff); Status flush_direct(const URI& uri); Status write_multipart( const URI& uri, const void* buffer, uint64_t length, bool last_part); MakeUploadPartCtx make_upload_part_req( const Aws::Http::URI& aws_uri, const void* buffer, uint64_t length, const Aws::String& upload_id, int upload_part_num); Status get_make_upload_part_req( const URI& uri, const std::string& uri_path, MakeUploadPartCtx& ctx); }; } } #endif #endif
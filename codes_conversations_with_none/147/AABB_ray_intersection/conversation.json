{"messages": [{"role": "system", "content": "You are a parallel computing expert. I will provide you a source code in C or C++ and I want you to classify if there is an inefficiency problem in the code. If there is an problem, I want you to classify this problem from the following list: ['Memory/Data locality', 'Micro-architectural inefficiency', 'Vector/SIMD parallelism', 'GPU parallelism', 'Instruction level parallelism', 'Task parallelism', 'small parallel region', 'Inefficeint thread mapping / inefficient block size / Load imbalance', 'Under-parallelization', 'Over-Parallelization', 'Unncessary locks', 'Unncessary strong memory consistency', 'Lock management overhead', 'Unnecessary synchronization', 'Unnecessary process communiction', 'Unnecessary operation/traversal/function call', 'Redundant operation', 'Expensive operation', 'Frequent  function call', 'Inefficient data-structure library', 'Usage of improper data type', 'memory leak', 'repreated memory allocation', 'Redundant memory allocation', 'Slower memory allocation library call', 'Insufficient memory', 'unnecessary data copy', 'sequential I/O operation', 'over parallelization', 'boundary condition check', 'Unintentional Programming logic error', 'Inefficiency due to new compiler version '] and return an answer with the following format and this format only, don't provide explanation: Type: classified_type. If you think there is no inefficiency in the program, return: Type: None"}, {"role": "user", "content": "// Copyright (c) 2015 INRIA Sophia-Antipolis (France).\n// All rights reserved.\n//\n// This file is part of CGAL (www.cgal.org).\n// You can redistribute it and/or modify it under the terms of the GNU\n// General Public License as published by the Free Software Foundation,\n// either version 3 of the License, or (at your option) any later version.\n//\n// Licensees holding a valid commercial license may use this file in\n// accordance with the commercial license agreement provided with the software.\n//\n// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE\n// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n//\n// $URL$\n// $Id$\n//\n//\n// Author(s) : Philipp Moeller\n//\n\n#ifndef CGAL_AABB_RAY_INTERSECTION_H\n#define CGAL_AABB_RAY_INTERSECTION_H\n\n#include <functional>\n#include <boost/optional.hpp>\n#include <boost/type_traits/is_same.hpp>\n#include <boost/variant/apply_visitor.hpp>\n#include <boost/heap/priority_queue.hpp>\n\n#include <CGAL/assertions.h>\n\nnamespace CGAL {\n\ntemplate<typename AABBTree, typename SkipFunctor>\nclass AABB_ray_intersection {\n  typedef typename AABBTree::AABB_traits AABB_traits;\n  typedef typename AABB_traits::Ray_3 Ray;\n  typedef typename AABBTree::template Intersection_and_primitive_id<Ray>::Type Ray_intersection_and_primitive_id;\n  typedef typename Ray_intersection_and_primitive_id::first_type Ray_intersection;\npublic:\n  AABB_ray_intersection(const AABBTree& tree) : tree_(tree) {}\n\n  boost::optional< Ray_intersection_and_primitive_id >\n  ray_intersection(const Ray& query, SkipFunctor skip) const {\n    // We hit the root, now continue on the children. Keep track of\n    // nb_primitives through a variable in each Node on the stack. In\n    // BVH_node::traversal this is done through the function parameter\n    // nb_primitives in the recursion.\n    typedef boost::heap::priority_queue< Node_ptr_with_ft, boost::heap::compare< std::greater<Node_ptr_with_ft> > >\n      Heap_type;\n\n    typename AABB_traits::Intersection\n      intersection_obj = tree_.traits().intersection_object();\n    typename AABB_traits::Do_intersect\n      do_intersect_obj = tree_.traits().do_intersect_object();\n    typename AABB_traits::Intersection_distance\n      intersection_distance_obj = tree_.traits().intersection_distance_object();\n    as_ray_param_visitor param_visitor = as_ray_param_visitor(&query);\n\n    Heap_type pq;\n    pq.reserve(tree_.size() / 2);\n    boost::optional< Ray_intersection_and_primitive_id >\n      intersection, /* the temporary for calculating the result */\n      p; /* the current best intersection */\n\n    // this is not the right way to do it, but using\n    // numeric_limits<FT>::{max,infinity} will not work with Epeck.\n    FT t = std::numeric_limits<double>::max();\n    // Start with the root node.\n    pq.push(Node_ptr_with_ft(tree_.root_node(), 0, tree_.size()));\n\n    while(!pq.empty() && pq.top().value < t) {\n      Node_ptr_with_ft current = pq.top();\n      pq.pop();\n\n      switch(current.nb_primitives) { // almost copy-paste from BVH_node::traversal\n      case 2: // Left & right child both leaves\n      {\n        //left child\n        if(!skip(current.node->left_data().id()) && do_intersect_obj(query, current.node->left_data())) {\n          intersection = intersection_obj(query, current.node->left_data());\n          if(intersection) {\n            FT ray_distance = boost::apply_visitor(param_visitor, intersection->first);\n            if(ray_distance < t) {\n              t = ray_distance;\n              p = intersection;\n            }\n          }\n        }\n\n        // right child\n        if(!skip(current.node->right_data().id()) && do_intersect_obj(query, current.node->right_data())) {\n          intersection = intersection_obj(query, current.node->right_data());\n          if(intersection) {\n            FT ray_distance = boost::apply_visitor(param_visitor, intersection->first);\n            if(ray_distance < t) {\n              t = ray_distance;\n              p = intersection;\n            }\n          }\n        }\n        break;\n      }\n      case 3: // Left child leaf, right child inner node\n      {\n        //left child\n        if(!skip(current.node->left_data().id()) && do_intersect_obj(query, current.node->left_data())) {\n          intersection = intersection_obj(query, current.node->left_data());\n          if(intersection) {\n            FT ray_distance = boost::apply_visitor(param_visitor, intersection->first);\n            if(ray_distance < t) {\n              t = ray_distance;\n              p = intersection;\n            }\n          }\n        }\n\n        // right child\n        const Node* child = &(current.node->right_child());\n        boost::optional< FT > dist = intersection_distance_obj(query, child->bbox());\n        if(dist)\n          pq.push(Node_ptr_with_ft(child, *dist, 2));\n\n        break;\n      }\n      default: // Children both inner nodes\n      {\n        const Node* child = &(current.node->left_child());\n        boost::optional<FT> dist = intersection_distance_obj(query, child->bbox());\n        if(dist)\n          pq.push(Node_ptr_with_ft(child, *dist, current.nb_primitives/2));\n\n        child = &(current.node->right_child());\n        dist = intersection_distance_obj(query, child->bbox());\n        if(dist)\n          pq.push(Node_ptr_with_ft(child, *dist, current.nb_primitives - current.nb_primitives/2));\n\n        break;\n      }\n      }\n    }\n\n    return p;\n  }\nprivate:\n  const AABBTree& tree_;\n  typedef typename AABBTree::Point Point;\n  typedef typename AABBTree::FT FT;\n  typedef typename AABBTree::Node Node;\n  typedef typename AABBTree::size_type size_type;\n\n  struct Node_ptr_with_ft {\n    Node_ptr_with_ft(const Node* node, const FT& value, size_type nb_primitives)\n      : node(node), nb_primitives(nb_primitives), value(value) {}\n    const Node* node;\n    size_type nb_primitives;\n    FT value;\n    bool operator<(const Node_ptr_with_ft& other) const { return value < other.value; }\n    bool operator>(const Node_ptr_with_ft& other) const { return value > other.value; }\n  };\n\n  struct as_ray_param_visitor {\n    typedef FT result_type;\n    as_ray_param_visitor(const Ray* ray) : ray(ray) {}\n\n    template<typename T>\n    FT operator()(const T&)\n    { std::cout << \"not handled\" << std::endl; return FT(); }\n\n    FT operator()(const Point& point) {\n      typename AABB_traits::Geom_traits::Vector_3 x(ray->source(), point);\n      typename AABB_traits::Geom_traits::Vector_3 v = ray->to_vector();\n\n      for(int i = 0; i < 3; ++i) {\n        if(v[0] != FT(0.)) {\n          return x[0] / v[0];\n        }\n      }\n      return FT(0.);\n    }\n\n    const Ray* ray;\n  };\n};\n\ntemplate<typename AABBTraits>\ntemplate<typename Ray, typename SkipFunctor>\nboost::optional< typename AABB_tree<AABBTraits>::template Intersection_and_primitive_id<Ray>::Type >\nAABB_tree<AABBTraits>::ray_intersection(const Ray& query, SkipFunctor skip) const {\n  CGAL_static_assertion_msg((boost::is_same<Ray, typename AABBTraits::Ray_3>::value), \n                            \"Ray and Ray_3 must be the same type\");\n\n  switch(size()) // copy-paste from AABB_tree::traversal\n  {\n  case 0: // Tree empty, nothing to intersect\n    break;\n  case 1: // Tree has 1 node, intersect directly\n    return traits().intersection_object()(query, singleton_data());\n  default: // Tree has >= 2 nodes\n    if(traits().do_intersect_object()(query, root_node()->bbox())) {\n      AABB_ray_intersection< AABB_tree<AABBTraits>, SkipFunctor > ri(*this);\n      return ri.ray_intersection(query, skip);\n    } else {\n      // but we don't hit the root\n      break;\n    }\n  }\n  return boost::none;\n}\n\n}\n\n#endif /* CGAL_AABB_RAY_INTERSECTION_H */\n"}, {"role": "assistant", "content": "Type: None"}]}
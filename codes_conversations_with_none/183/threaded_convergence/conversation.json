{"messages": [{"role": "system", "content": "You are a parallel computing expert. I will provide you a source code in C or C++ and I want you to classify if there is an inefficiency problem in the code. If there is an problem, I want you to classify this problem from the following list: ['Memory/Data locality', 'Micro-architectural inefficiency', 'Vector/SIMD parallelism', 'GPU parallelism', 'Instruction level parallelism', 'Task parallelism', 'small parallel region', 'Inefficeint thread mapping / inefficient block size / Load imbalance', 'Under-parallelization', 'Over-Parallelization', 'Unncessary locks', 'Unncessary strong memory consistency', 'Lock management overhead', 'Unnecessary synchronization', 'Unnecessary process communiction', 'Unnecessary operation/traversal/function call', 'Redundant operation', 'Expensive operation', 'Frequent  function call', 'Inefficient data-structure library', 'Usage of improper data type', 'memory leak', 'repreated memory allocation', 'Redundant memory allocation', 'Slower memory allocation library call', 'Insufficient memory', 'unnecessary data copy', 'sequential I/O operation', 'over parallelization', 'boundary condition check', 'Unintentional Programming logic error', 'Inefficiency due to new compiler version '] and return an answer with the following format and this format only, don't provide explanation: Type: classified_type. If you think there is no inefficiency in the program, return: Type: None"}, {"role": "user", "content": "/** @file threaded_convergence.h\n *\n *  @author Dongryeol Lee (dongryel@cc.gatech.edu)\n */\n\n#ifndef MLPACK_DISTRIBUTED_KPCA_THREADED_CONVERGENCE_H\n#define MLPACK_DISTRIBUTED_KPCA_THREADED_CONVERGENCE_H\n\n#include <boost/scoped_array.hpp>\n#include <pthread.h>\n#include <queue>\n#include \"mlpack/series_expansion/random_feature.h\"\n\nnamespace mlpack {\nnamespace distributed_kpca {\n\ntemplate<typename DistributedTableType>\nclass ThreadedConvergence {\n\n  public:\n    typedef typename DistributedTableType::TableType TableType;\n\n  private:\n\n    struct ThreadedConvergenceArgument {\n\n      int begin_;\n      int end_;\n      double relative_error_;\n      double absolute_error_;\n      double num_standard_deviations_;\n      int num_reference_samples_;\n      int num_random_fourier_features_;\n      DistributedTableType *reference_table_;\n      DistributedTableType *query_table_;\n      core::monte_carlo::MeanVariancePairMatrix *kernel_sums_;\n      std::deque<bool> *converged_;\n      boost::scoped_array< arma::vec > *random_variate_aliases_;\n      core::monte_carlo::MeanVariancePairVector *l1_norm_history_;\n      int max_num_iterations_;\n      int num_iterations_;\n      bool all_local_query_converged_;\n      core::monte_carlo::MeanVariancePairMatrix *global_reference_average_;\n\n      void Init(\n        int begin,\n        int end,\n        double relative_error_in,\n        double absolute_error_in,\n        double num_standard_deviations,\n        int num_reference_samples,\n        DistributedTableType *reference_table_in,\n        DistributedTableType *query_table_in,\n        core::monte_carlo::MeanVariancePairMatrix *kernel_sums,\n        std::deque<bool> &converged,\n        boost::scoped_array< arma::vec > &random_variate_aliases,\n        int num_random_fourier_features,\n        core::monte_carlo::MeanVariancePairVector &l1_norm_history,\n        int num_iterations,\n        int max_num_iterations,\n        core::monte_carlo::MeanVariancePairMatrix *global_reference_average) {\n\n        begin_ = begin;\n        end_ = end;\n        relative_error_ = relative_error_in;\n        absolute_error_ = absolute_error_in;\n        num_standard_deviations_ = num_standard_deviations;\n        num_reference_samples_ = num_reference_samples;\n        num_random_fourier_features_ = num_random_fourier_features;\n        reference_table_ = reference_table_in;\n        query_table_ = query_table_in;\n        kernel_sums_ = kernel_sums;\n        converged_ = &converged;\n        random_variate_aliases_ = &random_variate_aliases;\n        l1_norm_history_ = &l1_norm_history;\n        num_iterations_ = num_iterations;\n        max_num_iterations_ = max_num_iterations;\n        global_reference_average_ = global_reference_average;\n      }\n    };\n\n  private:\n\n    static void *Check_(void *args_in) {\n\n      ThreadedConvergenceArgument &args =\n        *(static_cast<ThreadedConvergenceArgument *>(args_in));\n      args.all_local_query_converged_ = true;\n      for(int i = args.begin_; i < args.end_; i++) {\n\n        if((*args.converged_)[i]) {\n\n          // If already converged, skip.\n          continue;\n        }\n\n        arma::vec query_point;\n        args.query_table_->local_table()->get(i, &query_point);\n        arma::vec query_point_projected;\n        mlpack::series_expansion::RandomFeature<TableType>::Transform(\n          query_point, *args.random_variate_aliases_,\n          args.num_random_fourier_features_, &query_point_projected);\n\n        double l1_norm = 0.0;\n        for(int k = 0; k < args.kernel_sums_->n_rows(); k++) {\n          for(int j = 0; j < args.num_random_fourier_features_; j++) {\n\n            // You need to multiply by the factor of two since Fourier\n            // features come in pairs of cosine and sines.\n            args.kernel_sums_->get(k, i).ScaledCombineWith(\n              2.0 * query_point_projected[j],\n              args.global_reference_average_->get(k, j));\n            args.kernel_sums_->get(k, i).ScaledCombineWith(\n              2.0 * query_point_projected[\n                j + args.num_random_fourier_features_],\n              args.global_reference_average_->get(\n                k, j + args.num_random_fourier_features_));\n          }\n\n          // Add up the frobenius norm contribution.\n          l1_norm += fabs(args.kernel_sums_->get(k, i).sample_mean());\n\n        } // end of checking the given KPCA component.\n\n        // Add to the history.\n        (*args.l1_norm_history_)[i].push_back(l1_norm);\n\n        // Start checking the convergence after 10 iterations.\n        if(args.num_iterations_ > 10) {\n          double left_hand_side =\n            args.num_standard_deviations_ *\n            sqrt(\n              (*args.l1_norm_history_)[i].sample_mean_variance());\n          double right_hand_side =\n            args.relative_error_ * (*args.l1_norm_history_)[i].sample_mean() +\n            args.absolute_error_;\n          (*args.converged_)[i] = (left_hand_side <= right_hand_side);\n        }\n        args.all_local_query_converged_ =\n          (args.all_local_query_converged_ && (*args.converged_)[i]) ||\n          (args.num_iterations_ > args.max_num_iterations_);\n\n      } // end of looping over each local query.\n\n      return NULL;\n    }\n\n  public:\n\n    static bool ThreadedCheck(\n      int num_threads,\n      double relative_error_in,\n      double absolute_error_in,\n      double num_standard_deviations,\n      int num_reference_samples,\n      DistributedTableType *reference_table_in,\n      DistributedTableType *query_table_in,\n      core::monte_carlo::MeanVariancePairMatrix *kernel_sums,\n      std::deque<bool> &converged,\n      boost::scoped_array< arma::vec > &random_variate_aliases,\n      int num_random_fourier_features,\n      core::monte_carlo::MeanVariancePairVector &l1_norm_history,\n      int num_iterations, int max_num_iterations,\n      core::monte_carlo::MeanVariancePairMatrix *global_reference_average) {\n\n      // Basically, store sub-results and combine them later after all\n      // threads are joined.\n      boost::scoped_array<pthread_t> thread_group(\n        new pthread_t[ num_threads - 1 ]);\n      std::vector < ThreadedConvergenceArgument > tmp_arguments(num_threads);\n\n      // The block size.\n      int grain_size = query_table_in->n_entries() / num_threads;\n      for(int i = 0; i < num_threads; i++) {\n        int begin = i * grain_size;\n        int end = (i < num_threads - 1) ?\n                  (i + 1) * grain_size : query_table_in->n_entries();\n        tmp_arguments[i].Init(\n          begin, end, relative_error_in, absolute_error_in,\n          num_standard_deviations, num_reference_samples,\n          reference_table_in, query_table_in, kernel_sums, converged,\n          random_variate_aliases, num_random_fourier_features,\n          l1_norm_history, num_iterations,\n          max_num_iterations, global_reference_average);\n\n        if(i == 0) {\n          Check_(&tmp_arguments[0]);\n        }\n        else {\n          pthread_create(&thread_group[i - 1], NULL,\n                         mlpack::distributed_kpca::ThreadedConvergence <\n                         DistributedTableType >::Check_,\n                         &tmp_arguments[i]);\n        }\n      }\n      for(int i = 1; i < num_threads; i++) {\n        pthread_join(thread_group[i - 1], NULL);\n      }\n\n      bool converged_result = true;\n      for(int i = 0; converged_result && i < num_threads; i++) {\n        converged_result =\n          converged_result && tmp_arguments[i].all_local_query_converged_;\n      }\n\n      return converged_result;\n    }\n};\n}\n}\n\n#endif\n"}, {"role": "assistant", "content": "Type: None"}]}
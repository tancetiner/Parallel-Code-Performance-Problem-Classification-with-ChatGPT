{"messages": [{"role": "system", "content": "You are a parallel computing expert. I will provide you a source code in C or C++ and I want you to classify if there is an inefficiency problem in the code. If there is an problem, I want you to classify this problem from the following list: ['Memory/Data locality', 'Micro-architectural inefficiency', 'Vector/SIMD parallelism', 'GPU parallelism', 'Instruction level parallelism', 'Task parallelism', 'small parallel region', 'Inefficeint thread mapping / inefficient block size / Load imbalance', 'Under-parallelization', 'Over-Parallelization', 'Unncessary locks', 'Unncessary strong memory consistency', 'Lock management overhead', 'Unnecessary synchronization', 'Unnecessary process communiction', 'Unnecessary operation/traversal/function call', 'Redundant operation', 'Expensive operation', 'Frequent  function call', 'Inefficient data-structure library', 'Usage of improper data type', 'memory leak', 'repreated memory allocation', 'Redundant memory allocation', 'Slower memory allocation library call', 'Insufficient memory', 'unnecessary data copy', 'sequential I/O operation', 'over parallelization', 'boundary condition check', 'Unintentional Programming logic error', 'Inefficiency due to new compiler version '] and return an answer with the following format and this format only, don't provide explanation: Type: classified_type. If you think there is no inefficiency in the program, return: Type: None"}, {"role": "user", "content": "/*\\\n *       TCGMSG INTERFACE FOR THE CRAY T3D      \n *\n\\*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <mpp/shmem.h>\n#include \"srftoc.h\"\n\n#define MAXPROC 512 \n\nlong pSync[_SHMEM_BCAST_SYNC_SIZE];  /* workspace needed for shmem system routines */\n\n#ifdef EVENTLOG\n#include \"evlog.h\"\n#endif\n\n#define MAX(a,b) (((a) >= (b)) ? (a) : (b))\n\n#define INCR 1                 /* increment for NXTVAL */\n#define BUSY -1L               /* indicates somebody else updating counter*/\n\nlong nxtval_counter=0;\n\n\nlong DEBUG_ =0;           /* debug flag ... see setdbg */\n\n/* Global variables */\n\nstatic volatile long n_in_msg_q = 0;    /* No. in the message q */\n\n#define MAX_Q_LEN 2048         /* Maximum no. of outstanding messages */\nstatic struct msg_q_struct{\n  long   msg_id;\n  long   node;\n  long   type;\n  long   lenbuf;\n  long   snd;\n  long   from;\n} msg_q[MAX_Q_LEN];\n\n\nextern char *memalign();\nextern copyto(const void *,  void *, long);\n#define MEMCPY(dst, src, n) copyto((src), (dst), (n))\n\nstatic long me, procs;\n/***********************************************************/\n\n\n/*\\ Return number of the calling process ...\n\\*/\nlong NODEID_()\n{\n  return ((long)_my_pe());\n}\n\n\n\n/*\\ Return number of USER tasks/processes\n\\*/\nlong NNODES_()\n{\n  return ((long)_num_pes());\n}\n\n\n\n/*\\ Error handler\n\\*/\nvoid Error(string, code)\n     char *string;\n     long code;\n{\n\n  (void) fflush(stdout);\n\n  (void) fprintf(stdout, \"%3d:%s %ld(%x)\\n\", NODEID_(), string, code, code);\n  (void) fflush(stdout);\n  (void) fprintf(stderr, \"%3d:%s %ld(%x)\\n\", NODEID_(), string, code, code);\n  (void) perror(\"system message\");\n\n  (void) fflush(stdout);\n  (void) fflush(stderr);\n\n  globalexit(1);\n}\n\n\n\n\n\n/*\\ Synchronize processes\n\\*/\nvoid SYNCH_(type)\n     long *type;\n{\n     barrier();\n}\n\n\n/*\\ initialize gops work array\n\\*/\nvoid t3d_gops_init()\n{\n  int node;\n\n  for(node=0;node<_SHMEM_BCAST_SYNC_SIZE;node++)pSync[node] = _SHMEM_SYNC_VALUE;\n}\n\n\nvoid PBEGINF_()\n{\n  PBEGIN_();\n}\n\n\n\n/*\\ Define value of debug flag\n\\*/\nvoid SETDBG_(onoff)\n     long *onoff;\n{\n  DEBUG_ = *onoff;\n}\n\n\n\n/*\\ Get next value of shared counter.\n\\*/\nlong NXTVAL_(mproc)\n     long *mproc;\n/*\n  mproc > 0 ... returns requested value\n  mproc < 0 ... server blocks until abs(mproc) processes are queued\n                and returns junk\n  mproc = 0 ... indicates to server that I am about to terminate\n*/\n{\n  int server = MAX(0, (int) procs - 1);\n  long local; \n\n  me = NODEID_();\n  procs = NNODES_();\n\n  if (*mproc == 0)\n\n    Error(\"NVS: invalid mproc \", mproc);\n\n  else if (*mproc > 0) {\n\n     /* use atomic swap operation to increment nxtval counter */\n\n     while((local = shmem_swap(&nxtval_counter, BUSY, server)) == BUSY);\n     shmem_swap(&nxtval_counter, (local+INCR), server);\n\n  } else if (*mproc < 0) {\n     \n    barrier();\n \n    /* reset the counter value to zero */\n\n    if( NODEID_() == server){\n\n        nxtval_counter = 0;\n\n    }\n    barrier();\n  }\n  if (DEBUG_) {\n        printf(\"NVS: from=%d  mproc=%d value=%d \\n\", me, *mproc, local );\n        (void) fflush(stdout);\n  }\n\n  return(local);\n}\n\n\n\n\nvoid PBFTOC_()\n{\n  Error(\"PBFTOC_: what the hell are we doing here?\",(long) -1);\n}\n\n\n/*\\ Handle request for application error termination\n\\*/\nvoid PARERR_(code)\n  long *code;\n{\n  Error(\"FORTRAN error detected\", *code);\n}\n\n\n/*\\ Print out statistics for communications ... not yet implemented\n\\*/\nvoid STATS_()\n{\n  (void) fprintf(stderr,\"STATS_ not yet supported\\n\");\n  (void) fflush(stderr);\n}\n\n\n/* global operation stuff */\n\n#define MAX(a,b) (((a) >= (b)) ? (a) : (b))\n#define MIN(a,b) (((a) <= (b)) ? (a) : (b))\n#define ABS(a) (((a) >= 0) ? (a) : (-(a)))\n\n#define GPSZ 10000\n#define GOP_WORK_SIZE (MAX(GPSZ, _SHMEM_BCAST_SYNC_SIZE)) /*gops work size*/\n#define GOP_BUF_SIZE  (2*GOP_WORK_SIZE-2)                 /* gops buffer size */\n\nstatic double gop_work[GOP_WORK_SIZE];\nstatic double gop_buf[GOP_BUF_SIZE];\n\n\n\n\nvoid BRDCST_(type, x, bytes, originator)\n     long *type;\n     char *x;\n     long *bytes;\n     long *originator;\n/*\n  broadcast buffer to all other processes from process originator\n  ... all processes call this routine specifying the same\n  orginating process.\n*/\n{\n  long buflen = GOP_BUF_SIZE;\n  int words   = (*bytes+sizeof(long)-1)/sizeof(long);\n  long nleft  = words;\n  long nbuf   = (nleft-1) / buflen + 1;\n  long bytes_to_copy;\n  char *start = x;\n  long *brdcst_buf = (long*)gop_work;\n\n  me = NODEID_();\n  procs = NNODES_();\n\n  if (DEBUG_) {\n        printf(\"BRDCST: me=%2ld  originator=%2ld  %d bytes\\n\", me, *originator,\n               *bytes );\n        (void) fflush(stdout);\n  }\n\n\n  buflen = (nleft-1) / nbuf + 1;\n\n  if(((long)x)%sizeof(long))\n     Error(\"t3d broadcast: buffer must be alligned on 8-byte boundary: \",(long) x);\n\n  while (nleft) {\n    long ndo = MIN(nleft, buflen);\n\n    barrier(); /* synchronize to make sure that nobody is accessing pSync */\n    shmem_broadcast(brdcst_buf, (long*)x, ndo, (int)*originator, 0, 0, \n                   (int)procs, pSync);\n    if(me!= *originator){\n          bytes_to_copy =  (long)( (start + *bytes <= x + ndo*sizeof(long)) ? \n                                    ndo*sizeof(long) : start + *bytes - x);\n          \n          MEMCPY(x,brdcst_buf,bytes_to_copy);\n    }\n    nleft -= ndo; x+= ndo*sizeof(long);\n  }\n  if (DEBUG_) {\n        printf(\"BRDCST: me=%2ld  done,   long value=%ld \\n\", me,*(long*)start);\n        (void) fflush(stdout);\n  }\n}\n\n\n\nvoid DGOP_(ptype, x, pn, op)\n     double *x;\n     long *ptype, *pn;\n     char *op;\n{\n  double *work = gop_work;\n  double *y    = gop_buf;\n  long nleft  = *pn;\n  long buflen = MIN(nleft,GOP_BUF_SIZE); /* Try to get even sized buffers */\n  long nbuf   = (nleft-1) / buflen + 1;\n  long n;\n  me = NODEID_();\n  procs = NNODES_();\n\n  buflen = (nleft-1) / nbuf + 1;\n\n  barrier();\n\n  if (strncmp(op,\"abs\",3) == 0) {\n    n = *pn;\n    while(n--) x[n] = ABS(x[n]);\n  } \n  \n  while (nleft) {\n    long ndo = MIN(nleft, buflen);\n\n    MEMCPY(y,x,ndo*sizeof(double));\n    if (strncmp(op,\"+\",1) == 0)\n      shmem_double_sum_to_all(y, y, ndo, 0, 0, procs, work, pSync);\n    else if (strncmp(op,\"*\",1) == 0)\n      shmem_double_prod_to_all(y, y, ndo, 0, 0, procs, work, pSync);\n    else if (strncmp(op,\"max\",3) == 0 || strncmp(op,\"absmax\",6) == 0)\n      shmem_double_max_to_all(y, y, ndo, 0, 0, procs, work, pSync);\n    else if (strncmp(op,\"min\",3) == 0 || strncmp(op,\"absmin\",6) == 0)\n      shmem_double_min_to_all(y, y, ndo, 0, 0, procs, work, pSync);\n    else\n      Error(\"DGOP: unknown operation requested\", (long) *pn);\n\n    MEMCPY(x,y,ndo*sizeof(double));\n    nleft -= ndo; x+= ndo;\n  }\n}\n\n\nvoid IGOP_(ptype, x, pn, op)\n     int *x;\n     int *ptype, *pn;\n     char *op;\n{\n  int *work  = (int*) gop_work;\n  int *y     = (int*) gop_buf;\n  int nleft  = *pn;\n  int buflen = MIN(nleft,GOP_BUF_SIZE); /* Try to get even sized buffers */\n  int nbuf   = (nleft-1) / buflen + 1;\n  int n;\n  me = NODEID_();\n  procs = NNODES_();\n\n  buflen = (nleft-1) / nbuf + 1;\n\n  barrier();\n\n  if (strncmp(op,\"abs\",3) == 0) {\n    n = *pn;\n    while(n--) x[n] = ABS(x[n]);\n  } \n  \n  while (nleft) {\n    int ndo = MIN(nleft, buflen);\n\n    MEMCPY(y,x,ndo*sizeof(int));\n    if (strncmp(op,\"+\",1) == 0)\n      shmem_int_sum_to_all(y, y, ndo, 0, 0, procs, work, pSync);\n    else if (strncmp(op,\"*\",1) == 0)\n      shmem_int_prod_to_all(y, y, ndo, 0, 0, procs, work, pSync);\n    else if (strncmp(op,\"max\",3) == 0 || strncmp(op,\"absmax\",6) == 0)\n      shmem_int_max_to_all(y, y, ndo, 0, 0, procs, work, pSync);\n    else if (strncmp(op,\"min\",3) == 0 || strncmp(op,\"absmax\",6) == 0)\n      shmem_int_min_to_all(y, y, ndo, 0, 0, procs, work, pSync);\n    else if (strncmp(op,\"or\",2) == 0)\n      shmem_int_or_to_all(y, y, ndo, 0, 0, procs, work, pSync);\n    else\n      Error(\"IGOP: unknown operation requested\", (long) *pn);\n\n    MEMCPY(x,y,ndo*sizeof(int));\n    nleft -= ndo; x+= ndo;\n  }\n}\n\n\n"}, {"role": "assistant", "content": "Type: Memory/Data locality."}]}
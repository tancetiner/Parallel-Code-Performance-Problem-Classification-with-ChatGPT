{"messages": [{"role": "system", "content": "You are a parallel computing expert. I will provide you a source code in C or C++ and I want you to classify if there is an inefficiency problem in the code. If there is an problem, I want you to classify this problem from the following list: ['Memory/Data locality', 'Micro-architectural inefficiency', 'Vector/SIMD parallelism', 'GPU parallelism', 'Instruction level parallelism', 'Task parallelism', 'small parallel region', 'Inefficeint thread mapping / inefficient block size / Load imbalance', 'Under-parallelization', 'Over-Parallelization', 'Unncessary locks', 'Unncessary strong memory consistency', 'Lock management overhead', 'Unnecessary synchronization', 'Unnecessary process communiction', 'Unnecessary operation/traversal/function call', 'Redundant operation', 'Expensive operation', 'Frequent  function call', 'Inefficient data-structure library', 'Usage of improper data type', 'memory leak', 'repreated memory allocation', 'Redundant memory allocation', 'Slower memory allocation library call', 'Insufficient memory', 'unnecessary data copy', 'sequential I/O operation', 'over parallelization', 'boundary condition check', 'Unintentional Programming logic error', 'Inefficiency due to new compiler version '] and return an answer with the following format and this format only, don't provide explanation: Type: classified_type. If you think there is no inefficiency in the program, return: Type: None"}, {"role": "user", "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <ctype.h>\n#include \"common.h\"\n#ifdef FUNCTION_PROFILE\n#include \"functable.h\"\n#endif\n\n#ifndef TRMM\n#ifndef COMPLEX\n#ifdef XDOUBLE\n#define ERROR_NAME \"QTRSM \"\n#elif defined(DOUBLE)\n#define ERROR_NAME \"DTRSM \"\n#else\n#define ERROR_NAME \"STRSM \"\n#endif\n#else\n#ifdef XDOUBLE\n#define ERROR_NAME \"XTRSM \"\n#elif defined(DOUBLE)\n#define ERROR_NAME \"ZTRSM \"\n#else\n#define ERROR_NAME \"CTRSM \"\n#endif\n#endif\n#else\n#ifndef COMPLEX\n#ifdef XDOUBLE\n#define ERROR_NAME \"QTRMM \"\n#elif defined(DOUBLE)\n#define ERROR_NAME \"DTRMM \"\n#else\n#define ERROR_NAME \"STRMM \"\n#endif\n#else\n#ifdef XDOUBLE\n#define ERROR_NAME \"XTRMM \"\n#elif defined(DOUBLE)\n#define ERROR_NAME \"ZTRMM \"\n#else\n#define ERROR_NAME \"CTRMM \"\n#endif\n#endif\n#endif\n\nstatic int (*trsm[])(blas_arg_t *, BLASLONG *, BLASLONG *, FLOAT *, FLOAT *, BLASLONG) = {\n#ifndef TRMM\n  TRSM_LNUU, TRSM_LNUN, TRSM_LNLU, TRSM_LNLN,\n  TRSM_LTUU, TRSM_LTUN, TRSM_LTLU, TRSM_LTLN,\n  TRSM_LRUU, TRSM_LRUN, TRSM_LRLU, TRSM_LRLN,\n  TRSM_LCUU, TRSM_LCUN, TRSM_LCLU, TRSM_LCLN,\n  TRSM_RNUU, TRSM_RNUN, TRSM_RNLU, TRSM_RNLN,\n  TRSM_RTUU, TRSM_RTUN, TRSM_RTLU, TRSM_RTLN,\n  TRSM_RRUU, TRSM_RRUN, TRSM_RRLU, TRSM_RRLN,\n  TRSM_RCUU, TRSM_RCUN, TRSM_RCLU, TRSM_RCLN,\n#else\n  TRMM_LNUU, TRMM_LNUN, TRMM_LNLU, TRMM_LNLN,\n  TRMM_LTUU, TRMM_LTUN, TRMM_LTLU, TRMM_LTLN,\n  TRMM_LRUU, TRMM_LRUN, TRMM_LRLU, TRMM_LRLN,\n  TRMM_LCUU, TRMM_LCUN, TRMM_LCLU, TRMM_LCLN,\n  TRMM_RNUU, TRMM_RNUN, TRMM_RNLU, TRMM_RNLN,\n  TRMM_RTUU, TRMM_RTUN, TRMM_RTLU, TRMM_RTLN,\n  TRMM_RRUU, TRMM_RRUN, TRMM_RRLU, TRMM_RRLN,\n  TRMM_RCUU, TRMM_RCUN, TRMM_RCLU, TRMM_RCLN,\n#endif\n};\n\n#ifndef CBLAS\n\nvoid NAME(char *SIDE, char *UPLO, char *TRANS, char *DIAG,\n\t   blasint *M, blasint *N, FLOAT *alpha,\n\t   FLOAT *a, blasint *ldA, FLOAT *b, blasint *ldB){\n\n  char side_arg  = *SIDE;\n  char uplo_arg  = *UPLO;\n  char trans_arg = *TRANS;\n  char diag_arg  = *DIAG;\n\n  blas_arg_t args;\n\n  FLOAT *buffer;\n  FLOAT *sa, *sb;\n\n#ifdef SMP\n#ifndef COMPLEX\n#ifdef XDOUBLE\n  int mode  =  BLAS_XDOUBLE | BLAS_REAL;\n#elif defined(DOUBLE)\n  int mode  =  BLAS_DOUBLE  | BLAS_REAL;\n#else\n  int mode  =  BLAS_SINGLE  | BLAS_REAL;\n#endif\n#else\n#ifdef XDOUBLE\n  int mode  =  BLAS_XDOUBLE | BLAS_COMPLEX;\n#elif defined(DOUBLE)\n  int mode  =  BLAS_DOUBLE  | BLAS_COMPLEX;\n#else\n  int mode  =  BLAS_SINGLE  | BLAS_COMPLEX;\n#endif\n#endif\n#endif\n\n  blasint info;\n  int side;\n  int uplo;\n  int unit;\n  int trans;\n  int nrowa;\n\n  PRINT_DEBUG_NAME;\n\n  args.m = *M;\n  args.n = *N;\n\n  args.a = (void *)a;\n  args.b = (void *)b;\n\n  args.lda = *ldA;\n  args.ldb = *ldB;\n\n  args.beta = (void *)alpha;\n\n  TOUPPER(side_arg);\n  TOUPPER(uplo_arg);\n  TOUPPER(trans_arg);\n  TOUPPER(diag_arg);\n\n  side  = -1;\n  trans = -1;\n  unit  = -1;\n  uplo  = -1;\n\n  if (side_arg  == 'L') side  = 0;\n  if (side_arg  == 'R') side  = 1;\n\n  if (trans_arg == 'N') trans = 0;\n  if (trans_arg == 'T') trans = 1;\n  if (trans_arg == 'R') trans = 2;\n  if (trans_arg == 'C') trans = 3;\n\n  if (diag_arg  == 'U') unit  = 0;\n  if (diag_arg  == 'N') unit  = 1;\n\n  if (uplo_arg  == 'U') uplo  = 0;\n  if (uplo_arg  == 'L') uplo  = 1;\n\n  nrowa = args.m;\n  if (side & 1) nrowa = args.n;\n\n  info = 0;\n\n  if (args.ldb < MAX(1,args.m)) info = 11;\n  if (args.lda < MAX(1,nrowa))  info =  9;\n  if (args.n < 0)               info =  6;\n  if (args.m < 0)               info =  5;\n  if (unit < 0)                 info =  4;\n  if (trans < 0)                info =  3;\n  if (uplo  < 0)                info =  2;\n  if (side  < 0)                info =  1;\n\n  if (info != 0) {\n    BLASFUNC(xerbla)(ERROR_NAME, &info, sizeof(ERROR_NAME));\n    return;\n  }\n\n#else\n\nvoid CNAME(enum CBLAS_ORDER order,\n\t   enum CBLAS_SIDE Side,  enum CBLAS_UPLO Uplo,\n\t   enum CBLAS_TRANSPOSE Trans, enum CBLAS_DIAG Diag,\n\t   blasint m, blasint n,\n#ifndef COMPLEX\n\t   FLOAT alpha,\n\t   FLOAT *a, blasint lda,\n\t   FLOAT *b, blasint ldb) {\n#else\n\t   void *valpha,\n\t   void *va, blasint lda,\n\t   void *vb, blasint ldb) {\n  FLOAT *alpha = (FLOAT*) valpha;\n  FLOAT *a = (FLOAT*) va;\n  FLOAT *b = (FLOAT*) vb;\n#endif\n\n  blas_arg_t args;\n  int side, uplo, trans, unit;\n  blasint info, nrowa;\n\n  XFLOAT *buffer;\n  XFLOAT *sa, *sb;\n\n#ifdef SMP\n#ifndef COMPLEX\n#ifdef XDOUBLE\n  int mode  =  BLAS_XDOUBLE | BLAS_REAL;\n#elif defined(DOUBLE)\n  int mode  =  BLAS_DOUBLE  | BLAS_REAL;\n#else\n  int mode  =  BLAS_SINGLE  | BLAS_REAL;\n#endif\n#else\n#ifdef XDOUBLE\n  int mode  =  BLAS_XDOUBLE | BLAS_COMPLEX;\n#elif defined(DOUBLE)\n  int mode  =  BLAS_DOUBLE  | BLAS_COMPLEX;\n#else\n  int mode  =  BLAS_SINGLE  | BLAS_COMPLEX;\n#endif\n#endif\n#endif\n\n  PRINT_DEBUG_CNAME;\n\n  args.a = (void *)a;\n  args.b = (void *)b;\n\n  args.lda = lda;\n  args.ldb = ldb;\n\n#ifndef COMPLEX\n  args.beta = (void *)&alpha;\n#else\n  args.beta = (void *)alpha;\n#endif\n\n  side   = -1;\n  uplo   = -1;\n  trans  = -1;\n  unit   = -1;\n  info   =  0;\n\n  if (order == CblasColMajor) {\n    args.m = m;\n    args.n = n;\n\n    if (Side == CblasLeft)         side  = 0;\n    if (Side == CblasRight)        side  = 1;\n\n    if (Uplo == CblasUpper)        uplo  = 0;\n    if (Uplo == CblasLower)        uplo  = 1;\n\n    if (Trans == CblasNoTrans)     trans = 0;\n    if (Trans == CblasTrans)       trans = 1;\n#ifndef COMPLEX\n    if (Trans == CblasConjNoTrans) trans = 0;\n    if (Trans == CblasConjTrans)   trans = 1;\n#else\n    if (Trans == CblasConjNoTrans) trans = 2;\n    if (Trans == CblasConjTrans)   trans = 3;\n#endif\n\n    if (Diag == CblasUnit)          unit  = 0;\n    if (Diag == CblasNonUnit)       unit  = 1;\n\n    info = -1;\n\n    nrowa = args.m;\n    if (side & 1) nrowa = args.n;\n\n    if (args.ldb < MAX(1,args.m)) info = 11;\n    if (args.lda < MAX(1,nrowa))  info =  9;\n    if (args.n < 0)               info =  6;\n    if (args.m < 0)               info =  5;\n    if (unit < 0)                 info =  4;\n    if (trans < 0)                info =  3;\n    if (uplo  < 0)                info =  2;\n    if (side  < 0)                info =  1;\n  }\n\n  if (order == CblasRowMajor) {\n    args.m = n;\n    args.n = m;\n\n    if (Side == CblasLeft)         side  = 1;\n    if (Side == CblasRight)        side  = 0;\n\n    if (Uplo == CblasUpper)        uplo  = 1;\n    if (Uplo == CblasLower)        uplo  = 0;\n\n    if (Trans == CblasNoTrans)     trans = 0;\n    if (Trans == CblasTrans)       trans = 1;\n#ifndef COMPLEX\n    if (Trans == CblasConjNoTrans) trans = 0;\n    if (Trans == CblasConjTrans)   trans = 1;\n#else\n    if (Trans == CblasConjNoTrans) trans = 2;\n    if (Trans == CblasConjTrans)   trans = 3;\n#endif\n\n    if (Diag == CblasUnit)         unit  = 0;\n    if (Diag == CblasNonUnit)      unit  = 1;\n\n    info = -1;\n\n    nrowa = args.m;\n    if (side & 1) nrowa = args.n;\n\n    if (args.ldb < MAX(1,args.m)) info = 11;\n    if (args.lda < MAX(1,nrowa))  info =  9;\n    if (args.n < 0)               info =  6;\n    if (args.m < 0)               info =  5;\n    if (unit < 0)                 info =  4;\n    if (trans < 0)                info =  3;\n    if (uplo  < 0)                info =  2;\n    if (side  < 0)                info =  1;\n  }\n\n  if (info >= 0) {\n    BLASFUNC(xerbla)(ERROR_NAME, &info, sizeof(ERROR_NAME));\n    return;\n  }\n\n#endif\n\n  if ((args.m == 0) || (args.n == 0)) return;\n\n  IDEBUG_START;\n\n  FUNCTION_PROFILE_START();\n\n  buffer = (FLOAT *)blas_memory_alloc(0);\n\n  sa = (FLOAT *)((BLASLONG)buffer + GEMM_OFFSET_A);\n  sb = (FLOAT *)(((BLASLONG)sa + ((GEMM_P * GEMM_Q * COMPSIZE * SIZE + GEMM_ALIGN) & ~GEMM_ALIGN)) + GEMM_OFFSET_B);\n\n#ifdef SMP\n  mode |= (trans << BLAS_TRANSA_SHIFT);\n  mode |= (side  << BLAS_RSIDE_SHIFT);\n\n  args.nthreads = num_cpu_avail(3);\n  if ( args.m < 2*GEMM_MULTITHREAD_THRESHOLD )\n\targs.nthreads = 1;\n  else\n\tif ( args.n < 2*GEMM_MULTITHREAD_THRESHOLD )\n\t\targs.nthreads = 1;\n\t\t\n\n  if (args.nthreads == 1) {\n#endif\n\n    (trsm[(side<<4) | (trans<<2) | (uplo<<1) | unit])(&args, NULL, NULL, sa, sb, 0);\n\n#ifdef SMP\n  } else {\n    if (!side) {\n      gemm_thread_n(mode, &args, NULL, NULL, trsm[(side<<4) | (trans<<2) | (uplo<<1) | unit], sa, sb, args.nthreads);\n    } else {\n      gemm_thread_m(mode, &args, NULL, NULL, trsm[(side<<4) | (trans<<2) | (uplo<<1) | unit], sa, sb, args.nthreads);\n    }\n  }\n#endif\n\n  blas_memory_free(buffer);\n\n  FUNCTION_PROFILE_END(COMPSIZE * COMPSIZE,\n\t\t       (!side) ? args.m * (args.m + args.n) : args.n * (args.m + args.n),\n\t\t       (!side) ? args.m * args.m * args.n : args.m * args.n * args.n);\n\n  IDEBUG_END;\n\n  return;\n}\n\n"}, {"role": "assistant", "content": "Type: None"}]}
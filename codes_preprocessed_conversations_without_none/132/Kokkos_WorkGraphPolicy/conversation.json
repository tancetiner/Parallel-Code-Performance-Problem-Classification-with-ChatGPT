{"messages": [{"role": "system", "content": "You are a parallel computing expert. I will provide you a source code in C or C++ and I want you to classify if there is an inefficiency problem in the code. If there is an problem, I want you to classify this problem from the following list: ['Memory/Data locality', 'Micro-architectural inefficiency', 'Vector/SIMD parallelism', 'GPU parallelism', 'Instruction level parallelism', 'Task parallelism', 'small parallel region', 'Inefficeint thread mapping / inefficient block size / Load imbalance', 'Under-parallelization', 'Over-Parallelization', 'Unncessary locks', 'Unncessary strong memory consistency', 'Lock management overhead', 'Unnecessary synchronization', 'Unnecessary process communiction', 'Unnecessary operation/traversal/function call', 'Redundant operation', 'Expensive operation', 'Frequent  function call', 'Inefficient data-structure library', 'Usage of improper data type', 'memory leak', 'repreated memory allocation', 'Redundant memory allocation', 'Slower memory allocation library call', 'Insufficient memory', 'unnecessary data copy', 'sequential I/O operation', 'over parallelization', 'boundary condition check', 'Unintentional Programming logic error', 'Inefficiency due to new compiler version '] and return an answer with the following format and this format only, don't provide explanation: Type: classified_type."}, {"role": "user", "content": "#ifndef KOKKOS_WORKGRAPHPOLICY_HPP #define KOKKOS_WORKGRAPHPOLICY_HPP namespace Kokkos { namespace Impl { template< class functor_type , class execution_space, class ... policy_args > class WorkGraphExec; }} namespace Kokkos { template< class ... Properties > class WorkGraphPolicy { public: using self_type = WorkGraphPolicy<Properties ... >; using traits = Kokkos::Impl::PolicyTraits<Properties ... >; using index_type = typename traits::index_type; using member_type = index_type; using work_tag = typename traits::work_tag; using execution_space = typename traits::execution_space; using memory_space = typename execution_space::memory_space; using graph_type = Kokkos::Crs<index_type,execution_space,void,index_type>; enum : std::int32_t { END_TOKEN = -1 , BEGIN_TOKEN = -2 , COMPLETED_TOKEN = -3 }; private: using ints_type = Kokkos::View<std::int32_t*, memory_space>; graph_type const m_graph; ints_type m_queue ; KOKKOS_INLINE_FUNCTION void push_work( const std::int32_t w ) const noexcept { const std::int32_t N = m_graph.numRows(); std::int32_t volatile * const ready_queue = & m_queue[0] ; std::int32_t volatile * const end_hint = & m_queue[2*N+1] ; const std::int32_t j = atomic_fetch_add( end_hint , 1 ); if ( ( N <= j ) || ( END_TOKEN != atomic_exchange(ready_queue+j,w) ) ) { Kokkos::abort(\"WorkGraphPolicy push_work error\"); } memory_fence(); } public: KOKKOS_INLINE_FUNCTION std::int32_t pop_work() const noexcept { const std::int32_t N = m_graph.numRows(); std::int32_t volatile * const ready_queue = & m_queue[0] ; std::int32_t volatile * const begin_hint = & m_queue[2*N] ; for ( std::int32_t i = *begin_hint ; i < N ; ++i ) { const std::int32_t w = ready_queue[i] ; if ( w == END_TOKEN ) { return END_TOKEN ; } if ( ( w != BEGIN_TOKEN ) && ( w == atomic_compare_exchange<std::int32_t>(ready_queue+i,w,BEGIN_TOKEN) ) ) { atomic_increment( begin_hint ); return w ; } } return COMPLETED_TOKEN ; } KOKKOS_INLINE_FUNCTION void completed_work( std::int32_t w ) const noexcept { Kokkos::memory_fence(); const std::int32_t N = m_graph.numRows(); std::int32_t volatile * const count_queue = & m_queue[N] ; const std::int32_t B = m_graph.row_map(w); const std::int32_t E = m_graph.row_map(w+1); for ( std::int32_t i = B ; i < E ; ++i ) { const std::int32_t j = m_graph.entries(i); if ( 1 == atomic_fetch_add(count_queue+j,-1) ) { push_work(j); } } } struct TagInit {}; struct TagCount {}; struct TagReady {}; KOKKOS_INLINE_FUNCTION void operator()( const TagInit , int i ) const noexcept { m_queue[i] = i < m_graph.numRows() ? END_TOKEN : 0 ; } KOKKOS_INLINE_FUNCTION void operator()( const TagCount , int i ) const noexcept { std::int32_t volatile * const count_queue = & m_queue[ m_graph.numRows() ] ; atomic_increment( count_queue + m_graph.entries[i] ); } KOKKOS_INLINE_FUNCTION void operator()( const TagReady , int w ) const noexcept { std::int32_t const * const count_queue = & m_queue[ m_graph.numRows() ] ; if ( 0 == count_queue[w] ) push_work(w); } WorkGraphPolicy( const graph_type & arg_graph ) : m_graph(arg_graph) , m_queue( view_alloc( \"queue\" , WithoutInitializing ) , arg_graph.numRows() * 2 + 2 ) { { using policy_type = RangePolicy<std::int32_t, execution_space, TagInit>; using closure_type = Kokkos::Impl::ParallelFor<self_type, policy_type>; const closure_type closure(*this, policy_type(0, m_queue.size())); closure.execute(); execution_space::fence(); } { using policy_type = RangePolicy<std::int32_t, execution_space, TagCount>; using closure_type = Kokkos::Impl::ParallelFor<self_type, policy_type>; const closure_type closure(*this,policy_type(0,m_graph.entries.size())); closure.execute(); execution_space::fence(); } { using policy_type = RangePolicy<std::int32_t, execution_space, TagReady>; using closure_type = Kokkos::Impl::ParallelFor<self_type, policy_type>; const closure_type closure(*this,policy_type(0,m_graph.numRows())); closure.execute(); execution_space::fence(); } } }; } #ifdef KOKKOS_ENABLE_SERIAL #include \"impl/Kokkos_Serial_WorkGraphPolicy.hpp\" #endif #ifdef KOKKOS_ENABLE_OPENMP #include \"OpenMP/Kokkos_OpenMP_WorkGraphPolicy.hpp\" #endif #ifdef KOKKOS_ENABLE_CUDA #include \"Cuda/Kokkos_Cuda_WorkGraphPolicy.hpp\" #endif #ifdef KOKKOS_ENABLE_THREADS #include \"Threads/Kokkos_Threads_WorkGraphPolicy.hpp\" #endif #endif"}, {"role": "assistant", "content": "Type: Task parallelism."}]}